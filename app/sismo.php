<?php 
/*Copyright (c) 2009-2013 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

 namespace { class Twig_Environment { const VERSION ='1.12.2'; protected $charset; protected $loader; protected $debug; protected $autoReload; protected $cache; protected $lexer; protected $parser; protected $compiler; protected $baseTemplateClass; protected $extensions; protected $parsers; protected $visitors; protected $filters; protected $tests; protected $functions; protected $globals; protected $runtimeInitialized; protected $extensionInitialized; protected $loadedTemplates; protected $strictVariables; protected $unaryOperators; protected $binaryOperators; protected $templateClassPrefix ='__TwigTemplate_'; protected $functionCallbacks; protected $filterCallbacks; protected $staging; public function __construct(Twig_LoaderInterface $loader = null, $options = array()) { if (null !== $loader) { $this->setLoader($loader); } $options = array_merge(array('debug'=> false,'charset'=>'UTF-8','base_template_class'=>'Twig_Template','strict_variables'=> false,'autoescape'=>'html','cache'=> false,'auto_reload'=> null,'optimizations'=> -1, ), $options); $this->debug = (bool) $options['debug']; $this->charset = $options['charset']; $this->baseTemplateClass = $options['base_template_class']; $this->autoReload = null === $options['auto_reload'] ? $this->debug : (bool) $options['auto_reload']; $this->strictVariables = (bool) $options['strict_variables']; $this->runtimeInitialized = false; $this->setCache($options['cache']); $this->functionCallbacks = array(); $this->filterCallbacks = array(); $this->addExtension(new Twig_Extension_Core()); $this->addExtension(new Twig_Extension_Escaper($options['autoescape'])); $this->addExtension(new Twig_Extension_Optimizer($options['optimizations'])); $this->extensionInitialized = false; $this->staging = new Twig_Extension_Staging(); } public function getBaseTemplateClass() { return $this->baseTemplateClass; } public function setBaseTemplateClass($class) { $this->baseTemplateClass = $class; } public function enableDebug() { $this->debug = true; } public function disableDebug() { $this->debug = false; } public function isDebug() { return $this->debug; } public function enableAutoReload() { $this->autoReload = true; } public function disableAutoReload() { $this->autoReload = false; } public function isAutoReload() { return $this->autoReload; } public function enableStrictVariables() { $this->strictVariables = true; } public function disableStrictVariables() { $this->strictVariables = false; } public function isStrictVariables() { return $this->strictVariables; } public function getCache() { return $this->cache; } public function setCache($cache) { $this->cache = $cache ? $cache : false; } public function getCacheFilename($name) { if (false === $this->cache) { return false; } $class = substr($this->getTemplateClass($name), strlen($this->templateClassPrefix)); return $this->getCache().'/'.substr($class, 0, 2).'/'.substr($class, 2, 2).'/'.substr($class, 4).'.php'; } public function getTemplateClass($name, $index = null) { return $this->templateClassPrefix.md5($this->getLoader()->getCacheKey($name)).(null === $index ?'':'_'.$index); } public function getTemplateClassPrefix() { return $this->templateClassPrefix; } public function render($name, array $context = array()) { return $this->loadTemplate($name)->render($context); } public function display($name, array $context = array()) { $this->loadTemplate($name)->display($context); } public function loadTemplate($name, $index = null) { $cls = $this->getTemplateClass($name, $index); if (isset($this->loadedTemplates[$cls])) { return $this->loadedTemplates[$cls]; } if (!class_exists($cls, false)) { if (false === $cache = $this->getCacheFilename($name)) { eval('?>'.$this->compileSource($this->getLoader()->getSource($name), $name)); } else { if (!is_file($cache) || ($this->isAutoReload() && !$this->isTemplateFresh($name, filemtime($cache)))) { $this->writeCacheFile($cache, $this->compileSource($this->getLoader()->getSource($name), $name)); } } } if (!$this->runtimeInitialized) { $this->initRuntime(); } return $this->loadedTemplates[$cls] = new $cls($this); } public function isTemplateFresh($name, $time) { foreach ($this->extensions as $extension) { $r = new ReflectionObject($extension); if (filemtime($r->getFileName()) > $time) { return false; } } return $this->getLoader()->isFresh($name, $time); } public function resolveTemplate($names) { if (!is_array($names)) { $names = array($names); } foreach ($names as $name) { if ($name instanceof Twig_Template) { return $name; } try { return $this->loadTemplate($name); } catch (Twig_Error_Loader $e) { } } if (1 === count($names)) { throw $e; } throw new Twig_Error_Loader(sprintf('Unable to find one of the following templates: "%s".', implode('", "', $names))); } public function clearTemplateCache() { $this->loadedTemplates = array(); } public function clearCacheFiles() { if (false === $this->cache) { return; } foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->cache), RecursiveIteratorIterator::LEAVES_ONLY) as $file) { if ($file->isFile()) { @unlink($file->getPathname()); } } } public function getLexer() { if (null === $this->lexer) { $this->lexer = new Twig_Lexer($this); } return $this->lexer; } public function setLexer(Twig_LexerInterface $lexer) { $this->lexer = $lexer; } public function tokenize($source, $name = null) { return $this->getLexer()->tokenize($source, $name); } public function getParser() { if (null === $this->parser) { $this->parser = new Twig_Parser($this); } return $this->parser; } public function setParser(Twig_ParserInterface $parser) { $this->parser = $parser; } public function parse(Twig_TokenStream $tokens) { return $this->getParser()->parse($tokens); } public function getCompiler() { if (null === $this->compiler) { $this->compiler = new Twig_Compiler($this); } return $this->compiler; } public function setCompiler(Twig_CompilerInterface $compiler) { $this->compiler = $compiler; } public function compile(Twig_NodeInterface $node) { return $this->getCompiler()->compile($node)->getSource(); } public function compileSource($source, $name = null) { try { return $this->compile($this->parse($this->tokenize($source, $name))); } catch (Twig_Error $e) { $e->setTemplateFile($name); throw $e; } catch (Exception $e) { throw new Twig_Error_Runtime(sprintf('An exception has been thrown during the compilation of a template ("%s").', $e->getMessage()), -1, $name, $e); } } public function setLoader(Twig_LoaderInterface $loader) { $this->loader = $loader; } public function getLoader() { if (null === $this->loader) { throw new LogicException('You must set a loader first.'); } return $this->loader; } public function setCharset($charset) { $this->charset = $charset; } public function getCharset() { return $this->charset; } public function initRuntime() { $this->runtimeInitialized = true; foreach ($this->getExtensions() as $extension) { $extension->initRuntime($this); } } public function hasExtension($name) { return isset($this->extensions[$name]); } public function getExtension($name) { if (!isset($this->extensions[$name])) { throw new Twig_Error_Runtime(sprintf('The "%s" extension is not enabled.', $name)); } return $this->extensions[$name]; } public function addExtension(Twig_ExtensionInterface $extension) { if ($this->extensionInitialized) { throw new LogicException(sprintf('Unable to register extension "%s" as extensions have already been initialized.', $extension->getName())); } $this->extensions[$extension->getName()] = $extension; } public function removeExtension($name) { if ($this->extensionInitialized) { throw new LogicException(sprintf('Unable to remove extension "%s" as extensions have already been initialized.', $name)); } unset($this->extensions[$name]); } public function setExtensions(array $extensions) { foreach ($extensions as $extension) { $this->addExtension($extension); } } public function getExtensions() { return $this->extensions; } public function addTokenParser(Twig_TokenParserInterface $parser) { if ($this->extensionInitialized) { throw new LogicException('Unable to add a token parser as extensions have already been initialized.'); } $this->staging->addTokenParser($parser); } public function getTokenParsers() { if (!$this->extensionInitialized) { $this->initExtensions(); } return $this->parsers; } public function getTags() { $tags = array(); foreach ($this->getTokenParsers()->getParsers() as $parser) { if ($parser instanceof Twig_TokenParserInterface) { $tags[$parser->getTag()] = $parser; } } return $tags; } public function addNodeVisitor(Twig_NodeVisitorInterface $visitor) { if ($this->extensionInitialized) { throw new LogicException('Unable to add a node visitor as extensions have already been initialized.', $extension->getName()); } $this->staging->addNodeVisitor($visitor); } public function getNodeVisitors() { if (!$this->extensionInitialized) { $this->initExtensions(); } return $this->visitors; } public function addFilter($name, $filter = null) { if ($this->extensionInitialized) { throw new LogicException(sprintf('Unable to add filter "%s" as extensions have already been initialized.', $name)); } if (!$name instanceof Twig_SimpleFilter && !($filter instanceof Twig_SimpleFilter || $filter instanceof Twig_FilterInterface)) { throw new LogicException('A filter must be an instance of Twig_FilterInterface or Twig_SimpleFilter'); } if ($name instanceof Twig_SimpleFilter) { $filter = $name; $name = $filter->getName(); } $this->staging->addFilter($name, $filter); } public function getFilter($name) { if (!$this->extensionInitialized) { $this->initExtensions(); } if (isset($this->filters[$name])) { return $this->filters[$name]; } foreach ($this->filters as $pattern => $filter) { $pattern = str_replace('\\*','(.*?)', preg_quote($pattern,'#'), $count); if ($count) { if (preg_match('#^'.$pattern.'$#', $name, $matches)) { array_shift($matches); $filter->setArguments($matches); return $filter; } } } foreach ($this->filterCallbacks as $callback) { if (false !== $filter = call_user_func($callback, $name)) { return $filter; } } return false; } public function registerUndefinedFilterCallback($callable) { $this->filterCallbacks[] = $callable; } public function getFilters() { if (!$this->extensionInitialized) { $this->initExtensions(); } return $this->filters; } public function addTest($name, $test = null) { if ($this->extensionInitialized) { throw new LogicException(sprintf('Unable to add test "%s" as extensions have already been initialized.', $name)); } if (!$name instanceof Twig_SimpleTest && !($test instanceof Twig_SimpleTest || $test instanceof Twig_TestInterface)) { throw new LogicException('A test must be an instance of Twig_TestInterface or Twig_SimpleTest'); } if ($name instanceof Twig_SimpleTest) { $test = $name; $name = $test->getName(); } $this->staging->addTest($name, $test); } public function getTests() { if (!$this->extensionInitialized) { $this->initExtensions(); } return $this->tests; } public function getTest($name) { if (!$this->extensionInitialized) { $this->initExtensions(); } if (isset($this->tests[$name])) { return $this->tests[$name]; } return false; } public function addFunction($name, $function = null) { if ($this->extensionInitialized) { throw new LogicException(sprintf('Unable to add function "%s" as extensions have already been initialized.', $name)); } if (!$name instanceof Twig_SimpleFunction && !($function instanceof Twig_SimpleFunction || $function instanceof Twig_FunctionInterface)) { throw new LogicException('A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction'); } if ($name instanceof Twig_SimpleFunction) { $function = $name; $name = $function->getName(); } $this->staging->addFunction($name, $function); } public function getFunction($name) { if (!$this->extensionInitialized) { $this->initExtensions(); } if (isset($this->functions[$name])) { return $this->functions[$name]; } foreach ($this->functions as $pattern => $function) { $pattern = str_replace('\\*','(.*?)', preg_quote($pattern,'#'), $count); if ($count) { if (preg_match('#^'.$pattern.'$#', $name, $matches)) { array_shift($matches); $function->setArguments($matches); return $function; } } } foreach ($this->functionCallbacks as $callback) { if (false !== $function = call_user_func($callback, $name)) { return $function; } } return false; } public function registerUndefinedFunctionCallback($callable) { $this->functionCallbacks[] = $callable; } public function getFunctions() { if (!$this->extensionInitialized) { $this->initExtensions(); } return $this->functions; } public function addGlobal($name, $value) { if ($this->extensionInitialized || $this->runtimeInitialized) { if (null === $this->globals) { $this->globals = $this->initGlobals(); } } if ($this->extensionInitialized || $this->runtimeInitialized) { $this->globals[$name] = $value; } else { $this->staging->addGlobal($name, $value); } } public function getGlobals() { if (!$this->runtimeInitialized && !$this->extensionInitialized) { return $this->initGlobals(); } if (null === $this->globals) { $this->globals = $this->initGlobals(); } return $this->globals; } public function mergeGlobals(array $context) { foreach ($this->getGlobals() as $key => $value) { if (!array_key_exists($key, $context)) { $context[$key] = $value; } } return $context; } public function getUnaryOperators() { if (!$this->extensionInitialized) { $this->initExtensions(); } return $this->unaryOperators; } public function getBinaryOperators() { if (!$this->extensionInitialized) { $this->initExtensions(); } return $this->binaryOperators; } public function computeAlternatives($name, $items) { $alternatives = array(); foreach ($items as $item) { $lev = levenshtein($name, $item); if ($lev <= strlen($name) / 3 || false !== strpos($item, $name)) { $alternatives[$item] = $lev; } } asort($alternatives); return array_keys($alternatives); } protected function initGlobals() { $globals = array(); foreach ($this->extensions as $extension) { $globals = array_merge($globals, $extension->getGlobals()); } return array_merge($globals, $this->staging->getGlobals()); } protected function initExtensions() { if ($this->extensionInitialized) { return; } $this->extensionInitialized = true; $this->parsers = new Twig_TokenParserBroker(); $this->filters = array(); $this->functions = array(); $this->tests = array(); $this->visitors = array(); $this->unaryOperators = array(); $this->binaryOperators = array(); foreach ($this->extensions as $extension) { $this->initExtension($extension); } $this->initExtension($this->staging); } protected function initExtension(Twig_ExtensionInterface $extension) { foreach ($extension->getFilters() as $name => $filter) { if ($name instanceof Twig_SimpleFilter) { $filter = $name; $name = $filter->getName(); } elseif ($filter instanceof Twig_SimpleFilter) { $name = $filter->getName(); } $this->filters[$name] = $filter; } foreach ($extension->getFunctions() as $name => $function) { if ($name instanceof Twig_SimpleFunction) { $function = $name; $name = $function->getName(); } elseif ($function instanceof Twig_SimpleFunction) { $name = $function->getName(); } $this->functions[$name] = $function; } foreach ($extension->getTests() as $name => $test) { if ($name instanceof Twig_SimpleTest) { $test = $name; $name = $test->getName(); } elseif ($test instanceof Twig_SimpleTest) { $name = $test->getName(); } $this->tests[$name] = $test; } foreach ($extension->getTokenParsers() as $parser) { if ($parser instanceof Twig_TokenParserInterface) { $this->parsers->addTokenParser($parser); } elseif ($parser instanceof Twig_TokenParserBrokerInterface) { $this->parsers->addTokenParserBroker($parser); } else { throw new LogicException('getTokenParsers() must return an array of Twig_TokenParserInterface or Twig_TokenParserBrokerInterface instances'); } } foreach ($extension->getNodeVisitors() as $visitor) { $this->visitors[] = $visitor; } if ($operators = $extension->getOperators()) { if (2 !== count($operators)) { throw new InvalidArgumentException(sprintf('"%s::getOperators()" does not return a valid operators array.', get_class($extension))); } $this->unaryOperators = array_merge($this->unaryOperators, $operators[0]); $this->binaryOperators = array_merge($this->binaryOperators, $operators[1]); } } protected function writeCacheFile($file, $content) { $dir = dirname($file); if (!is_dir($dir)) { if (false === @mkdir($dir, 0777, true) && !is_dir($dir)) { throw new RuntimeException(sprintf("Unable to create the cache directory (%s).", $dir)); } } elseif (!is_writable($dir)) { throw new RuntimeException(sprintf("Unable to write in the cache directory (%s).", $dir)); } $tmpFile = tempnam(dirname($file), basename($file)); if (false !== @file_put_contents($tmpFile, $content)) { if (@rename($tmpFile, $file) || (@copy($tmpFile, $file) && unlink($tmpFile))) { @chmod($file, 0666 & ~umask()); return; } } throw new RuntimeException(sprintf('Failed to write cache file "%s".', $file)); } } } namespace { class Twig_Error extends Exception { protected $lineno; protected $filename; protected $rawMessage; protected $previous; public function __construct($message, $lineno = -1, $filename = null, Exception $previous = null) { if (version_compare(PHP_VERSION,'5.3.0','<')) { $this->previous = $previous; parent::__construct(''); } else { parent::__construct('', 0, $previous); } $this->lineno = $lineno; $this->filename = $filename; if (-1 === $this->lineno || null === $this->filename) { $this->guessTemplateInfo(); } $this->rawMessage = $message; $this->updateRepr(); } public function getRawMessage() { return $this->rawMessage; } public function getTemplateFile() { return $this->filename; } public function setTemplateFile($filename) { $this->filename = $filename; $this->updateRepr(); } public function getTemplateLine() { return $this->lineno; } public function setTemplateLine($lineno) { $this->lineno = $lineno; $this->updateRepr(); } public function guess() { $this->guessTemplateInfo(); $this->updateRepr(); } public function __call($method, $arguments) { if ('getprevious'== strtolower($method)) { return $this->previous; } throw new BadMethodCallException(sprintf('Method "Twig_Error::%s()" does not exist.', $method)); } protected function updateRepr() { $this->message = $this->rawMessage; $dot = false; if ('.'=== substr($this->message, -1)) { $this->message = substr($this->message, 0, -1); $dot = true; } if ($this->filename) { if (is_string($this->filename) || (is_object($this->filename) && method_exists($this->filename,'__toString'))) { $filename = sprintf('"%s"', $this->filename); } else { $filename = json_encode($this->filename); } $this->message .= sprintf(' in %s', $filename); } if ($this->lineno && $this->lineno >= 0) { $this->message .= sprintf(' at line %d', $this->lineno); } if ($dot) { $this->message .='.'; } } protected function guessTemplateInfo() { $template = null; foreach (debug_backtrace() as $trace) { if (isset($trace['object']) && $trace['object'] instanceof Twig_Template &&'Twig_Template'!== get_class($trace['object'])) { if (null === $this->filename || $this->filename == $trace['object']->getTemplateName()) { $template = $trace['object']; } } } if (null !== $template && null === $this->filename) { $this->filename = $template->getTemplateName(); } if (null === $template || $this->lineno > -1) { return; } $r = new ReflectionObject($template); $file = $r->getFileName(); $exceptions = array($e = $this); while (($e instanceof self || method_exists($e,'getPrevious')) && $e = $e->getPrevious()) { $exceptions[] = $e; } while ($e = array_pop($exceptions)) { $traces = $e->getTrace(); while ($trace = array_shift($traces)) { if (!isset($trace['file']) || !isset($trace['line']) || $file != $trace['file']) { continue; } foreach ($template->getDebugInfo() as $codeLine => $templateLine) { if ($codeLine <= $trace['line']) { $this->lineno = $templateLine; return; } } } } } } } namespace { class Twig_Error_Loader extends Twig_Error { public function __construct($message, $lineno = -1, $filename = null, Exception $previous = null) { parent::__construct($message, false, false, $previous); } } } namespace { class Twig_Error_Runtime extends Twig_Error { } } namespace { class Twig_Error_Syntax extends Twig_Error { } } namespace { interface Twig_ExtensionInterface { public function initRuntime(Twig_Environment $environment); public function getTokenParsers(); public function getNodeVisitors(); public function getFilters(); public function getTests(); public function getFunctions(); public function getOperators(); public function getGlobals(); public function getName(); } } namespace { abstract class Twig_Extension implements Twig_ExtensionInterface { public function initRuntime(Twig_Environment $environment) { } public function getTokenParsers() { return array(); } public function getNodeVisitors() { return array(); } public function getFilters() { return array(); } public function getTests() { return array(); } public function getFunctions() { return array(); } public function getOperators() { return array(); } public function getGlobals() { return array(); } } } namespace { if (!defined('ENT_SUBSTITUTE')) { define('ENT_SUBSTITUTE', 8); } class Twig_Extension_Core extends Twig_Extension { protected $dateFormats = array('F j, Y H:i','%d days'); protected $numberFormat = array(0,'.',','); protected $timezone = null; public function setDateFormat($format = null, $dateIntervalFormat = null) { if (null !== $format) { $this->dateFormats[0] = $format; } if (null !== $dateIntervalFormat) { $this->dateFormats[1] = $dateIntervalFormat; } } public function getDateFormat() { return $this->dateFormats; } public function setTimezone($timezone) { $this->timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone); } public function getTimezone() { if (null === $this->timezone) { $this->timezone = new DateTimeZone(date_default_timezone_get()); } return $this->timezone; } public function setNumberFormat($decimal, $decimalPoint, $thousandSep) { $this->numberFormat = array($decimal, $decimalPoint, $thousandSep); } public function getNumberFormat() { return $this->numberFormat; } public function getTokenParsers() { return array( new Twig_TokenParser_For(), new Twig_TokenParser_If(), new Twig_TokenParser_Extends(), new Twig_TokenParser_Include(), new Twig_TokenParser_Block(), new Twig_TokenParser_Use(), new Twig_TokenParser_Filter(), new Twig_TokenParser_Macro(), new Twig_TokenParser_Import(), new Twig_TokenParser_From(), new Twig_TokenParser_Set(), new Twig_TokenParser_Spaceless(), new Twig_TokenParser_Flush(), new Twig_TokenParser_Do(), new Twig_TokenParser_Embed(), ); } public function getFilters() { $filters = array( new Twig_SimpleFilter('date','twig_date_format_filter', array('needs_environment'=> true)), new Twig_SimpleFilter('date_modify','twig_date_modify_filter', array('needs_environment'=> true)), new Twig_SimpleFilter('format','sprintf'), new Twig_SimpleFilter('replace','strtr'), new Twig_SimpleFilter('number_format','twig_number_format_filter', array('needs_environment'=> true)), new Twig_SimpleFilter('abs','abs'), new Twig_SimpleFilter('url_encode','twig_urlencode_filter'), new Twig_SimpleFilter('json_encode','twig_jsonencode_filter'), new Twig_SimpleFilter('convert_encoding','twig_convert_encoding'), new Twig_SimpleFilter('title','twig_title_string_filter', array('needs_environment'=> true)), new Twig_SimpleFilter('capitalize','twig_capitalize_string_filter', array('needs_environment'=> true)), new Twig_SimpleFilter('upper','strtoupper'), new Twig_SimpleFilter('lower','strtolower'), new Twig_SimpleFilter('striptags','strip_tags'), new Twig_SimpleFilter('trim','trim'), new Twig_SimpleFilter('nl2br','nl2br', array('pre_escape'=>'html','is_safe'=> array('html'))), new Twig_SimpleFilter('join','twig_join_filter'), new Twig_SimpleFilter('split','twig_split_filter'), new Twig_SimpleFilter('sort','twig_sort_filter'), new Twig_SimpleFilter('merge','twig_array_merge'), new Twig_SimpleFilter('reverse','twig_reverse_filter', array('needs_environment'=> true)), new Twig_SimpleFilter('length','twig_length_filter', array('needs_environment'=> true)), new Twig_SimpleFilter('slice','twig_slice', array('needs_environment'=> true)), new Twig_SimpleFilter('first','twig_first', array('needs_environment'=> true)), new Twig_SimpleFilter('last','twig_last', array('needs_environment'=> true)), new Twig_SimpleFilter('default','_twig_default_filter', array('node_class'=>'Twig_Node_Expression_Filter_Default')), new Twig_SimpleFilter('keys','twig_get_array_keys_filter'), new Twig_SimpleFilter('escape','twig_escape_filter', array('needs_environment'=> true,'is_safe_callback'=>'twig_escape_filter_is_safe')), new Twig_SimpleFilter('e','twig_escape_filter', array('needs_environment'=> true,'is_safe_callback'=>'twig_escape_filter_is_safe')), ); if (function_exists('mb_get_info')) { $filters['upper'] = new Twig_Filter_Function('twig_upper_filter', array('needs_environment'=> true)); $filters['lower'] = new Twig_Filter_Function('twig_lower_filter', array('needs_environment'=> true)); } return $filters; } public function getFunctions() { return array( new Twig_SimpleFunction('range','range'), new Twig_SimpleFunction('constant','twig_constant'), new Twig_SimpleFunction('cycle','twig_cycle'), new Twig_SimpleFunction('random','twig_random', array('needs_environment'=> true)), new Twig_SimpleFunction('date','twig_date_converter', array('needs_environment'=> true)), new Twig_SimpleFunction('include','twig_include', array('needs_environment'=> true,'needs_context'=> true)), ); } public function getTests() { return array( new Twig_SimpleTest('even', null, array('node_class'=>'Twig_Node_Expression_Test_Even')), new Twig_SimpleTest('odd', null, array('node_class'=>'Twig_Node_Expression_Test_Odd')), new Twig_SimpleTest('defined', null, array('node_class'=>'Twig_Node_Expression_Test_Defined')), new Twig_SimpleTest('sameas', null, array('node_class'=>'Twig_Node_Expression_Test_Sameas')), new Twig_SimpleTest('none', null, array('node_class'=>'Twig_Node_Expression_Test_Null')), new Twig_SimpleTest('null', null, array('node_class'=>'Twig_Node_Expression_Test_Null')), new Twig_SimpleTest('divisibleby', null, array('node_class'=>'Twig_Node_Expression_Test_Divisibleby')), new Twig_SimpleTest('constant', null, array('node_class'=>'Twig_Node_Expression_Test_Constant')), new Twig_SimpleTest('empty','twig_test_empty'), new Twig_SimpleTest('iterable','twig_test_iterable'), ); } public function getOperators() { return array( array('not'=> array('precedence'=> 50,'class'=>'Twig_Node_Expression_Unary_Not'),'-'=> array('precedence'=> 500,'class'=>'Twig_Node_Expression_Unary_Neg'),'+'=> array('precedence'=> 500,'class'=>'Twig_Node_Expression_Unary_Pos'), ), array('or'=> array('precedence'=> 10,'class'=>'Twig_Node_Expression_Binary_Or','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'and'=> array('precedence'=> 15,'class'=>'Twig_Node_Expression_Binary_And','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'b-or'=> array('precedence'=> 16,'class'=>'Twig_Node_Expression_Binary_BitwiseOr','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'b-xor'=> array('precedence'=> 17,'class'=>'Twig_Node_Expression_Binary_BitwiseXor','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'b-and'=> array('precedence'=> 18,'class'=>'Twig_Node_Expression_Binary_BitwiseAnd','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'=='=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_Equal','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'!='=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_NotEqual','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'<'=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_Less','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'>'=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_Greater','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'>='=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_GreaterEqual','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'<='=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_LessEqual','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'not in'=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_NotIn','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'in'=> array('precedence'=> 20,'class'=>'Twig_Node_Expression_Binary_In','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'..'=> array('precedence'=> 25,'class'=>'Twig_Node_Expression_Binary_Range','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'+'=> array('precedence'=> 30,'class'=>'Twig_Node_Expression_Binary_Add','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'-'=> array('precedence'=> 30,'class'=>'Twig_Node_Expression_Binary_Sub','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'~'=> array('precedence'=> 40,'class'=>'Twig_Node_Expression_Binary_Concat','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'*'=> array('precedence'=> 60,'class'=>'Twig_Node_Expression_Binary_Mul','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'/'=> array('precedence'=> 60,'class'=>'Twig_Node_Expression_Binary_Div','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'//'=> array('precedence'=> 60,'class'=>'Twig_Node_Expression_Binary_FloorDiv','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'%'=> array('precedence'=> 60,'class'=>'Twig_Node_Expression_Binary_Mod','associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'is'=> array('precedence'=> 100,'callable'=> array($this,'parseTestExpression'),'associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'is not'=> array('precedence'=> 100,'callable'=> array($this,'parseNotTestExpression'),'associativity'=> Twig_ExpressionParser::OPERATOR_LEFT),'**'=> array('precedence'=> 200,'class'=>'Twig_Node_Expression_Binary_Power','associativity'=> Twig_ExpressionParser::OPERATOR_RIGHT), ), ); } public function parseNotTestExpression(Twig_Parser $parser, $node) { return new Twig_Node_Expression_Unary_Not($this->parseTestExpression($parser, $node), $parser->getCurrentToken()->getLine()); } public function parseTestExpression(Twig_Parser $parser, $node) { $stream = $parser->getStream(); $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue(); $arguments = null; if ($stream->test(Twig_Token::PUNCTUATION_TYPE,'(')) { $arguments = $parser->getExpressionParser()->parseArguments(true); } $class = $this->getTestNodeClass($parser, $name, $node->getLine()); return new $class($node, $name, $arguments, $parser->getCurrentToken()->getLine()); } protected function getTestNodeClass(Twig_Parser $parser, $name, $line) { $env = $parser->getEnvironment(); $testMap = $env->getTests(); if (!isset($testMap[$name])) { $message = sprintf('The test "%s" does not exist', $name); if ($alternatives = $env->computeAlternatives($name, array_keys($env->getTests()))) { $message = sprintf('%s. Did you mean "%s"', $message, implode('", "', $alternatives)); } throw new Twig_Error_Syntax($message, $line, $parser->getFilename()); } if ($testMap[$name] instanceof Twig_SimpleTest) { return $testMap[$name]->getNodeClass(); } return $testMap[$name] instanceof Twig_Test_Node ? $testMap[$name]->getClass() :'Twig_Node_Expression_Test'; } public function getName() { return'core'; } } function twig_cycle($values, $position) { if (!is_array($values) && !$values instanceof ArrayAccess) { return $values; } return $values[$position % count($values)]; } function twig_random(Twig_Environment $env, $values = null) { if (null === $values) { return mt_rand(); } if (is_int($values) || is_float($values)) { return $values < 0 ? mt_rand($values, 0) : mt_rand(0, $values); } if ($values instanceof Traversable) { $values = iterator_to_array($values); } elseif (is_string($values)) { if (''=== $values) { return''; } if (null !== $charset = $env->getCharset()) { if ('UTF-8'!= $charset) { $values = twig_convert_encoding($values,'UTF-8', $charset); } $values = preg_split('/(?<!^)(?!$)/u', $values); if ('UTF-8'!= $charset) { foreach ($values as $i => $value) { $values[$i] = twig_convert_encoding($value, $charset,'UTF-8'); } } } else { return $values[mt_rand(0, strlen($values) - 1)]; } } if (!is_array($values)) { return $values; } if (0 === count($values)) { throw new Twig_Error_Runtime('The random function cannot pick from an empty array.'); } return $values[array_rand($values, 1)]; } function twig_date_format_filter(Twig_Environment $env, $date, $format = null, $timezone = null) { if (null === $format) { $formats = $env->getExtension('core')->getDateFormat(); $format = $date instanceof DateInterval ? $formats[1] : $formats[0]; } if ($date instanceof DateInterval) { return $date->format($format); } return twig_date_converter($env, $date, $timezone)->format($format); } function twig_date_modify_filter(Twig_Environment $env, $date, $modifier) { $date = twig_date_converter($env, $date, false); $date->modify($modifier); return $date; } function twig_date_converter(Twig_Environment $env, $date = null, $timezone = null) { if (!$timezone) { $defaultTimezone = $env->getExtension('core')->getTimezone(); } elseif (!$timezone instanceof DateTimeZone) { $defaultTimezone = new DateTimeZone($timezone); } else { $defaultTimezone = $timezone; } if ($date instanceof DateTime) { $date = clone $date; if (false !== $timezone) { $date->setTimezone($defaultTimezone); } return $date; } $asString = (string) $date; if (ctype_digit($asString) || (!empty($asString) &&'-'=== $asString[0] && ctype_digit(substr($asString, 1)))) { $date ='@'.$date; } $date = new DateTime($date, $defaultTimezone); if (false !== $timezone) { $date->setTimezone($defaultTimezone); } return $date; } function twig_number_format_filter(Twig_Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null) { $defaults = $env->getExtension('core')->getNumberFormat(); if (null === $decimal) { $decimal = $defaults[0]; } if (null === $decimalPoint) { $decimalPoint = $defaults[1]; } if (null === $thousandSep) { $thousandSep = $defaults[2]; } return number_format((float) $number, $decimal, $decimalPoint, $thousandSep); } function twig_urlencode_filter($url, $raw = false) { if ($raw) { return rawurlencode($url); } return urlencode($url); } if (version_compare(PHP_VERSION,'5.3.0','<')) { function twig_jsonencode_filter($value, $options = 0) { if ($value instanceof Twig_Markup) { $value = (string) $value; } elseif (is_array($value)) { array_walk_recursive($value,'_twig_markup2string'); } return json_encode($value); } } else { function twig_jsonencode_filter($value, $options = 0) { if ($value instanceof Twig_Markup) { $value = (string) $value; } elseif (is_array($value)) { array_walk_recursive($value,'_twig_markup2string'); } return json_encode($value, $options); } } function _twig_markup2string(&$value) { if ($value instanceof Twig_Markup) { $value = (string) $value; } } function twig_array_merge($arr1, $arr2) { if (!is_array($arr1) || !is_array($arr2)) { throw new Twig_Error_Runtime('The merge filter only works with arrays or hashes.'); } return array_merge($arr1, $arr2); } function twig_slice(Twig_Environment $env, $item, $start, $length = null, $preserveKeys = false) { if ($item instanceof Traversable) { $item = iterator_to_array($item, false); } if (is_array($item)) { return array_slice($item, $start, $length, $preserveKeys); } $item = (string) $item; if (function_exists('mb_get_info') && null !== $charset = $env->getCharset()) { return mb_substr($item, $start, null === $length ? mb_strlen($item, $charset) - $start : $length, $charset); } return null === $length ? substr($item, $start) : substr($item, $start, $length); } function twig_first(Twig_Environment $env, $item) { $elements = twig_slice($env, $item, 0, 1, false); return is_string($elements) ? $elements[0] : current($elements); } function twig_last(Twig_Environment $env, $item) { $elements = twig_slice($env, $item, -1, 1, false); return is_string($elements) ? $elements[0] : current($elements); } function twig_join_filter($value, $glue ='') { if ($value instanceof Traversable) { $value = iterator_to_array($value, false); } return implode($glue, (array) $value); } function twig_split_filter($value, $delimiter, $limit = null) { if (empty($delimiter)) { return str_split($value, null === $limit ? 1 : $limit); } return null === $limit ? explode($delimiter, $value) : explode($delimiter, $value, $limit); } function _twig_default_filter($value, $default ='') { if (twig_test_empty($value)) { return $default; } return $value; } function twig_get_array_keys_filter($array) { if (is_object($array) && $array instanceof Traversable) { return array_keys(iterator_to_array($array)); } if (!is_array($array)) { return array(); } return array_keys($array); } function twig_reverse_filter(Twig_Environment $env, $item, $preserveKeys = false) { if (is_object($item) && $item instanceof Traversable) { return array_reverse(iterator_to_array($item), $preserveKeys); } if (is_array($item)) { return array_reverse($item, $preserveKeys); } if (null !== $charset = $env->getCharset()) { $string = (string) $item; if ('UTF-8'!= $charset) { $item = twig_convert_encoding($string,'UTF-8', $charset); } preg_match_all('/./us', $item, $matches); $string = implode('', array_reverse($matches[0])); if ('UTF-8'!= $charset) { $string = twig_convert_encoding($string, $charset,'UTF-8'); } return $string; } return strrev((string) $item); } function twig_sort_filter($array) { asort($array); return $array; } function twig_in_filter($value, $compare) { if (is_array($compare)) { return in_array($value, $compare, is_object($value)); } elseif (is_string($compare)) { if (!strlen($value)) { return empty($compare); } return false !== strpos($compare, (string) $value); } elseif ($compare instanceof Traversable) { return in_array($value, iterator_to_array($compare, false), is_object($value)); } return false; } function twig_escape_filter(Twig_Environment $env, $string, $strategy ='html', $charset = null, $autoescape = false) { if ($autoescape && is_object($string) && $string instanceof Twig_Markup) { return $string; } if (!is_string($string) && !(is_object($string) && method_exists($string,'__toString'))) { return $string; } if (null === $charset) { $charset = $env->getCharset(); } $string = (string) $string; switch ($strategy) { case'js': if ('UTF-8'!= $charset) { $string = twig_convert_encoding($string,'UTF-8', $charset); } if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) { throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.'); } $string = preg_replace_callback('#[^a-zA-Z0-9,\._]#Su','_twig_escape_js_callback', $string); if ('UTF-8'!= $charset) { $string = twig_convert_encoding($string, $charset,'UTF-8'); } return $string; case'css': if ('UTF-8'!= $charset) { $string = twig_convert_encoding($string,'UTF-8', $charset); } if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) { throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.'); } $string = preg_replace_callback('#[^a-zA-Z0-9]#Su','_twig_escape_css_callback', $string); if ('UTF-8'!= $charset) { $string = twig_convert_encoding($string, $charset,'UTF-8'); } return $string; case'html_attr': if ('UTF-8'!= $charset) { $string = twig_convert_encoding($string,'UTF-8', $charset); } if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) { throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.'); } $string = preg_replace_callback('#[^a-zA-Z0-9,\.\-_]#Su','_twig_escape_html_attr_callback', $string); if ('UTF-8'!= $charset) { $string = twig_convert_encoding($string, $charset,'UTF-8'); } return $string; case'html': static $htmlspecialcharsCharsets = array('iso-8859-1'=> true,'iso8859-1'=> true,'iso-8859-15'=> true,'iso8859-15'=> true,'utf-8'=> true,'cp866'=> true,'ibm866'=> true,'866'=> true,'cp1251'=> true,'windows-1251'=> true,'win-1251'=> true,'1251'=> true,'cp1252'=> true,'windows-1252'=> true,'1252'=> true,'koi8-r'=> true,'koi8-ru'=> true,'koi8r'=> true,'big5'=> true,'950'=> true,'gb2312'=> true,'936'=> true,'big5-hkscs'=> true,'shift_jis'=> true,'sjis'=> true,'932'=> true,'euc-jp'=> true,'eucjp'=> true,'iso8859-5'=> true,'iso-8859-5'=> true,'macroman'=> true, ); if (isset($htmlspecialcharsCharsets[strtolower($charset)])) { return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset); } $string = twig_convert_encoding($string,'UTF-8', $charset); $string = htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE,'UTF-8'); return twig_convert_encoding($string, $charset,'UTF-8'); case'url': if (version_compare(PHP_VERSION,'5.3.0','<')) { return str_replace('%7E','~', rawurlencode($string)); } return rawurlencode($string); default: throw new Twig_Error_Runtime(sprintf('Invalid escaping strategy "%s" (valid ones: html, js, url, css, and html_attr).', $strategy)); } } function twig_escape_filter_is_safe(Twig_Node $filterArgs) { foreach ($filterArgs as $arg) { if ($arg instanceof Twig_Node_Expression_Constant) { return array($arg->getAttribute('value')); } return array(); } return array('html'); } if (function_exists('mb_convert_encoding')) { function twig_convert_encoding($string, $to, $from) { return mb_convert_encoding($string, $to, $from); } } elseif (function_exists('iconv')) { function twig_convert_encoding($string, $to, $from) { return iconv($from, $to, $string); } } else { function twig_convert_encoding($string, $to, $from) { throw new Twig_Error_Runtime('No suitable convert encoding function (use UTF-8 as your encoding or install the iconv or mbstring extension).'); } } function _twig_escape_js_callback($matches) { $char = $matches[0]; if (!isset($char[1])) { return'\\x'.strtoupper(substr('00'.bin2hex($char), -2)); } $char = twig_convert_encoding($char,'UTF-16BE','UTF-8'); return'\\u'.strtoupper(substr('0000'.bin2hex($char), -4)); } function _twig_escape_css_callback($matches) { $char = $matches[0]; if (!isset($char[1])) { $hex = ltrim(strtoupper(bin2hex($char)),'0'); if (0 === strlen($hex)) { $hex ='0'; } return'\\'.$hex.' '; } $char = twig_convert_encoding($char,'UTF-16BE','UTF-8'); return'\\'.ltrim(strtoupper(bin2hex($char)),'0').' '; } function _twig_escape_html_attr_callback($matches) { static $entityMap = array( 34 =>'quot', 38 =>'amp', 60 =>'lt', 62 =>'gt', ); $chr = $matches[0]; $ord = ord($chr); if (($ord <= 0x1f && $chr !="\t"&& $chr !="\n"&& $chr !="\r") || ($ord >= 0x7f && $ord <= 0x9f)) { return'&#xFFFD;'; } if (strlen($chr) == 1) { $hex = strtoupper(substr('00'.bin2hex($chr), -2)); } else { $chr = twig_convert_encoding($chr,'UTF-16BE','UTF-8'); $hex = strtoupper(substr('0000'.bin2hex($chr), -4)); } $int = hexdec($hex); if (array_key_exists($int, $entityMap)) { return sprintf('&%s;', $entityMap[$int]); } return sprintf('&#x%s;', $hex); } if (function_exists('mb_get_info')) { function twig_length_filter(Twig_Environment $env, $thing) { return is_scalar($thing) ? mb_strlen($thing, $env->getCharset()) : count($thing); } function twig_upper_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_strtoupper($string, $charset); } return strtoupper($string); } function twig_lower_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_strtolower($string, $charset); } return strtolower($string); } function twig_title_string_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_convert_case($string, MB_CASE_TITLE, $charset); } return ucwords(strtolower($string)); } function twig_capitalize_string_filter(Twig_Environment $env, $string) { if (null !== ($charset = $env->getCharset())) { return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset). mb_strtolower(mb_substr($string, 1, mb_strlen($string, $charset), $charset), $charset); } return ucfirst(strtolower($string)); } } else { function twig_length_filter(Twig_Environment $env, $thing) { return is_scalar($thing) ? strlen($thing) : count($thing); } function twig_title_string_filter(Twig_Environment $env, $string) { return ucwords(strtolower($string)); } function twig_capitalize_string_filter(Twig_Environment $env, $string) { return ucfirst(strtolower($string)); } } function twig_ensure_traversable($seq) { if ($seq instanceof Traversable || is_array($seq)) { return $seq; } return array(); } function twig_test_empty($value) { if ($value instanceof Countable) { return 0 == count($value); } return''=== $value || false === $value || null === $value || array() === $value; } function twig_test_iterable($value) { return $value instanceof Traversable || is_array($value); } function twig_include(Twig_Environment $env, $context, $template, $variables = array(), $withContext = true, $ignoreMissing = false, $sandboxed = false) { if ($withContext) { $variables = array_merge($context, $variables); } if ($isSandboxed = $sandboxed && $env->hasExtension('sandbox')) { $sandbox = $env->getExtension('sandbox'); if (!$alreadySandboxed = $sandbox->isSandboxed()) { $sandbox->enableSandbox(); } } try { return $env->resolveTemplate($template)->display($variables); } catch (Twig_Error_Loader $e) { if (!$ignoreMissing) { throw $e; } } if ($isSandboxed && !$alreadySandboxed) { $sandbox->disableSandbox(); } } function twig_constant($constant, $object = null) { if (null !== $object) { $constant = get_class($object).'::'.$constant; } return constant($constant); } } namespace { class Twig_Extension_Debug extends Twig_Extension { public function getFunctions() { $isDumpOutputHtmlSafe = extension_loaded('xdebug') && (false === ini_get('xdebug.overload_var_dump') || ini_get('xdebug.overload_var_dump')) && (false === ini_get('html_errors') || ini_get('html_errors')) ; return array( new Twig_SimpleFunction('dump','twig_var_dump', array('is_safe'=> $isDumpOutputHtmlSafe ? array('html') : array(),'needs_context'=> true,'needs_environment'=> true)), ); } public function getName() { return'debug'; } } function twig_var_dump(Twig_Environment $env, $context) { if (!$env->isDebug()) { return; } ob_start(); $count = func_num_args(); if (2 === $count) { $vars = array(); foreach ($context as $key => $value) { if (!$value instanceof Twig_Template) { $vars[$key] = $value; } } var_dump($vars); } else { for ($i = 2; $i < $count; $i++) { var_dump(func_get_arg($i)); } } return ob_get_clean(); } } namespace { class Twig_Extension_Escaper extends Twig_Extension { protected $defaultStrategy; public function __construct($defaultStrategy ='html') { $this->setDefaultStrategy($defaultStrategy); } public function getTokenParsers() { return array(new Twig_TokenParser_AutoEscape()); } public function getNodeVisitors() { return array(new Twig_NodeVisitor_Escaper()); } public function getFilters() { return array( new Twig_SimpleFilter('raw','twig_raw_filter', array('is_safe'=> array('all'))), ); } public function setDefaultStrategy($defaultStrategy) { if (true === $defaultStrategy) { $defaultStrategy ='html'; } $this->defaultStrategy = $defaultStrategy; } public function getDefaultStrategy($filename) { if (!is_string($this->defaultStrategy) && is_callable($this->defaultStrategy)) { return call_user_func($this->defaultStrategy, $filename); } return $this->defaultStrategy; } public function getName() { return'escaper'; } } function twig_raw_filter($string) { return $string; } } namespace { class Twig_Extension_Optimizer extends Twig_Extension { protected $optimizers; public function __construct($optimizers = -1) { $this->optimizers = $optimizers; } public function getNodeVisitors() { return array(new Twig_NodeVisitor_Optimizer($this->optimizers)); } public function getName() { return'optimizer'; } } } namespace { class Twig_Extension_Staging extends Twig_Extension { protected $functions = array(); protected $filters = array(); protected $visitors = array(); protected $tokenParsers = array(); protected $globals = array(); protected $tests = array(); public function addFunction($name, $function) { $this->functions[$name] = $function; } public function getFunctions() { return $this->functions; } public function addFilter($name, $filter) { $this->filters[$name] = $filter; } public function getFilters() { return $this->filters; } public function addNodeVisitor(Twig_NodeVisitorInterface $visitor) { $this->visitors[] = $visitor; } public function getNodeVisitors() { return $this->visitors; } public function addTokenParser(Twig_TokenParserInterface $parser) { $this->tokenParsers[] = $parser; } public function getTokenParsers() { return $this->tokenParsers; } public function addGlobal($name, $value) { $this->globals[$name] = $value; } public function getGlobals() { return $this->globals; } public function addTest($name, $test) { $this->tests[$name] = $test; } public function getTests() { return $this->tests; } public function getName() { return'staging'; } } } namespace { interface Twig_LoaderInterface { public function getSource($name); public function getCacheKey($name); public function isFresh($name, $time); } } namespace { class Twig_Markup implements Countable { protected $content; protected $charset; public function __construct($content, $charset) { $this->content = (string) $content; $this->charset = $charset; } public function __toString() { return $this->content; } public function count() { return function_exists('mb_get_info') ? mb_strlen($this->content, $this->charset) : strlen($this->content); } } } namespace { interface Twig_TemplateInterface { const ANY_CALL ='any'; const ARRAY_CALL ='array'; const METHOD_CALL ='method'; public function render(array $context); public function display(array $context, array $blocks = array()); public function getEnvironment(); } } namespace { abstract class Twig_Template implements Twig_TemplateInterface { protected static $cache = array(); protected $parent; protected $parents; protected $env; protected $blocks; protected $traits; public function __construct(Twig_Environment $env) { $this->env = $env; $this->blocks = array(); $this->traits = array(); } abstract public function getTemplateName(); public function getEnvironment() { return $this->env; } public function getParent(array $context) { if (null !== $this->parent) { return $this->parent; } $parent = $this->doGetParent($context); if (false === $parent) { return false; } elseif ($parent instanceof Twig_Template) { $name = $parent->getTemplateName(); $this->parents[$name] = $parent; $parent = $name; } elseif (!isset($this->parents[$parent])) { $this->parents[$parent] = $this->env->loadTemplate($parent); } return $this->parents[$parent]; } protected function doGetParent(array $context) { return false; } public function isTraitable() { return true; } public function displayParentBlock($name, array $context, array $blocks = array()) { $name = (string) $name; if (isset($this->traits[$name])) { $this->traits[$name][0]->displayBlock($name, $context, $blocks); } elseif (false !== $parent = $this->getParent($context)) { $parent->displayBlock($name, $context, $blocks); } else { throw new Twig_Error_Runtime(sprintf('The template has no parent and no traits defining the "%s" block', $name), -1, $this->getTemplateName()); } } public function displayBlock($name, array $context, array $blocks = array()) { $name = (string) $name; if (isset($blocks[$name])) { $b = $blocks; unset($b[$name]); call_user_func($blocks[$name], $context, $b); } elseif (isset($this->blocks[$name])) { call_user_func($this->blocks[$name], $context, $blocks); } elseif (false !== $parent = $this->getParent($context)) { $parent->displayBlock($name, $context, array_merge($this->blocks, $blocks)); } } public function renderParentBlock($name, array $context, array $blocks = array()) { ob_start(); $this->displayParentBlock($name, $context, $blocks); return ob_get_clean(); } public function renderBlock($name, array $context, array $blocks = array()) { ob_start(); $this->displayBlock($name, $context, $blocks); return ob_get_clean(); } public function hasBlock($name) { return isset($this->blocks[(string) $name]); } public function getBlockNames() { return array_keys($this->blocks); } public function getBlocks() { return $this->blocks; } public function display(array $context, array $blocks = array()) { $this->displayWithErrorHandling($this->env->mergeGlobals($context), $blocks); } public function render(array $context) { $level = ob_get_level(); ob_start(); try { $this->display($context); } catch (Exception $e) { while (ob_get_level() > $level) { ob_end_clean(); } throw $e; } return ob_get_clean(); } protected function displayWithErrorHandling(array $context, array $blocks = array()) { try { $this->doDisplay($context, $blocks); } catch (Twig_Error $e) { if (!$e->getTemplateFile()) { $e->setTemplateFile($this->getTemplateName()); } if (false === $e->getTemplateLine()) { $e->setTemplateLine(-1); $e->guess(); } throw $e; } catch (Exception $e) { throw new Twig_Error_Runtime(sprintf('An exception has been thrown during the rendering of a template ("%s").', $e->getMessage()), -1, null, $e); } } abstract protected function doDisplay(array $context, array $blocks = array()); final protected function getContext($context, $item, $ignoreStrictCheck = false) { if (!array_key_exists($item, $context)) { if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } throw new Twig_Error_Runtime(sprintf('Variable "%s" does not exist', $item), -1, $this->getTemplateName()); } return $context[$item]; } protected function getAttribute($object, $item, array $arguments = array(), $type = Twig_TemplateInterface::ANY_CALL, $isDefinedTest = false, $ignoreStrictCheck = false) { $item = ctype_digit((string) $item) ? (int) $item : (string) $item; if (Twig_TemplateInterface::METHOD_CALL !== $type) { if ((is_array($object) && array_key_exists($item, $object)) || ($object instanceof ArrayAccess && isset($object[$item])) ) { if ($isDefinedTest) { return true; } return $object[$item]; } if (Twig_TemplateInterface::ARRAY_CALL === $type) { if ($isDefinedTest) { return false; } if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } if (is_object($object)) { throw new Twig_Error_Runtime(sprintf('Key "%s" in object (with ArrayAccess) of type "%s" does not exist', $item, get_class($object)), -1, $this->getTemplateName()); } elseif (is_array($object)) { throw new Twig_Error_Runtime(sprintf('Key "%s" for array with keys "%s" does not exist', $item, implode(', ', array_keys($object))), -1, $this->getTemplateName()); } else { throw new Twig_Error_Runtime(sprintf('Impossible to access a key ("%s") on a "%s" variable', $item, gettype($object)), -1, $this->getTemplateName()); } } } if (!is_object($object)) { if ($isDefinedTest) { return false; } if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } throw new Twig_Error_Runtime(sprintf('Item "%s" for "%s" does not exist', $item, is_array($object) ?'Array': $object), -1, $this->getTemplateName()); } $class = get_class($object); if (Twig_TemplateInterface::METHOD_CALL !== $type) { if (isset($object->$item) || array_key_exists($item, $object)) { if ($isDefinedTest) { return true; } if ($this->env->hasExtension('sandbox')) { $this->env->getExtension('sandbox')->checkPropertyAllowed($object, $item); } return $object->$item; } } if (!isset(self::$cache[$class]['methods'])) { self::$cache[$class]['methods'] = array_change_key_case(array_flip(get_class_methods($object))); } $lcItem = strtolower($item); if (isset(self::$cache[$class]['methods'][$lcItem])) { $method = $item; } elseif (isset(self::$cache[$class]['methods']['get'.$lcItem])) { $method ='get'.$item; } elseif (isset(self::$cache[$class]['methods']['is'.$lcItem])) { $method ='is'.$item; } elseif (isset(self::$cache[$class]['methods']['__call'])) { $method = $item; } else { if ($isDefinedTest) { return false; } if ($ignoreStrictCheck || !$this->env->isStrictVariables()) { return null; } throw new Twig_Error_Runtime(sprintf('Method "%s" for object "%s" does not exist', $item, get_class($object)), -1, $this->getTemplateName()); } if ($isDefinedTest) { return true; } if ($this->env->hasExtension('sandbox')) { $this->env->getExtension('sandbox')->checkMethodAllowed($object, $method); } $ret = call_user_func_array(array($object, $method), $arguments); if ($object instanceof Twig_TemplateInterface) { return $ret ===''?'': new Twig_Markup($ret, $this->env->getCharset()); } return $ret; } public static function clearCache() { self::$cache = array(); } } } namespace Symfony\Component\Console\Helper { interface HelperInterface { public function setHelperSet(HelperSet $helperSet = null); public function getHelperSet(); public function getName(); } } namespace Symfony\Component\Console\Helper { abstract class Helper implements HelperInterface { protected $helperSet = null; public function setHelperSet(HelperSet $helperSet = null) { $this->helperSet = $helperSet; } public function getHelperSet() { return $this->helperSet; } } } namespace Symfony\Component\Console\Helper { use Symfony\Component\Console\Command\Command; class HelperSet { private $helpers; private $command; public function __construct(array $helpers = array()) { $this->helpers = array(); foreach ($helpers as $alias => $helper) { $this->set($helper, is_int($alias) ? null : $alias); } } public function set(HelperInterface $helper, $alias = null) { $this->helpers[$helper->getName()] = $helper; if (null !== $alias) { $this->helpers[$alias] = $helper; } $helper->setHelperSet($this); } public function has($name) { return isset($this->helpers[$name]); } public function get($name) { if (!$this->has($name)) { throw new \InvalidArgumentException(sprintf('The helper "%s" is not defined.', $name)); } return $this->helpers[$name]; } public function setCommand(Command $command = null) { $this->command = $command; } public function getCommand() { return $this->command; } } } namespace Symfony\Component\Console\Helper { use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Formatter\OutputFormatterStyle; class DialogHelper extends Helper { private $inputStream; private static $shell; private static $stty; public function select(OutputInterface $output, $question, $choices, $default = null, $attempts = false, $errorMessage ='Value "%s" is invalid') { $width = max(array_map('strlen', array_keys($choices))); $messages = (array) $question; foreach ($choices as $key => $value) { $messages[] = sprintf(" [<info>%-${width}s</info>] %s", $key, $value); } $output->writeln($messages); $result = $this->askAndValidate($output,'> ', function ($picked) use ($choices, $errorMessage) { if (empty($choices[$picked])) { throw new \InvalidArgumentException(sprintf($errorMessage, $picked)); } return $picked; }, $attempts, $default); return $result; } public function ask(OutputInterface $output, $question, $default = null, array $autocomplete = null) { $output->write($question); $inputStream = $this->inputStream ?: STDIN; if (null === $autocomplete || !$this->hasSttyAvailable()) { $ret = fgets($inputStream, 4096); if (false === $ret) { throw new \RuntimeException('Aborted'); } $ret = trim($ret); } else { $ret =''; $i = 0; $ofs = -1; $matches = $autocomplete; $numMatches = count($matches); $sttyMode = shell_exec('stty -g'); shell_exec('stty -icanon -echo'); $output->getFormatter()->setStyle('hl', new OutputFormatterStyle('black','white')); while ($c = fread($inputStream, 1)) { if ("\177"=== $c) { if (0 === $numMatches && 0 !== $i) { $i--; $output->write("\033[1D"); } if ($i === 0) { $ofs = -1; $matches = $autocomplete; $numMatches = count($matches); } else { $numMatches = 0; } $ret = substr($ret, 0, $i); } elseif ("\033"=== $c) { $c .= fread($inputStream, 2); if ('A'=== $c[2] ||'B'=== $c[2]) { if ('A'=== $c[2] && -1 === $ofs) { $ofs = 0; } if (0 === $numMatches) { continue; } $ofs += ('A'=== $c[2]) ? -1 : 1; $ofs = ($numMatches + $ofs) % $numMatches; } } elseif (ord($c) < 32) { if ("\t"=== $c ||"\n"=== $c) { if ($numMatches > 0 && -1 !== $ofs) { $ret = $matches[$ofs]; $output->write(substr($ret, $i)); $i = strlen($ret); } if ("\n"=== $c) { $output->write($c); break; } $numMatches = 0; } continue; } else { $output->write($c); $ret .= $c; $i++; $numMatches = 0; $ofs = 0; foreach ($autocomplete as $value) { if (0 === strpos($value, $ret) && $i !== strlen($value)) { $matches[$numMatches++] = $value; } } } $output->write("\033[K"); if ($numMatches > 0 && -1 !== $ofs) { $output->write("\0337"); $output->write('<hl>'. substr($matches[$ofs], $i) .'</hl>'); $output->write("\0338"); } } shell_exec(sprintf('stty %s', $sttyMode)); } return strlen($ret) > 0 ? $ret : $default; } public function askConfirmation(OutputInterface $output, $question, $default = true) { $answer ='z'; while ($answer && !in_array(strtolower($answer[0]), array('y','n'))) { $answer = $this->ask($output, $question); } if (false === $default) { return $answer &&'y'== strtolower($answer[0]); } return !$answer ||'y'== strtolower($answer[0]); } public function askHiddenResponse(OutputInterface $output, $question, $fallback = true) { if (defined('PHP_WINDOWS_VERSION_BUILD')) { $exe = __DIR__ .'/../../Resources/bin/hiddeninput.exe'; if ('phar:'=== substr(__FILE__, 0, 5)) { $tmpExe = sys_get_temp_dir() .'/../../Resources/bin/hiddeninput.exe'; copy($exe, $tmpExe); $exe = $tmpExe; } $output->write($question); $value = rtrim(shell_exec($exe)); $output->writeln(''); if (isset($tmpExe)) { unlink($tmpExe); } return $value; } if ($this->hasSttyAvailable()) { $output->write($question); $sttyMode = shell_exec('stty -g'); shell_exec('stty -echo'); $value = fgets($this->inputStream ?: STDIN, 4096); shell_exec(sprintf('stty %s', $sttyMode)); if (false === $value) { throw new \RuntimeException('Aborted'); } $value = trim($value); $output->writeln(''); return $value; } if (false !== $shell = $this->getShell()) { $output->write($question); $readCmd = $shell ==='csh'?'set mypassword = $<':'read -r mypassword'; $command = sprintf("/usr/bin/env %s -c 'stty -echo; %s; stty echo; echo \$mypassword'", $shell, $readCmd); $value = rtrim(shell_exec($command)); $output->writeln(''); return $value; } if ($fallback) { return $this->ask($output, $question); } throw new \RuntimeException('Unable to hide the response'); } public function askAndValidate(OutputInterface $output, $question, $validator, $attempts = false, $default = null, array $autocomplete = null) { $that = $this; $interviewer = function() use ($output, $question, $default, $autocomplete, $that) { return $that->ask($output, $question, $default, $autocomplete); }; return $this->validateAttempts($interviewer, $output, $validator, $attempts); } public function askHiddenResponseAndValidate(OutputInterface $output, $question, $validator, $attempts = false, $fallback = true) { $that = $this; $interviewer = function() use ($output, $question, $fallback, $that) { return $that->askHiddenResponse($output, $question, $fallback); }; return $this->validateAttempts($interviewer, $output, $validator, $attempts); } public function setInputStream($stream) { $this->inputStream = $stream; } public function getInputStream() { return $this->inputStream; } public function getName() { return'dialog'; } private function getShell() { if (null !== self::$shell) { return self::$shell; } self::$shell = false; if (file_exists('/usr/bin/env')) { $test ="/usr/bin/env %s -c 'echo OK' 2> /dev/null"; foreach (array('bash','zsh','ksh','csh') as $sh) { if ('OK'=== rtrim(shell_exec(sprintf($test, $sh)))) { self::$shell = $sh; break; } } } return self::$shell; } private function hasSttyAvailable() { if (null !== self::$stty) { return self::$stty; } exec('stty 2>&1', $output, $exitcode); return self::$stty = $exitcode === 0; } private function validateAttempts($interviewer, OutputInterface $output, $validator, $attempts) { $error = null; while (false === $attempts || $attempts--) { if (null !== $error) { $output->writeln($this->getHelperSet()->get('formatter')->formatBlock($error->getMessage(),'error')); } try { return call_user_func($validator, $interviewer()); } catch (\Exception $error) { } } throw $error; } } } namespace Symfony\Component\Console\Helper { use Symfony\Component\Console\Formatter\OutputFormatter; class FormatterHelper extends Helper { public function formatSection($section, $message, $style ='info') { return sprintf('<%s>[%s]</%s> %s', $style, $section, $style, $message); } public function formatBlock($messages, $style, $large = false) { $messages = (array) $messages; $len = 0; $lines = array(); foreach ($messages as $message) { $message = OutputFormatter::escape($message); $lines[] = sprintf($large ?'  %s  ':' %s ', $message); $len = max($this->strlen($message) + ($large ? 4 : 2), $len); } $messages = $large ? array(str_repeat(' ', $len)) : array(); foreach ($lines as $line) { $messages[] = $line.str_repeat(' ', $len - $this->strlen($line)); } if ($large) { $messages[] = str_repeat(' ', $len); } foreach ($messages as &$message) { $message = sprintf('<%s>%s</%s>', $style, $message, $style); } return implode("\n", $messages); } private function strlen($string) { if (!function_exists('mb_strlen')) { return strlen($string); } if (false === $encoding = mb_detect_encoding($string)) { return strlen($string); } return mb_strlen($string, $encoding); } public function getName() { return'formatter'; } } } namespace Symfony\Component\Console\Helper { use Symfony\Component\Console\Output\OutputInterface; class ProgressHelper extends Helper { const FORMAT_QUIET =' %percent%%'; const FORMAT_NORMAL =' %current%/%max% [%bar%] %percent%%'; const FORMAT_VERBOSE =' %current%/%max% [%bar%] %percent%% Elapsed: %elapsed%'; const FORMAT_QUIET_NOMAX =' %current%'; const FORMAT_NORMAL_NOMAX =' %current% [%bar%]'; const FORMAT_VERBOSE_NOMAX =' %current% [%bar%] Elapsed: %elapsed%'; private $barWidth = 28; private $barChar ='='; private $emptyBarChar ='-'; private $progressChar ='>'; private $format = null; private $redrawFreq = 1; private $lastMessagesLength; private $barCharOriginal; private $output; private $current; private $max; private $startTime; private $defaultFormatVars = array('current','max','bar','percent','elapsed', ); private $formatVars; private $widths = array('current'=> 4,'max'=> 4,'percent'=> 3,'elapsed'=> 6, ); private $timeFormats = array( array(0,'???'), array(2,'1 sec'), array(59,'secs', 1), array(60,'1 min'), array(3600,'mins', 60), array(5400,'1 hr'), array(86400,'hrs', 3600), array(129600,'1 day'), array(604800,'days', 86400), ); public function setBarWidth($size) { $this->barWidth = (int) $size; } public function setBarCharacter($char) { $this->barChar = $char; } public function setEmptyBarCharacter($char) { $this->emptyBarChar = $char; } public function setProgressCharacter($char) { $this->progressChar = $char; } public function setFormat($format) { $this->format = $format; } public function setRedrawFrequency($freq) { $this->redrawFreq = (int) $freq; } public function start(OutputInterface $output, $max = null) { $this->startTime = time(); $this->current = 0; $this->max = (int) $max; $this->output = $output; if (null === $this->format) { switch ($output->getVerbosity()) { case OutputInterface::VERBOSITY_QUIET: $this->format = self::FORMAT_QUIET_NOMAX; if ($this->max > 0) { $this->format = self::FORMAT_QUIET; } break; case OutputInterface::VERBOSITY_VERBOSE: $this->format = self::FORMAT_VERBOSE_NOMAX; if ($this->max > 0) { $this->format = self::FORMAT_VERBOSE; } break; default: $this->format = self::FORMAT_NORMAL_NOMAX; if ($this->max > 0) { $this->format = self::FORMAT_NORMAL; } break; } } $this->initialize(); } public function advance($step = 1, $redraw = false) { if (null === $this->startTime) { throw new \LogicException('You must start the progress bar before calling advance().'); } if ($this->current === 0) { $redraw = true; } $this->current += $step; if ($redraw || $this->current % $this->redrawFreq === 0) { $this->display(); } } public function display($finish = false) { if (null === $this->startTime) { throw new \LogicException('You must start the progress bar before calling display().'); } $message = $this->format; foreach ($this->generate($finish) as $name => $value) { $message = str_replace("%{$name}%", $value, $message); } $this->overwrite($this->output, $message); } public function finish() { if (null === $this->startTime) { throw new \LogicException('You must start the progress bar before calling finish().'); } if ($this->startTime !== null) { if (!$this->max) { $this->barChar = $this->barCharOriginal; $this->display(true); } $this->startTime = null; $this->output->writeln(''); $this->output = null; } } private function initialize() { $this->formatVars = array(); foreach ($this->defaultFormatVars as $var) { if (strpos($this->format, "%{$var}%") !== false) { $this->formatVars[$var] = true; } } if ($this->max > 0) { $this->widths['max'] = strlen($this->max); $this->widths['current'] = $this->widths['max']; } else { $this->barCharOriginal = $this->barChar; $this->barChar = $this->emptyBarChar; } } private function generate($finish = false) { $vars = array(); $percent = 0; if ($this->max > 0) { $percent = (double) round($this->current / $this->max, 2); } if (isset($this->formatVars['bar'])) { $completeBars = 0; $emptyBars = 0; if ($this->max > 0) { $completeBars = floor($percent * $this->barWidth); } else { if (!$finish) { $completeBars = floor($this->current % $this->barWidth); } else { $completeBars = $this->barWidth; } } $emptyBars = $this->barWidth - $completeBars - strlen($this->progressChar); $bar = str_repeat($this->barChar, $completeBars); if ($completeBars < $this->barWidth) { $bar .= $this->progressChar; $bar .= str_repeat($this->emptyBarChar, $emptyBars); } $vars['bar'] = $bar; } if (isset($this->formatVars['elapsed'])) { $elapsed = time() - $this->startTime; $vars['elapsed'] = str_pad($this->humaneTime($elapsed), $this->widths['elapsed'],' ', STR_PAD_LEFT); } if (isset($this->formatVars['current'])) { $vars['current'] = str_pad($this->current, $this->widths['current'],' ', STR_PAD_LEFT); } if (isset($this->formatVars['max'])) { $vars['max'] = $this->max; } if (isset($this->formatVars['percent'])) { $vars['percent'] = str_pad($percent * 100, $this->widths['percent'],' ', STR_PAD_LEFT); } return $vars; } private function humaneTime($secs) { $text =''; foreach ($this->timeFormats as $format) { if ($secs < $format[0]) { if (count($format) == 2) { $text = $format[1]; break; } else { $text = ceil($secs / $format[2]) .' '. $format[1]; break; } } } return $text; } private function overwrite(OutputInterface $output, $messages) { $output->write("\x0D"); if ($this->lastMessagesLength!==null) { $output->write(str_repeat("\x20", $this->lastMessagesLength)); $output->write("\x0D"); } $output->write($messages); $this->lastMessagesLength=strlen($messages); } public function getName() { return'progress'; } } } namespace Symfony\Component\Console\Command { use Symfony\Component\Console\Input\InputDefinition; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Application; use Symfony\Component\Console\Helper\HelperSet; class Command { private $application; private $name; private $aliases; private $definition; private $help; private $description; private $ignoreValidationErrors; private $applicationDefinitionMerged; private $code; private $synopsis; private $helperSet; public function __construct($name = null) { $this->definition = new InputDefinition(); $this->ignoreValidationErrors = false; $this->applicationDefinitionMerged = false; $this->aliases = array(); if (null !== $name) { $this->setName($name); } $this->configure(); if (!$this->name) { throw new \LogicException('The command name cannot be empty.'); } } public function ignoreValidationErrors() { $this->ignoreValidationErrors = true; } public function setApplication(Application $application = null) { $this->application = $application; if ($application) { $this->setHelperSet($application->getHelperSet()); } else { $this->helperSet = null; } } public function setHelperSet(HelperSet $helperSet) { $this->helperSet = $helperSet; } public function getHelperSet() { return $this->helperSet; } public function getApplication() { return $this->application; } public function isEnabled() { return true; } protected function configure() { } protected function execute(InputInterface $input, OutputInterface $output) { throw new \LogicException('You must override the execute() method in the concrete command class.'); } protected function interact(InputInterface $input, OutputInterface $output) { } protected function initialize(InputInterface $input, OutputInterface $output) { } public function run(InputInterface $input, OutputInterface $output) { $this->getSynopsis(); $this->mergeApplicationDefinition(); try { $input->bind($this->definition); } catch (\Exception $e) { if (!$this->ignoreValidationErrors) { throw $e; } } $this->initialize($input, $output); if ($input->isInteractive()) { $this->interact($input, $output); } $input->validate(); if ($this->code) { $statusCode = call_user_func($this->code, $input, $output); } else { $statusCode = $this->execute($input, $output); } return is_numeric($statusCode) ? $statusCode : 0; } public function setCode($code) { if (!is_callable($code)) { throw new \InvalidArgumentException('Invalid callable provided to Command::setCode.'); } $this->code = $code; return $this; } private function mergeApplicationDefinition($mergeArgs = true) { if (null === $this->application || true === $this->applicationDefinitionMerged) { return; } if ($mergeArgs) { $currentArguments = $this->definition->getArguments(); $this->definition->setArguments($this->application->getDefinition()->getArguments()); $this->definition->addArguments($currentArguments); } $this->definition->addOptions($this->application->getDefinition()->getOptions()); $this->applicationDefinitionMerged = true; } public function setDefinition($definition) { if ($definition instanceof InputDefinition) { $this->definition = $definition; } else { $this->definition->setDefinition($definition); } $this->applicationDefinitionMerged = false; return $this; } public function getDefinition() { return $this->definition; } protected function getNativeDefinition() { return $this->getDefinition(); } public function addArgument($name, $mode = null, $description ='', $default = null) { $this->definition->addArgument(new InputArgument($name, $mode, $description, $default)); return $this; } public function addOption($name, $shortcut = null, $mode = null, $description ='', $default = null) { $this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default)); return $this; } public function setName($name) { $this->validateName($name); $this->name = $name; return $this; } public function getName() { return $this->name; } public function setDescription($description) { $this->description = $description; return $this; } public function getDescription() { return $this->description; } public function setHelp($help) { $this->help = $help; return $this; } public function getHelp() { return $this->help; } public function getProcessedHelp() { $name = $this->name; $placeholders = array('%command.name%','%command.full_name%'); $replacements = array( $name, $_SERVER['PHP_SELF'].' '.$name ); return str_replace($placeholders, $replacements, $this->getHelp()); } public function setAliases($aliases) { foreach ($aliases as $alias) { $this->validateName($alias); } $this->aliases = $aliases; return $this; } public function getAliases() { return $this->aliases; } public function getSynopsis() { if (null === $this->synopsis) { $this->synopsis = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis())); } return $this->synopsis; } public function getHelper($name) { return $this->helperSet->get($name); } public function asText() { if ($this->application && !$this->applicationDefinitionMerged) { $this->getSynopsis(); $this->mergeApplicationDefinition(false); } $messages = array('<comment>Usage:</comment>',' '.$this->getSynopsis(),'', ); if ($this->getAliases()) { $messages[] ='<comment>Aliases:</comment> <info>'.implode(', ', $this->getAliases()).'</info>'; } $messages[] = $this->getNativeDefinition()->asText(); if ($help = $this->getProcessedHelp()) { $messages[] ='<comment>Help:</comment>'; $messages[] =' '.str_replace("\n","\n ", $help)."\n"; } return implode("\n", $messages); } public function asXml($asDom = false) { if ($this->application && !$this->applicationDefinitionMerged) { $this->getSynopsis(); $this->mergeApplicationDefinition(false); } $dom = new \DOMDocument('1.0','UTF-8'); $dom->formatOutput = true; $dom->appendChild($commandXML = $dom->createElement('command')); $commandXML->setAttribute('id', $this->name); $commandXML->setAttribute('name', $this->name); $commandXML->appendChild($usageXML = $dom->createElement('usage')); $usageXML->appendChild($dom->createTextNode(sprintf($this->getSynopsis(),''))); $commandXML->appendChild($descriptionXML = $dom->createElement('description')); $descriptionXML->appendChild($dom->createTextNode(str_replace("\n","\n ", $this->getDescription()))); $commandXML->appendChild($helpXML = $dom->createElement('help')); $helpXML->appendChild($dom->createTextNode(str_replace("\n","\n ", $this->getProcessedHelp()))); $commandXML->appendChild($aliasesXML = $dom->createElement('aliases')); foreach ($this->getAliases() as $alias) { $aliasesXML->appendChild($aliasXML = $dom->createElement('alias')); $aliasXML->appendChild($dom->createTextNode($alias)); } $definition = $this->getNativeDefinition()->asXml(true); $commandXML->appendChild($dom->importNode($definition->getElementsByTagName('arguments')->item(0), true)); $commandXML->appendChild($dom->importNode($definition->getElementsByTagName('options')->item(0), true)); return $asDom ? $dom : $dom->saveXml(); } private function validateName($name) { if (!preg_match('/^[^\:]+(\:[^\:]+)*$/', $name)) { throw new \InvalidArgumentException(sprintf('Command name "%s" is invalid.', $name)); } } } } namespace Symfony\Component\Console\Command { use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Command\Command; class HelpCommand extends Command { private $command; protected function configure() { $this->ignoreValidationErrors(); $this ->setName('help') ->setDefinition(array( new InputArgument('command_name', InputArgument::OPTIONAL,'The command name','help'), new InputOption('xml', null, InputOption::VALUE_NONE,'To output help as XML'), )) ->setDescription('Displays help for a command') ->setHelp(<<<EOF
The <info>%command.name%</info> command displays help for a given command:

  <info>php %command.full_name% list</info>

You can also output the help as XML by using the <comment>--xml</comment> option:

  <info>php %command.full_name% --xml list</info>

To display the list of available commands, please use the <info>list</info> command.
EOF
) ; } public function setCommand(Command $command) { $this->command = $command; } protected function execute(InputInterface $input, OutputInterface $output) { if (null === $this->command) { $this->command = $this->getApplication()->find($input->getArgument('command_name')); } if ($input->getOption('xml')) { $output->writeln($this->command->asXml(), OutputInterface::OUTPUT_RAW); } else { $output->writeln($this->command->asText()); } $this->command = null; } } } namespace Symfony\Component\Console\Command { use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Command\Command; use Symfony\Component\Console\Input\InputDefinition; class ListCommand extends Command { protected function configure() { $this ->setName('list') ->setDefinition($this->createDefinition()) ->setDescription('Lists commands') ->setHelp(<<<EOF
The <info>%command.name%</info> command lists all commands:

  <info>php %command.full_name%</info>

You can also display the commands for a specific namespace:

  <info>php %command.full_name% test</info>

You can also output the information as XML by using the <comment>--xml</comment> option:

  <info>php %command.full_name% --xml</info>

It's also possible to get raw list of commands (useful for embedding command runner):

  <info>php %command.full_name% --raw</info>
EOF
) ; } protected function getNativeDefinition() { return $this->createDefinition(); } protected function execute(InputInterface $input, OutputInterface $output) { if ($input->getOption('xml')) { $output->writeln($this->getApplication()->asXml($input->getArgument('namespace')), OutputInterface::OUTPUT_RAW); } else { $output->writeln($this->getApplication()->asText($input->getArgument('namespace'), $input->getOption('raw'))); } } private function createDefinition() { return new InputDefinition(array( new InputArgument('namespace', InputArgument::OPTIONAL,'The namespace name'), new InputOption('xml', null, InputOption::VALUE_NONE,'To output help as XML'), new InputOption('raw', null, InputOption::VALUE_NONE,'To output raw command list'), )); } } } namespace Symfony\Component\Console\Formatter { interface OutputFormatterInterface { public function setDecorated($decorated); public function isDecorated(); public function setStyle($name, OutputFormatterStyleInterface $style); public function hasStyle($name); public function getStyle($name); public function format($message); } } namespace Symfony\Component\Console\Formatter { class OutputFormatter implements OutputFormatterInterface { const FORMAT_PATTERN ='#(\\\\?)<(/?)([a-z][a-z0-9_=;-]+)?>((?: [^<\\\\]+ | (?!<(?:/?[a-z]|/>)). | .(?<=\\\\<) )*)#isx'; private $decorated; private $styles = array(); private $styleStack; public static function escape($text) { return preg_replace('/([^\\\\]?)</is','$1\\<', $text); } public function __construct($decorated = null, array $styles = array()) { $this->decorated = (Boolean) $decorated; $this->setStyle('error', new OutputFormatterStyle('white','red')); $this->setStyle('info', new OutputFormatterStyle('green')); $this->setStyle('comment', new OutputFormatterStyle('yellow')); $this->setStyle('question', new OutputFormatterStyle('black','cyan')); foreach ($styles as $name => $style) { $this->setStyle($name, $style); } $this->styleStack = new OutputFormatterStyleStack(); } public function setDecorated($decorated) { $this->decorated = (Boolean) $decorated; } public function isDecorated() { return $this->decorated; } public function setStyle($name, OutputFormatterStyleInterface $style) { $this->styles[strtolower($name)] = $style; } public function hasStyle($name) { return isset($this->styles[strtolower($name)]); } public function getStyle($name) { if (!$this->hasStyle($name)) { throw new \InvalidArgumentException('Undefined style: '.$name); } return $this->styles[strtolower($name)]; } public function format($message) { $message = preg_replace_callback(self::FORMAT_PATTERN, array($this,'replaceStyle'), $message); return str_replace('\\<','<', $message); } public function getStyleStack() { return $this->styleStack; } private function replaceStyle($match) { if ('\\'=== $match[1]) { return $this->applyCurrentStyle($match[0]); } if (''=== $match[3]) { if ('/'=== $match[2]) { $this->styleStack->pop(); return $this->applyCurrentStyle($match[4]); } return'<>'.$this->applyCurrentStyle($match[4]); } if (isset($this->styles[strtolower($match[3])])) { $style = $this->styles[strtolower($match[3])]; } else { $style = $this->createStyleFromString($match[3]); if (false === $style) { return $this->applyCurrentStyle($match[0]); } } if ('/'=== $match[2]) { $this->styleStack->pop($style); } else { $this->styleStack->push($style); } return $this->applyCurrentStyle($match[4]); } private function createStyleFromString($string) { if (!preg_match_all('/([^=]+)=([^;]+)(;|$)/', strtolower($string), $matches, PREG_SET_ORDER)) { return false; } $style = new OutputFormatterStyle(); foreach ($matches as $match) { array_shift($match); if ('fg'== $match[0]) { $style->setForeground($match[1]); } elseif ('bg'== $match[0]) { $style->setBackground($match[1]); } else { $style->setOption($match[1]); } } return $style; } private function applyCurrentStyle($text) { return $this->isDecorated() && strlen($text) > 0 ? $this->styleStack->getCurrent()->apply($text) : $text; } } } namespace Symfony\Component\Console\Formatter { interface OutputFormatterStyleInterface { public function setForeground($color = null); public function setBackground($color = null); public function setOption($option); public function unsetOption($option); public function setOptions(array $options); public function apply($text); } } namespace Symfony\Component\Console\Formatter { class OutputFormatterStyle implements OutputFormatterStyleInterface { private static $availableForegroundColors = array('black'=> 30,'red'=> 31,'green'=> 32,'yellow'=> 33,'blue'=> 34,'magenta'=> 35,'cyan'=> 36,'white'=> 37 ); private static $availableBackgroundColors = array('black'=> 40,'red'=> 41,'green'=> 42,'yellow'=> 43,'blue'=> 44,'magenta'=> 45,'cyan'=> 46,'white'=> 47 ); private static $availableOptions = array('bold'=> 1,'underscore'=> 4,'blink'=> 5,'reverse'=> 7,'conceal'=> 8 ); private $foreground; private $background; private $options = array(); public function __construct($foreground = null, $background = null, array $options = array()) { if (null !== $foreground) { $this->setForeground($foreground); } if (null !== $background) { $this->setBackground($background); } if (count($options)) { $this->setOptions($options); } } public function setForeground($color = null) { if (null === $color) { $this->foreground = null; return; } if (!isset(static::$availableForegroundColors[$color])) { throw new \InvalidArgumentException(sprintf('Invalid foreground color specified: "%s". Expected one of (%s)', $color, implode(', ', array_keys(static::$availableForegroundColors)) )); } $this->foreground = static::$availableForegroundColors[$color]; } public function setBackground($color = null) { if (null === $color) { $this->background = null; return; } if (!isset(static::$availableBackgroundColors[$color])) { throw new \InvalidArgumentException(sprintf('Invalid background color specified: "%s". Expected one of (%s)', $color, implode(', ', array_keys(static::$availableBackgroundColors)) )); } $this->background = static::$availableBackgroundColors[$color]; } public function setOption($option) { if (!isset(static::$availableOptions[$option])) { throw new \InvalidArgumentException(sprintf('Invalid option specified: "%s". Expected one of (%s)', $option, implode(', ', array_keys(static::$availableOptions)) )); } if (false === array_search(static::$availableOptions[$option], $this->options)) { $this->options[] = static::$availableOptions[$option]; } } public function unsetOption($option) { if (!isset(static::$availableOptions[$option])) { throw new \InvalidArgumentException(sprintf('Invalid option specified: "%s". Expected one of (%s)', $option, implode(', ', array_keys(static::$availableOptions)) )); } $pos = array_search(static::$availableOptions[$option], $this->options); if (false !== $pos) { unset($this->options[$pos]); } } public function setOptions(array $options) { $this->options = array(); foreach ($options as $option) { $this->setOption($option); } } public function apply($text) { $codes = array(); if (null !== $this->foreground) { $codes[] = $this->foreground; } if (null !== $this->background) { $codes[] = $this->background; } if (count($this->options)) { $codes = array_merge($codes, $this->options); } if (0 === count($codes)) { return $text; } return sprintf("\033[%sm%s\033[0m", implode(';', $codes), $text); } } } namespace Symfony\Component\Console\Formatter { class OutputFormatterStyleStack { private $styles; private $emptyStyle; public function __construct(OutputFormatterStyleInterface $emptyStyle = null) { $this->emptyStyle = $emptyStyle ?: new OutputFormatterStyle(); $this->reset(); } public function reset() { $this->styles = array(); } public function push(OutputFormatterStyleInterface $style) { $this->styles[] = $style; } public function pop(OutputFormatterStyleInterface $style = null) { if (empty($this->styles)) { return $this->emptyStyle; } if (null === $style) { return array_pop($this->styles); } foreach (array_reverse($this->styles, true) as $index => $stackedStyle) { if ($style->apply('') === $stackedStyle->apply('')) { $this->styles = array_slice($this->styles, 0, $index); return $stackedStyle; } } throw new \InvalidArgumentException('Incorrectly nested style tag found.'); } public function getCurrent() { if (empty($this->styles)) { return $this->emptyStyle; } return $this->styles[count($this->styles)-1]; } public function setEmptyStyle(OutputFormatterStyleInterface $emptyStyle) { $this->emptyStyle = $emptyStyle; return $this; } public function getEmptyStyle() { return $this->emptyStyle; } } } namespace Symfony\Component\Console\Input { interface InputInterface { public function getFirstArgument(); public function hasParameterOption($values); public function getParameterOption($values, $default = false); public function bind(InputDefinition $definition); public function validate(); public function getArguments(); public function getArgument($name); public function setArgument($name, $value); public function hasArgument($name); public function getOptions(); public function getOption($name); public function setOption($name, $value); public function hasOption($name); public function isInteractive(); public function setInteractive($interactive); } } namespace Symfony\Component\Console\Input { abstract class Input implements InputInterface { protected $definition; protected $options; protected $arguments; protected $interactive = true; public function __construct(InputDefinition $definition = null) { if (null === $definition) { $this->arguments = array(); $this->options = array(); $this->definition = new InputDefinition(); } else { $this->bind($definition); $this->validate(); } } public function bind(InputDefinition $definition) { $this->arguments = array(); $this->options = array(); $this->definition = $definition; $this->parse(); } abstract protected function parse(); public function validate() { if (count($this->arguments) < $this->definition->getArgumentRequiredCount()) { throw new \RuntimeException('Not enough arguments.'); } } public function isInteractive() { return $this->interactive; } public function setInteractive($interactive) { $this->interactive = (Boolean) $interactive; } public function getArguments() { return array_merge($this->definition->getArgumentDefaults(), $this->arguments); } public function getArgument($name) { if (!$this->definition->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } return isset($this->arguments[$name]) ? $this->arguments[$name] : $this->definition->getArgument($name)->getDefault(); } public function setArgument($name, $value) { if (!$this->definition->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } $this->arguments[$name] = $value; } public function hasArgument($name) { return $this->definition->hasArgument($name); } public function getOptions() { return array_merge($this->definition->getOptionDefaults(), $this->options); } public function getOption($name) { if (!$this->definition->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "%s" option does not exist.', $name)); } return isset($this->options[$name]) ? $this->options[$name] : $this->definition->getOption($name)->getDefault(); } public function setOption($name, $value) { if (!$this->definition->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "%s" option does not exist.', $name)); } $this->options[$name] = $value; } public function hasOption($name) { return $this->definition->hasOption($name); } } } namespace Symfony\Component\Console\Input { class ArgvInput extends Input { private $tokens; private $parsed; public function __construct(array $argv = null, InputDefinition $definition = null) { if (null === $argv) { $argv = $_SERVER['argv']; } array_shift($argv); $this->tokens = $argv; parent::__construct($definition); } protected function setTokens(array $tokens) { $this->tokens = $tokens; $this->parse(); } protected function parse() { $parseOptions = true; $this->parsed = $this->tokens; while (null !== $token = array_shift($this->parsed)) { if ($parseOptions &&''== $token) { $this->parseArgument($token); } elseif ($parseOptions &&'--'== $token) { $parseOptions = false; } elseif ($parseOptions && 0 === strpos($token,'--')) { $this->parseLongOption($token); } elseif ($parseOptions &&'-'=== $token[0]) { $this->parseShortOption($token); } else { $this->parseArgument($token); } } } private function parseShortOption($token) { $name = substr($token, 1); if (strlen($name) > 1) { if ($this->definition->hasShortcut($name[0]) && $this->definition->getOptionForShortcut($name[0])->acceptValue()) { $this->addShortOption($name[0], substr($name, 1)); } else { $this->parseShortOptionSet($name); } } else { $this->addShortOption($name, null); } } private function parseShortOptionSet($name) { $len = strlen($name); for ($i = 0; $i < $len; $i++) { if (!$this->definition->hasShortcut($name[$i])) { throw new \RuntimeException(sprintf('The "-%s" option does not exist.', $name[$i])); } $option = $this->definition->getOptionForShortcut($name[$i]); if ($option->acceptValue()) { $this->addLongOption($option->getName(), $i === $len - 1 ? null : substr($name, $i + 1)); break; } else { $this->addLongOption($option->getName(), true); } } } private function parseLongOption($token) { $name = substr($token, 2); if (false !== $pos = strpos($name,'=')) { $this->addLongOption(substr($name, 0, $pos), substr($name, $pos + 1)); } else { $this->addLongOption($name, null); } } private function parseArgument($token) { $c = count($this->arguments); if ($this->definition->hasArgument($c)) { $arg = $this->definition->getArgument($c); $this->arguments[$arg->getName()] = $arg->isArray()? array($token) : $token; } elseif ($this->definition->hasArgument($c - 1) && $this->definition->getArgument($c - 1)->isArray()) { $arg = $this->definition->getArgument($c - 1); $this->arguments[$arg->getName()][] = $token; } else { throw new \RuntimeException('Too many arguments.'); } } private function addShortOption($shortcut, $value) { if (!$this->definition->hasShortcut($shortcut)) { throw new \RuntimeException(sprintf('The "-%s" option does not exist.', $shortcut)); } $this->addLongOption($this->definition->getOptionForShortcut($shortcut)->getName(), $value); } private function addLongOption($name, $value) { if (!$this->definition->hasOption($name)) { throw new \RuntimeException(sprintf('The "--%s" option does not exist.', $name)); } $option = $this->definition->getOption($name); if (null === $value && $option->acceptValue() && count($this->parsed)) { $next = array_shift($this->parsed); if (isset($next[0]) &&'-'!== $next[0]) { $value = $next; } elseif (empty($next)) { $value =''; } else { array_unshift($this->parsed, $next); } } if (null === $value) { if ($option->isValueRequired()) { throw new \RuntimeException(sprintf('The "--%s" option requires a value.', $name)); } $value = $option->isValueOptional() ? $option->getDefault() : true; } if ($option->isArray()) { $this->options[$name][] = $value; } else { $this->options[$name] = $value; } } public function getFirstArgument() { foreach ($this->tokens as $token) { if ($token &&'-'=== $token[0]) { continue; } return $token; } } public function hasParameterOption($values) { $values = (array) $values; foreach ($this->tokens as $v) { if (in_array($v, $values)) { return true; } } return false; } public function getParameterOption($values, $default = false) { $values = (array) $values; $tokens = $this->tokens; while ($token = array_shift($tokens)) { foreach ($values as $value) { if (0 === strpos($token, $value)) { if (false !== $pos = strpos($token,'=')) { return substr($token, $pos + 1); } return array_shift($tokens); } } } return $default; } } } namespace Symfony\Component\Console\Input { class ArrayInput extends Input { private $parameters; public function __construct(array $parameters, InputDefinition $definition = null) { $this->parameters = $parameters; parent::__construct($definition); } public function getFirstArgument() { foreach ($this->parameters as $key => $value) { if ($key &&'-'=== $key[0]) { continue; } return $value; } } public function hasParameterOption($values) { $values = (array) $values; foreach ($this->parameters as $k => $v) { if (!is_int($k)) { $v = $k; } if (in_array($v, $values)) { return true; } } return false; } public function getParameterOption($values, $default = false) { $values = (array) $values; foreach ($this->parameters as $k => $v) { if (is_int($k) && in_array($v, $values)) { return true; } elseif (in_array($k, $values)) { return $v; } } return $default; } protected function parse() { foreach ($this->parameters as $key => $value) { if (0 === strpos($key,'--')) { $this->addLongOption(substr($key, 2), $value); } elseif ('-'=== $key[0]) { $this->addShortOption(substr($key, 1), $value); } else { $this->addArgument($key, $value); } } } private function addShortOption($shortcut, $value) { if (!$this->definition->hasShortcut($shortcut)) { throw new \InvalidArgumentException(sprintf('The "-%s" option does not exist.', $shortcut)); } $this->addLongOption($this->definition->getOptionForShortcut($shortcut)->getName(), $value); } private function addLongOption($name, $value) { if (!$this->definition->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "--%s" option does not exist.', $name)); } $option = $this->definition->getOption($name); if (null === $value) { if ($option->isValueRequired()) { throw new \InvalidArgumentException(sprintf('The "--%s" option requires a value.', $name)); } $value = $option->isValueOptional() ? $option->getDefault() : true; } $this->options[$name] = $value; } private function addArgument($name, $value) { if (!$this->definition->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } $this->arguments[$name] = $value; } } } namespace Symfony\Component\Console\Input { class InputArgument { const REQUIRED = 1; const OPTIONAL = 2; const IS_ARRAY = 4; private $name; private $mode; private $default; private $description; public function __construct($name, $mode = null, $description ='', $default = null) { if (null === $mode) { $mode = self::OPTIONAL; } elseif (!is_int($mode) || $mode > 7 || $mode < 1) { throw new \InvalidArgumentException(sprintf('Argument mode "%s" is not valid.', $mode)); } $this->name = $name; $this->mode = $mode; $this->description = $description; $this->setDefault($default); } public function getName() { return $this->name; } public function isRequired() { return self::REQUIRED === (self::REQUIRED & $this->mode); } public function isArray() { return self::IS_ARRAY === (self::IS_ARRAY & $this->mode); } public function setDefault($default = null) { if (self::REQUIRED === $this->mode && null !== $default) { throw new \LogicException('Cannot set a default value except for InputArgument::OPTIONAL mode.'); } if ($this->isArray()) { if (null === $default) { $default = array(); } elseif (!is_array($default)) { throw new \LogicException('A default value for an array argument must be an array.'); } } $this->default = $default; } public function getDefault() { return $this->default; } public function getDescription() { return $this->description; } } } namespace Symfony\Component\Console\Input { class InputDefinition { private $arguments; private $requiredCount; private $hasAnArrayArgument = false; private $hasOptional; private $options; private $shortcuts; public function __construct(array $definition = array()) { $this->setDefinition($definition); } public function setDefinition(array $definition) { $arguments = array(); $options = array(); foreach ($definition as $item) { if ($item instanceof InputOption) { $options[] = $item; } else { $arguments[] = $item; } } $this->setArguments($arguments); $this->setOptions($options); } public function setArguments($arguments = array()) { $this->arguments = array(); $this->requiredCount = 0; $this->hasOptional = false; $this->hasAnArrayArgument = false; $this->addArguments($arguments); } public function addArguments($arguments = array()) { if (null !== $arguments) { foreach ($arguments as $argument) { $this->addArgument($argument); } } } public function addArgument(InputArgument $argument) { if (isset($this->arguments[$argument->getName()])) { throw new \LogicException(sprintf('An argument with name "%s" already exists.', $argument->getName())); } if ($this->hasAnArrayArgument) { throw new \LogicException('Cannot add an argument after an array argument.'); } if ($argument->isRequired() && $this->hasOptional) { throw new \LogicException('Cannot add a required argument after an optional one.'); } if ($argument->isArray()) { $this->hasAnArrayArgument = true; } if ($argument->isRequired()) { ++$this->requiredCount; } else { $this->hasOptional = true; } $this->arguments[$argument->getName()] = $argument; } public function getArgument($name) { $arguments = is_int($name) ? array_values($this->arguments) : $this->arguments; if (!$this->hasArgument($name)) { throw new \InvalidArgumentException(sprintf('The "%s" argument does not exist.', $name)); } return $arguments[$name]; } public function hasArgument($name) { $arguments = is_int($name) ? array_values($this->arguments) : $this->arguments; return isset($arguments[$name]); } public function getArguments() { return $this->arguments; } public function getArgumentCount() { return $this->hasAnArrayArgument ? PHP_INT_MAX : count($this->arguments); } public function getArgumentRequiredCount() { return $this->requiredCount; } public function getArgumentDefaults() { $values = array(); foreach ($this->arguments as $argument) { $values[$argument->getName()] = $argument->getDefault(); } return $values; } public function setOptions($options = array()) { $this->options = array(); $this->shortcuts = array(); $this->addOptions($options); } public function addOptions($options = array()) { foreach ($options as $option) { $this->addOption($option); } } public function addOption(InputOption $option) { if (isset($this->options[$option->getName()]) && !$option->equals($this->options[$option->getName()])) { throw new \LogicException(sprintf('An option named "%s" already exists.', $option->getName())); } elseif (isset($this->shortcuts[$option->getShortcut()]) && !$option->equals($this->options[$this->shortcuts[$option->getShortcut()]])) { throw new \LogicException(sprintf('An option with shortcut "%s" already exists.', $option->getShortcut())); } $this->options[$option->getName()] = $option; if ($option->getShortcut()) { $this->shortcuts[$option->getShortcut()] = $option->getName(); } } public function getOption($name) { if (!$this->hasOption($name)) { throw new \InvalidArgumentException(sprintf('The "--%s" option does not exist.', $name)); } return $this->options[$name]; } public function hasOption($name) { return isset($this->options[$name]); } public function getOptions() { return $this->options; } public function hasShortcut($name) { return isset($this->shortcuts[$name]); } public function getOptionForShortcut($shortcut) { return $this->getOption($this->shortcutToName($shortcut)); } public function getOptionDefaults() { $values = array(); foreach ($this->options as $option) { $values[$option->getName()] = $option->getDefault(); } return $values; } private function shortcutToName($shortcut) { if (!isset($this->shortcuts[$shortcut])) { throw new \InvalidArgumentException(sprintf('The "-%s" option does not exist.', $shortcut)); } return $this->shortcuts[$shortcut]; } public function getSynopsis() { $elements = array(); foreach ($this->getOptions() as $option) { $shortcut = $option->getShortcut() ? sprintf('-%s|', $option->getShortcut()) :''; $elements[] = sprintf('['.($option->isValueRequired() ?'%s--%s="..."': ($option->isValueOptional() ?'%s--%s[="..."]':'%s--%s')).']', $shortcut, $option->getName()); } foreach ($this->getArguments() as $argument) { $elements[] = sprintf($argument->isRequired() ?'%s':'[%s]', $argument->getName().($argument->isArray() ?'1':'')); if ($argument->isArray()) { $elements[] = sprintf('... [%sN]', $argument->getName()); } } return implode(' ', $elements); } public function asText() { $max = 0; foreach ($this->getOptions() as $option) { $nameLength = strlen($option->getName()) + 2; if ($option->getShortcut()) { $nameLength += strlen($option->getShortcut()) + 3; } $max = max($max, $nameLength); } foreach ($this->getArguments() as $argument) { $max = max($max, strlen($argument->getName())); } ++$max; $text = array(); if ($this->getArguments()) { $text[] ='<comment>Arguments:</comment>'; foreach ($this->getArguments() as $argument) { if (null !== $argument->getDefault() && (!is_array($argument->getDefault()) || count($argument->getDefault()))) { $default = sprintf('<comment> (default: %s)</comment>', $this->formatDefaultValue($argument->getDefault())); } else { $default =''; } $description = str_replace("\n","\n".str_repeat(' ', $max + 2), $argument->getDescription()); $text[] = sprintf(" <info>%-${max}s</info> %s%s", $argument->getName(), $description, $default); } $text[] =''; } if ($this->getOptions()) { $text[] ='<comment>Options:</comment>'; foreach ($this->getOptions() as $option) { if ($option->acceptValue() && null !== $option->getDefault() && (!is_array($option->getDefault()) || count($option->getDefault()))) { $default = sprintf('<comment> (default: %s)</comment>', $this->formatDefaultValue($option->getDefault())); } else { $default =''; } $multiple = $option->isArray() ?'<comment> (multiple values allowed)</comment>':''; $description = str_replace("\n","\n".str_repeat(' ', $max + 2), $option->getDescription()); $optionMax = $max - strlen($option->getName()) - 2; $text[] = sprintf(" <info>%s</info> %-${optionMax}s%s%s%s",'--'.$option->getName(), $option->getShortcut() ? sprintf('(-%s) ', $option->getShortcut()) :'', $description, $default, $multiple ); } $text[] =''; } return implode("\n", $text); } public function asXml($asDom = false) { $dom = new \DOMDocument('1.0','UTF-8'); $dom->formatOutput = true; $dom->appendChild($definitionXML = $dom->createElement('definition')); $definitionXML->appendChild($argumentsXML = $dom->createElement('arguments')); foreach ($this->getArguments() as $argument) { $argumentsXML->appendChild($argumentXML = $dom->createElement('argument')); $argumentXML->setAttribute('name', $argument->getName()); $argumentXML->setAttribute('is_required', $argument->isRequired() ? 1 : 0); $argumentXML->setAttribute('is_array', $argument->isArray() ? 1 : 0); $argumentXML->appendChild($descriptionXML = $dom->createElement('description')); $descriptionXML->appendChild($dom->createTextNode($argument->getDescription())); $argumentXML->appendChild($defaultsXML = $dom->createElement('defaults')); $defaults = is_array($argument->getDefault()) ? $argument->getDefault() : (is_bool($argument->getDefault()) ? array(var_export($argument->getDefault(), true)) : ($argument->getDefault() ? array($argument->getDefault()) : array())); foreach ($defaults as $default) { $defaultsXML->appendChild($defaultXML = $dom->createElement('default')); $defaultXML->appendChild($dom->createTextNode($default)); } } $definitionXML->appendChild($optionsXML = $dom->createElement('options')); foreach ($this->getOptions() as $option) { $optionsXML->appendChild($optionXML = $dom->createElement('option')); $optionXML->setAttribute('name','--'.$option->getName()); $optionXML->setAttribute('shortcut', $option->getShortcut() ?'-'.$option->getShortcut() :''); $optionXML->setAttribute('accept_value', $option->acceptValue() ? 1 : 0); $optionXML->setAttribute('is_value_required', $option->isValueRequired() ? 1 : 0); $optionXML->setAttribute('is_multiple', $option->isArray() ? 1 : 0); $optionXML->appendChild($descriptionXML = $dom->createElement('description')); $descriptionXML->appendChild($dom->createTextNode($option->getDescription())); if ($option->acceptValue()) { $optionXML->appendChild($defaultsXML = $dom->createElement('defaults')); $defaults = is_array($option->getDefault()) ? $option->getDefault() : (is_bool($option->getDefault()) ? array(var_export($option->getDefault(), true)) : ($option->getDefault() ? array($option->getDefault()) : array())); foreach ($defaults as $default) { $defaultsXML->appendChild($defaultXML = $dom->createElement('default')); $defaultXML->appendChild($dom->createTextNode($default)); } } } return $asDom ? $dom : $dom->saveXml(); } private function formatDefaultValue($default) { if (version_compare(PHP_VERSION,'5.4','<')) { return str_replace('\/','/', json_encode($default)); } return json_encode($default, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE); } } } namespace Symfony\Component\Console\Input { class InputOption { const VALUE_NONE = 1; const VALUE_REQUIRED = 2; const VALUE_OPTIONAL = 4; const VALUE_IS_ARRAY = 8; private $name; private $shortcut; private $mode; private $default; private $description; public function __construct($name, $shortcut = null, $mode = null, $description ='', $default = null) { if (0 === strpos($name,'--')) { $name = substr($name, 2); } if (empty($name)) { throw new \InvalidArgumentException('An option name cannot be empty.'); } if (empty($shortcut)) { $shortcut = null; } if (null !== $shortcut) { if ('-'=== $shortcut[0]) { $shortcut = substr($shortcut, 1); } if (empty($shortcut)) { throw new \InvalidArgumentException('An option shortcut cannot be empty.'); } } if (null === $mode) { $mode = self::VALUE_NONE; } elseif (!is_int($mode) || $mode > 15 || $mode < 1) { throw new \InvalidArgumentException(sprintf('Option mode "%s" is not valid.', $mode)); } $this->name = $name; $this->shortcut = $shortcut; $this->mode = $mode; $this->description = $description; if ($this->isArray() && !$this->acceptValue()) { throw new \InvalidArgumentException('Impossible to have an option mode VALUE_IS_ARRAY if the option does not accept a value.'); } $this->setDefault($default); } public function getShortcut() { return $this->shortcut; } public function getName() { return $this->name; } public function acceptValue() { return $this->isValueRequired() || $this->isValueOptional(); } public function isValueRequired() { return self::VALUE_REQUIRED === (self::VALUE_REQUIRED & $this->mode); } public function isValueOptional() { return self::VALUE_OPTIONAL === (self::VALUE_OPTIONAL & $this->mode); } public function isArray() { return self::VALUE_IS_ARRAY === (self::VALUE_IS_ARRAY & $this->mode); } public function setDefault($default = null) { if (self::VALUE_NONE === (self::VALUE_NONE & $this->mode) && null !== $default) { throw new \LogicException('Cannot set a default value when using InputOption::VALUE_NONE mode.'); } if ($this->isArray()) { if (null === $default) { $default = array(); } elseif (!is_array($default)) { throw new \LogicException('A default value for an array option must be an array.'); } } $this->default = $this->acceptValue() ? $default : false; } public function getDefault() { return $this->default; } public function getDescription() { return $this->description; } public function equals(InputOption $option) { return $option->getName() === $this->getName() && $option->getShortcut() === $this->getShortcut() && $option->getDefault() === $this->getDefault() && $option->isArray() === $this->isArray() && $option->isValueRequired() === $this->isValueRequired() && $option->isValueOptional() === $this->isValueOptional() ; } } } namespace Symfony\Component\Console\Input { class StringInput extends ArgvInput { const REGEX_STRING ='([^ ]+?)(?: |(?<!\\\\)"|(?<!\\\\)\'|$)'; const REGEX_QUOTED_STRING ='(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'([^\'\\\\]*(?:\\\\.[^\'\\\\]*)*)\')'; public function __construct($input, InputDefinition $definition = null) { parent::__construct(array(), $definition); $this->setTokens($this->tokenize($input)); } private function tokenize($input) { $input = preg_replace('/(\r\n|\r|\n|\t)/',' ', $input); $tokens = array(); $length = strlen($input); $cursor = 0; while ($cursor < $length) { if (preg_match('/\s+/A', $input, $match, null, $cursor)) { } elseif (preg_match('/([^="\' ]+?)(=?)('.self::REGEX_QUOTED_STRING.'+)/A', $input, $match, null, $cursor)) { $tokens[] = $match[1].$match[2].stripcslashes(str_replace(array('"\'','\'"','\'\'','""'),'', substr($match[3], 1, strlen($match[3]) - 2))); } elseif (preg_match('/'.self::REGEX_QUOTED_STRING.'/A', $input, $match, null, $cursor)) { $tokens[] = stripcslashes(substr($match[0], 1, strlen($match[0]) - 2)); } elseif (preg_match('/'.self::REGEX_STRING.'/A', $input, $match, null, $cursor)) { $tokens[] = stripcslashes($match[1]); } else { throw new \InvalidArgumentException(sprintf('Unable to parse input near "... %s ..."', substr($input, $cursor, 10))); } $cursor += strlen($match[0]); } return $tokens; } } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatterInterface; interface OutputInterface { const VERBOSITY_QUIET = 0; const VERBOSITY_NORMAL = 1; const VERBOSITY_VERBOSE = 2; const OUTPUT_NORMAL = 0; const OUTPUT_RAW = 1; const OUTPUT_PLAIN = 2; public function write($messages, $newline = false, $type = 0); public function writeln($messages, $type = 0); public function setVerbosity($level); public function getVerbosity(); public function setDecorated($decorated); public function isDecorated(); public function setFormatter(OutputFormatterInterface $formatter); public function getFormatter(); } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatterInterface; use Symfony\Component\Console\Formatter\OutputFormatter; abstract class Output implements OutputInterface { private $verbosity; private $formatter; public function __construct($verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null) { $this->verbosity = null === $verbosity ? self::VERBOSITY_NORMAL : $verbosity; $this->formatter = null === $formatter ? new OutputFormatter() : $formatter; $this->formatter->setDecorated((Boolean) $decorated); } public function setFormatter(OutputFormatterInterface $formatter) { $this->formatter = $formatter; } public function getFormatter() { return $this->formatter; } public function setDecorated($decorated) { $this->formatter->setDecorated((Boolean) $decorated); } public function isDecorated() { return $this->formatter->isDecorated(); } public function setVerbosity($level) { $this->verbosity = (int) $level; } public function getVerbosity() { return $this->verbosity; } public function writeln($messages, $type = 0) { $this->write($messages, true, $type); } public function write($messages, $newline = false, $type = 0) { if (self::VERBOSITY_QUIET === $this->verbosity) { return; } $messages = (array) $messages; foreach ($messages as $message) { switch ($type) { case OutputInterface::OUTPUT_NORMAL: $message = $this->formatter->format($message); break; case OutputInterface::OUTPUT_RAW: break; case OutputInterface::OUTPUT_PLAIN: $message = strip_tags($this->formatter->format($message)); break; default: throw new \InvalidArgumentException(sprintf('Unknown output type given (%s)', $type)); } $this->doWrite($message, $newline); } } abstract protected function doWrite($message, $newline); } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatterInterface; class StreamOutput extends Output { private $stream; public function __construct($stream, $verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null) { if (!is_resource($stream) ||'stream'!== get_resource_type($stream)) { throw new \InvalidArgumentException('The StreamOutput class needs a stream as its first argument.'); } $this->stream = $stream; if (null === $decorated) { $decorated = $this->hasColorSupport(); } parent::__construct($verbosity, $decorated, $formatter); } public function getStream() { return $this->stream; } protected function doWrite($message, $newline) { if (false === @fwrite($this->stream, $message.($newline ? PHP_EOL :''))) { throw new \RuntimeException('Unable to write output.'); } fflush($this->stream); } protected function hasColorSupport() { if (DIRECTORY_SEPARATOR =='\\') { return false !== getenv('ANSICON') ||'ON'=== getenv('ConEmuANSI'); } return function_exists('posix_isatty') && @posix_isatty($this->stream); } } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Output\OutputInterface; interface ConsoleOutputInterface extends OutputInterface { public function getErrorOutput(); public function setErrorOutput(OutputInterface $error); } } namespace Symfony\Component\Console\Output { use Symfony\Component\Console\Formatter\OutputFormatterInterface; use Symfony\Component\Console\Output\ConsoleOutputInterface; class ConsoleOutput extends StreamOutput implements ConsoleOutputInterface { private $stderr; public function __construct($verbosity = self::VERBOSITY_NORMAL, $decorated = null, OutputFormatterInterface $formatter = null) { $outputStream ='php://stdout'; if (!$this->hasStdoutSupport()) { $outputStream ='php://output'; } parent::__construct(fopen($outputStream,'w'), $verbosity, $decorated, $formatter); $this->stderr = new StreamOutput(fopen('php://stderr','w'), $verbosity, $decorated, $formatter); } public function setDecorated($decorated) { parent::setDecorated($decorated); $this->stderr->setDecorated($decorated); } public function setFormatter(OutputFormatterInterface $formatter) { parent::setFormatter($formatter); $this->stderr->setFormatter($formatter); } public function setVerbosity($level) { parent::setVerbosity($level); $this->stderr->setVerbosity($level); } public function getErrorOutput() { return $this->stderr; } public function setErrorOutput(OutputInterface $error) { $this->stderr = $error; } protected function hasStdoutSupport() { return ('OS400'!= php_uname('s')); } } } namespace Symfony\Component\Console\Output { class NullOutput extends Output { protected function doWrite($message, $newline) { } } } namespace Symfony\Component\Console { use Symfony\Component\Console\Application; use Symfony\Component\Console\Input\StringInput; use Symfony\Component\Console\Output\ConsoleOutput; use Symfony\Component\Process\ProcessBuilder; use Symfony\Component\Process\PhpExecutableFinder; class Shell { private $application; private $history; private $output; private $hasReadline; private $prompt; private $processIsolation; public function __construct(Application $application) { $this->hasReadline = function_exists('readline'); $this->application = $application; $this->history = getenv('HOME').'/.history_'.$application->getName(); $this->output = new ConsoleOutput(); $this->prompt = $application->getName().' > '; $this->processIsolation = false; } public function run() { $this->application->setAutoExit(false); $this->application->setCatchExceptions(true); if ($this->hasReadline) { readline_read_history($this->history); readline_completion_function(array($this,'autocompleter')); } $this->output->writeln($this->getHeader()); $php = null; if ($this->processIsolation) { $finder = new PhpExecutableFinder(); $php = $finder->find(); $this->output->writeln(<<<EOF
<info>Running with process isolation, you should consider this:</info>
  * each command is executed as separate process,
  * commands don't support interactivity, all params must be passed explicitly,
  * commands output is not colorized.

EOF
); } while (true) { $command = $this->readline(); if (false === $command) { $this->output->writeln("\n"); break; } if ($this->hasReadline) { readline_add_history($command); readline_write_history($this->history); } if ($this->processIsolation) { $pb = new ProcessBuilder(); $process = $pb ->add($php) ->add($_SERVER['argv'][0]) ->add($command) ->inheritEnvironmentVariables(true) ->getProcess() ; $output = $this->output; $process->run(function($type, $data) use ($output) { $output->writeln($data); }); $ret = $process->getExitCode(); } else { $ret = $this->application->run(new StringInput($command), $this->output); } if (0 !== $ret) { $this->output->writeln(sprintf('<error>The command terminated with an error status (%s)</error>', $ret)); } } } protected function getHeader() { return<<<EOF

Welcome to the <info>{$this->application->getName()}</info> shell (<comment>{$this->application->getVersion()}</comment>).

At the prompt, type <comment>help</comment> for some help,
or <comment>list</comment> to get a list of available commands.

To exit the shell, type <comment>^D</comment>.

EOF
; } private function autocompleter($text) { $info = readline_info(); $text = substr($info['line_buffer'], 0, $info['end']); if ($info['point'] !== $info['end']) { return true; } if (false === strpos($text,' ') || !$text) { return array_keys($this->application->all()); } try { $command = $this->application->find(substr($text, 0, strpos($text,' '))); } catch (\Exception $e) { return true; } $list = array('--help'); foreach ($command->getDefinition()->getOptions() as $option) { $list[] ='--'.$option->getName(); } return $list; } private function readline() { if ($this->hasReadline) { $line = readline($this->prompt); } else { $this->output->write($this->prompt); $line = fgets(STDIN, 1024); $line = (!$line && strlen($line) == 0) ? false : rtrim($line); } return $line; } public function getProcessIsolation() { return $this->processIsolation; } public function setProcessIsolation($processIsolation) { $this->processIsolation = (Boolean) $processIsolation; if ($this->processIsolation && !class_exists('Symfony\\Component\\Process\\Process')) { throw new \RuntimeException('Unable to isolate processes as the Symfony Process Component is not installed.'); } } } } namespace Symfony\Component\Console { use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Input\ArgvInput; use Symfony\Component\Console\Input\ArrayInput; use Symfony\Component\Console\Input\InputDefinition; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Console\Output\ConsoleOutput; use Symfony\Component\Console\Output\ConsoleOutputInterface; use Symfony\Component\Console\Command\Command; use Symfony\Component\Console\Command\HelpCommand; use Symfony\Component\Console\Command\ListCommand; use Symfony\Component\Console\Helper\HelperSet; use Symfony\Component\Console\Helper\FormatterHelper; use Symfony\Component\Console\Helper\DialogHelper; use Symfony\Component\Console\Helper\ProgressHelper; class Application { private $commands; private $wantHelps = false; private $runningCommand; private $name; private $version; private $catchExceptions; private $autoExit; private $definition; private $helperSet; public function __construct($name ='UNKNOWN', $version ='UNKNOWN') { $this->name = $name; $this->version = $version; $this->catchExceptions = true; $this->autoExit = true; $this->commands = array(); $this->helperSet = $this->getDefaultHelperSet(); $this->definition = $this->getDefaultInputDefinition(); foreach ($this->getDefaultCommands() as $command) { $this->add($command); } } public function run(InputInterface $input = null, OutputInterface $output = null) { if (null === $input) { $input = new ArgvInput(); } if (null === $output) { $output = new ConsoleOutput(); } try { $statusCode = $this->doRun($input, $output); } catch (\Exception $e) { if (!$this->catchExceptions) { throw $e; } if ($output instanceof ConsoleOutputInterface) { $this->renderException($e, $output->getErrorOutput()); } else { $this->renderException($e, $output); } $statusCode = $e->getCode(); $statusCode = is_numeric($statusCode) && $statusCode ? $statusCode : 1; } if ($this->autoExit) { if ($statusCode > 255) { $statusCode = 255; } exit($statusCode); } return $statusCode; } public function doRun(InputInterface $input, OutputInterface $output) { $name = $this->getCommandName($input); if (true === $input->hasParameterOption(array('--ansi'))) { $output->setDecorated(true); } elseif (true === $input->hasParameterOption(array('--no-ansi'))) { $output->setDecorated(false); } if (true === $input->hasParameterOption(array('--help','-h'))) { if (!$name) { $name ='help'; $input = new ArrayInput(array('command'=>'help')); } else { $this->wantHelps = true; } } if (true === $input->hasParameterOption(array('--no-interaction','-n'))) { $input->setInteractive(false); } if (function_exists('posix_isatty') && $this->getHelperSet()->has('dialog')) { $inputStream = $this->getHelperSet()->get('dialog')->getInputStream(); if (!posix_isatty($inputStream)) { $input->setInteractive(false); } } if (true === $input->hasParameterOption(array('--quiet','-q'))) { $output->setVerbosity(OutputInterface::VERBOSITY_QUIET); } elseif (true === $input->hasParameterOption(array('--verbose','-v'))) { $output->setVerbosity(OutputInterface::VERBOSITY_VERBOSE); } if (true === $input->hasParameterOption(array('--version','-V'))) { $output->writeln($this->getLongVersion()); return 0; } if (!$name) { $name ='list'; $input = new ArrayInput(array('command'=>'list')); } $command = $this->find($name); $this->runningCommand = $command; $statusCode = $command->run($input, $output); $this->runningCommand = null; return is_numeric($statusCode) ? $statusCode : 0; } public function setHelperSet(HelperSet $helperSet) { $this->helperSet = $helperSet; } public function getHelperSet() { return $this->helperSet; } public function setDefinition(InputDefinition $definition) { $this->definition = $definition; } public function getDefinition() { return $this->definition; } public function getHelp() { $messages = array( $this->getLongVersion(),'','<comment>Usage:</comment>','  [options] command [arguments]','','<comment>Options:</comment>', ); foreach ($this->getDefinition()->getOptions() as $option) { $messages[] = sprintf('  %-29s %s %s','<info>--'.$option->getName().'</info>', $option->getShortcut() ?'<info>-'.$option->getShortcut().'</info>':'  ', $option->getDescription() ); } return implode(PHP_EOL, $messages); } public function setCatchExceptions($boolean) { $this->catchExceptions = (Boolean) $boolean; } public function setAutoExit($boolean) { $this->autoExit = (Boolean) $boolean; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } public function getVersion() { return $this->version; } public function setVersion($version) { $this->version = $version; } public function getLongVersion() { if ('UNKNOWN'!== $this->getName() &&'UNKNOWN'!== $this->getVersion()) { return sprintf('<info>%s</info> version <comment>%s</comment>', $this->getName(), $this->getVersion()); } return'<info>Console Tool</info>'; } public function register($name) { return $this->add(new Command($name)); } public function addCommands(array $commands) { foreach ($commands as $command) { $this->add($command); } } public function add(Command $command) { $command->setApplication($this); if (!$command->isEnabled()) { $command->setApplication(null); return; } $this->commands[$command->getName()] = $command; foreach ($command->getAliases() as $alias) { $this->commands[$alias] = $command; } return $command; } public function get($name) { if (!isset($this->commands[$name])) { throw new \InvalidArgumentException(sprintf('The command "%s" does not exist.', $name)); } $command = $this->commands[$name]; if ($this->wantHelps) { $this->wantHelps = false; $helpCommand = $this->get('help'); $helpCommand->setCommand($command); return $helpCommand; } return $command; } public function has($name) { return isset($this->commands[$name]); } public function getNamespaces() { $namespaces = array(); foreach ($this->commands as $command) { $namespaces[] = $this->extractNamespace($command->getName()); foreach ($command->getAliases() as $alias) { $namespaces[] = $this->extractNamespace($alias); } } return array_values(array_unique(array_filter($namespaces))); } public function findNamespace($namespace) { $allNamespaces = array(); foreach ($this->getNamespaces() as $n) { $allNamespaces[$n] = explode(':', $n); } $found = array(); foreach (explode(':', $namespace) as $i => $part) { $abbrevs = static::getAbbreviations(array_unique(array_values(array_filter(array_map(function ($p) use ($i) { return isset($p[$i]) ? $p[$i] :''; }, $allNamespaces))))); if (!isset($abbrevs[$part])) { $message = sprintf('There are no commands defined in the "%s" namespace.', $namespace); if (1 <= $i) { $part = implode(':', $found).':'.$part; } if ($alternatives = $this->findAlternativeNamespace($part, $abbrevs)) { if (1 == count($alternatives)) { $message .="\n\nDid you mean this?\n    "; } else { $message .="\n\nDid you mean one of these?\n    "; } $message .= implode("\n    ", $alternatives); } throw new \InvalidArgumentException($message); } if (count($abbrevs[$part]) > 1) { throw new \InvalidArgumentException(sprintf('The namespace "%s" is ambiguous (%s).', $namespace, $this->getAbbreviationSuggestions($abbrevs[$part]))); } $found[] = $abbrevs[$part][0]; } return implode(':', $found); } public function find($name) { $namespace =''; $searchName = $name; if (false !== $pos = strrpos($name,':')) { $namespace = $this->findNamespace(substr($name, 0, $pos)); $searchName = $namespace.substr($name, $pos); } $commands = array(); foreach ($this->commands as $command) { $extractedNamespace = $this->extractNamespace($command->getName()); if ($extractedNamespace === $namespace || !empty($namespace) && 0 === strpos($extractedNamespace, $namespace) ) { $commands[] = $command->getName(); } } $abbrevs = static::getAbbreviations(array_unique($commands)); if (isset($abbrevs[$searchName]) && 1 == count($abbrevs[$searchName])) { return $this->get($abbrevs[$searchName][0]); } if (isset($abbrevs[$searchName]) && count($abbrevs[$searchName]) > 1) { $suggestions = $this->getAbbreviationSuggestions($abbrevs[$searchName]); throw new \InvalidArgumentException(sprintf('Command "%s" is ambiguous (%s).', $name, $suggestions)); } $aliases = array(); foreach ($this->commands as $command) { foreach ($command->getAliases() as $alias) { $extractedNamespace = $this->extractNamespace($alias); if ($extractedNamespace === $namespace || !empty($namespace) && 0 === strpos($extractedNamespace, $namespace) ) { $aliases[] = $alias; } } } $aliases = static::getAbbreviations(array_unique($aliases)); if (!isset($aliases[$searchName])) { $message = sprintf('Command "%s" is not defined.', $name); if ($alternatives = $this->findAlternativeCommands($searchName, $abbrevs)) { if (1 == count($alternatives)) { $message .="\n\nDid you mean this?\n    "; } else { $message .="\n\nDid you mean one of these?\n    "; } $message .= implode("\n    ", $alternatives); } throw new \InvalidArgumentException($message); } if (count($aliases[$searchName]) > 1) { throw new \InvalidArgumentException(sprintf('Command "%s" is ambiguous (%s).', $name, $this->getAbbreviationSuggestions($aliases[$searchName]))); } return $this->get($aliases[$searchName][0]); } public function all($namespace = null) { if (null === $namespace) { return $this->commands; } $commands = array(); foreach ($this->commands as $name => $command) { if ($namespace === $this->extractNamespace($name, substr_count($namespace,':') + 1)) { $commands[$name] = $command; } } return $commands; } public static function getAbbreviations($names) { $abbrevs = array(); foreach ($names as $name) { for ($len = strlen($name) - 1; $len > 0; --$len) { $abbrev = substr($name, 0, $len); if (!isset($abbrevs[$abbrev])) { $abbrevs[$abbrev] = array($name); } else { $abbrevs[$abbrev][] = $name; } } } foreach ($names as $name) { $abbrevs[$name] = array($name); } return $abbrevs; } public function asText($namespace = null, $raw = false) { $commands = $namespace ? $this->all($this->findNamespace($namespace)) : $this->commands; $width = 0; foreach ($commands as $command) { $width = strlen($command->getName()) > $width ? strlen($command->getName()) : $width; } $width += 2; if ($raw) { $messages = array(); foreach ($this->sortCommands($commands) as $space => $commands) { foreach ($commands as $name => $command) { $messages[] = sprintf("%-${width}s %s", $name, $command->getDescription()); } } return implode(PHP_EOL, $messages); } $messages = array($this->getHelp(),''); if ($namespace) { $messages[] = sprintf("<comment>Available commands for the \"%s\" namespace:</comment>", $namespace); } else { $messages[] ='<comment>Available commands:</comment>'; } foreach ($this->sortCommands($commands) as $space => $commands) { if (!$namespace &&'_global'!== $space) { $messages[] ='<comment>'.$space.'</comment>'; } foreach ($commands as $name => $command) { $messages[] = sprintf(" <info>%-${width}s</info> %s", $name, $command->getDescription()); } } return implode(PHP_EOL, $messages); } public function asXml($namespace = null, $asDom = false) { $commands = $namespace ? $this->all($this->findNamespace($namespace)) : $this->commands; $dom = new \DOMDocument('1.0','UTF-8'); $dom->formatOutput = true; $dom->appendChild($xml = $dom->createElement('symfony')); $xml->appendChild($commandsXML = $dom->createElement('commands')); if ($namespace) { $commandsXML->setAttribute('namespace', $namespace); } else { $namespacesXML = $dom->createElement('namespaces'); $xml->appendChild($namespacesXML); } foreach ($this->sortCommands($commands) as $space => $commands) { if (!$namespace) { $namespaceArrayXML = $dom->createElement('namespace'); $namespacesXML->appendChild($namespaceArrayXML); $namespaceArrayXML->setAttribute('id', $space); } foreach ($commands as $name => $command) { if ($name !== $command->getName()) { continue; } if (!$namespace) { $commandXML = $dom->createElement('command'); $namespaceArrayXML->appendChild($commandXML); $commandXML->appendChild($dom->createTextNode($name)); } $node = $command->asXml(true)->getElementsByTagName('command')->item(0); $node = $dom->importNode($node, true); $commandsXML->appendChild($node); } } return $asDom ? $dom : $dom->saveXml(); } public function renderException($e, $output) { $strlen = function ($string) { if (!function_exists('mb_strlen')) { return strlen($string); } if (false === $encoding = mb_detect_encoding($string)) { return strlen($string); } return mb_strlen($string, $encoding); }; do { $title = sprintf('  [%s]  ', get_class($e)); $len = $strlen($title); $width = $this->getTerminalWidth() ? $this->getTerminalWidth() - 1 : PHP_INT_MAX; $lines = array(); foreach (preg_split('/\r?\n/', $e->getMessage()) as $line) { foreach (str_split($line, $width - 4) as $line) { $lines[] = sprintf('  %s  ', $line); $len = max($strlen($line) + 4, $len); } } $messages = array(str_repeat(' ', $len), $title.str_repeat(' ', max(0, $len - $strlen($title)))); foreach ($lines as $line) { $messages[] = $line.str_repeat(' ', $len - $strlen($line)); } $messages[] = str_repeat(' ', $len); $output->writeln(""); $output->writeln(""); foreach ($messages as $message) { $output->writeln('<error>'.$message.'</error>'); } $output->writeln(""); $output->writeln(""); if (OutputInterface::VERBOSITY_VERBOSE === $output->getVerbosity()) { $output->writeln('<comment>Exception trace:</comment>'); $trace = $e->getTrace(); array_unshift($trace, array('function'=>'','file'=> $e->getFile() != null ? $e->getFile() :'n/a','line'=> $e->getLine() != null ? $e->getLine() :'n/a','args'=> array(), )); for ($i = 0, $count = count($trace); $i < $count; $i++) { $class = isset($trace[$i]['class']) ? $trace[$i]['class'] :''; $type = isset($trace[$i]['type']) ? $trace[$i]['type'] :''; $function = $trace[$i]['function']; $file = isset($trace[$i]['file']) ? $trace[$i]['file'] :'n/a'; $line = isset($trace[$i]['line']) ? $trace[$i]['line'] :'n/a'; $output->writeln(sprintf(' %s%s%s() at <info>%s:%s</info>', $class, $type, $function, $file, $line)); } $output->writeln(""); $output->writeln(""); } } while ($e = $e->getPrevious()); if (null !== $this->runningCommand) { $output->writeln(sprintf('<info>%s</info>', sprintf($this->runningCommand->getSynopsis(), $this->getName()))); $output->writeln(""); $output->writeln(""); } } protected function getTerminalWidth() { $dimensions = $this->getTerminalDimensions(); return $dimensions[0]; } protected function getTerminalHeight() { $dimensions = $this->getTerminalDimensions(); return $dimensions[1]; } public function getTerminalDimensions() { if (defined('PHP_WINDOWS_VERSION_BUILD')) { if (preg_match('/^(\d+)x\d+ \(\d+x(\d+)\)$/', trim(getenv('ANSICON')), $matches)) { return array((int) $matches[1], (int) $matches[2]); } if (preg_match('/^(\d+)x(\d+)$/', $this->getConsoleMode(), $matches)) { return array((int) $matches[1], (int) $matches[2]); } } if ($sttyString = $this->getSttyColumns()) { if (preg_match('/rows.(\d+);.columns.(\d+);/i', $sttyString, $matches)) { return array((int) $matches[2], (int) $matches[1]); } if (preg_match('/;.(\d+).rows;.(\d+).columns/i', $sttyString, $matches)) { return array((int) $matches[2], (int) $matches[1]); } } return array(null, null); } protected function getCommandName(InputInterface $input) { return $input->getFirstArgument(); } protected function getDefaultInputDefinition() { return new InputDefinition(array( new InputArgument('command', InputArgument::REQUIRED,'The command to execute'), new InputOption('--help','-h', InputOption::VALUE_NONE,'Display this help message.'), new InputOption('--quiet','-q', InputOption::VALUE_NONE,'Do not output any message.'), new InputOption('--verbose','-v', InputOption::VALUE_NONE,'Increase verbosity of messages.'), new InputOption('--version','-V', InputOption::VALUE_NONE,'Display this application version.'), new InputOption('--ansi','', InputOption::VALUE_NONE,'Force ANSI output.'), new InputOption('--no-ansi','', InputOption::VALUE_NONE,'Disable ANSI output.'), new InputOption('--no-interaction','-n', InputOption::VALUE_NONE,'Do not ask any interactive question.'), )); } protected function getDefaultCommands() { return array(new HelpCommand(), new ListCommand()); } protected function getDefaultHelperSet() { return new HelperSet(array( new FormatterHelper(), new DialogHelper(), new ProgressHelper(), )); } private function getSttyColumns() { if (!function_exists('proc_open')) { return; } $descriptorspec = array(1 => array('pipe','w'), 2 => array('pipe','w')); $process = proc_open('stty -a | grep columns', $descriptorspec, $pipes, null, null, array('suppress_errors'=> true)); if (is_resource($process)) { $info = stream_get_contents($pipes[1]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); return $info; } } private function getConsoleMode() { if (!function_exists('proc_open')) { return; } $descriptorspec = array(1 => array('pipe','w'), 2 => array('pipe','w')); $process = proc_open('mode CON', $descriptorspec, $pipes, null, null, array('suppress_errors'=> true)); if (is_resource($process)) { $info = stream_get_contents($pipes[1]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); if (preg_match('/--------+\r?\n.+?(\d+)\r?\n.+?(\d+)\r?\n/', $info, $matches)) { return $matches[2].'x'.$matches[1]; } } } private function sortCommands($commands) { $namespacedCommands = array(); foreach ($commands as $name => $command) { $key = $this->extractNamespace($name, 1); if (!$key) { $key ='_global'; } $namespacedCommands[$key][$name] = $command; } ksort($namespacedCommands); foreach ($namespacedCommands as &$commands) { ksort($commands); } return $namespacedCommands; } private function getAbbreviationSuggestions($abbrevs) { return sprintf('%s, %s%s', $abbrevs[0], $abbrevs[1], count($abbrevs) > 2 ? sprintf(' and %d more', count($abbrevs) - 2) :''); } private function extractNamespace($name, $limit = null) { $parts = explode(':', $name); array_pop($parts); return implode(':', null === $limit ? $parts : array_slice($parts, 0, $limit)); } private function findAlternativeCommands($name, $abbrevs) { $callback = function($item) { return $item->getName(); }; return $this->findAlternatives($name, $this->commands, $abbrevs, $callback); } private function findAlternativeNamespace($name, $abbrevs) { return $this->findAlternatives($name, $this->getNamespaces(), $abbrevs); } private function findAlternatives($name, $collection, $abbrevs, $callback = null) { $alternatives = array(); foreach ($collection as $item) { if (null !== $callback) { $item = call_user_func($callback, $item); } $lev = levenshtein($name, $item); if ($lev <= strlen($name) / 3 || false !== strpos($item, $name)) { $alternatives[$item] = $lev; } } if (!$alternatives) { foreach ($abbrevs as $key => $values) { $lev = levenshtein($name, $key); if ($lev <= strlen($name) / 3 || false !== strpos($key, $name)) { foreach ($values as $value) { $alternatives[$value] = $lev; } } } } asort($alternatives); return array_keys($alternatives); } } } namespace Symfony\Component\EventDispatcher { class Event { private $propagationStopped = false; private $dispatcher; private $name; public function isPropagationStopped() { return $this->propagationStopped; } public function stopPropagation() { $this->propagationStopped = true; } public function setDispatcher(EventDispatcherInterface $dispatcher) { $this->dispatcher = $dispatcher; } public function getDispatcher() { return $this->dispatcher; } public function getName() { return $this->name; } public function setName($name) { $this->name = $name; } } } namespace Symfony\Component\EventDispatcher { interface EventDispatcherInterface { public function dispatch($eventName, Event $event = null); public function addListener($eventName, $listener, $priority = 0); public function addSubscriber(EventSubscriberInterface $subscriber); public function removeListener($eventName, $listener); public function removeSubscriber(EventSubscriberInterface $subscriber); public function getListeners($eventName = null); public function hasListeners($eventName = null); } } namespace Symfony\Component\EventDispatcher { class EventDispatcher implements EventDispatcherInterface { private $listeners = array(); private $sorted = array(); public function dispatch($eventName, Event $event = null) { if (null === $event) { $event = new Event(); } $event->setDispatcher($this); $event->setName($eventName); if (!isset($this->listeners[$eventName])) { return $event; } $this->doDispatch($this->getListeners($eventName), $eventName, $event); return $event; } public function getListeners($eventName = null) { if (null !== $eventName) { if (!isset($this->sorted[$eventName])) { $this->sortListeners($eventName); } return $this->sorted[$eventName]; } foreach (array_keys($this->listeners) as $eventName) { if (!isset($this->sorted[$eventName])) { $this->sortListeners($eventName); } } return $this->sorted; } public function hasListeners($eventName = null) { return (Boolean) count($this->getListeners($eventName)); } public function addListener($eventName, $listener, $priority = 0) { $this->listeners[$eventName][$priority][] = $listener; unset($this->sorted[$eventName]); } public function removeListener($eventName, $listener) { if (!isset($this->listeners[$eventName])) { return; } foreach ($this->listeners[$eventName] as $priority => $listeners) { if (false !== ($key = array_search($listener, $listeners, true))) { unset($this->listeners[$eventName][$priority][$key], $this->sorted[$eventName]); } } } public function addSubscriber(EventSubscriberInterface $subscriber) { foreach ($subscriber->getSubscribedEvents() as $eventName => $params) { if (is_string($params)) { $this->addListener($eventName, array($subscriber, $params)); } elseif (is_string($params[0])) { $this->addListener($eventName, array($subscriber, $params[0]), isset($params[1]) ? $params[1] : 0); } else { foreach ($params as $listener) { $this->addListener($eventName, array($subscriber, $listener[0]), isset($listener[1]) ? $listener[1] : 0); } } } } public function removeSubscriber(EventSubscriberInterface $subscriber) { foreach ($subscriber->getSubscribedEvents() as $eventName => $params) { if (is_array($params) && is_array($params[0])) { foreach ($params as $listener) { $this->removeListener($eventName, array($subscriber, $listener[0])); } } else { $this->removeListener($eventName, array($subscriber, is_string($params) ? $params : $params[0])); } } } protected function doDispatch($listeners, $eventName, Event $event) { foreach ($listeners as $listener) { call_user_func($listener, $event); if ($event->isPropagationStopped()) { break; } } } private function sortListeners($eventName) { $this->sorted[$eventName] = array(); if (isset($this->listeners[$eventName])) { krsort($this->listeners[$eventName]); $this->sorted[$eventName] = call_user_func_array('array_merge', $this->listeners[$eventName]); } } } } namespace Symfony\Component\HttpFoundation { class ParameterBag implements \IteratorAggregate, \Countable { protected $parameters; public function __construct(array $parameters = array()) { $this->parameters = $parameters; } public function all() { return $this->parameters; } public function keys() { return array_keys($this->parameters); } public function replace(array $parameters = array()) { $this->parameters = $parameters; } public function add(array $parameters = array()) { $this->parameters = array_replace($this->parameters, $parameters); } public function get($path, $default = null, $deep = false) { if (!$deep || false === $pos = strpos($path,'[')) { return array_key_exists($path, $this->parameters) ? $this->parameters[$path] : $default; } $root = substr($path, 0, $pos); if (!array_key_exists($root, $this->parameters)) { return $default; } $value = $this->parameters[$root]; $currentKey = null; for ($i = $pos, $c = strlen($path); $i < $c; $i++) { $char = $path[$i]; if ('['=== $char) { if (null !== $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "[" at position %d.', $i)); } $currentKey =''; } elseif (']'=== $char) { if (null === $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "]" at position %d.', $i)); } if (!is_array($value) || !array_key_exists($currentKey, $value)) { return $default; } $value = $value[$currentKey]; $currentKey = null; } else { if (null === $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "%s" at position %d.', $char, $i)); } $currentKey .= $char; } } if (null !== $currentKey) { throw new \InvalidArgumentException(sprintf('Malformed path. Path must end with "]".')); } return $value; } public function set($key, $value) { $this->parameters[$key] = $value; } public function has($key) { return array_key_exists($key, $this->parameters); } public function remove($key) { unset($this->parameters[$key]); } public function getAlpha($key, $default ='', $deep = false) { return preg_replace('/[^[:alpha:]]/','', $this->get($key, $default, $deep)); } public function getAlnum($key, $default ='', $deep = false) { return preg_replace('/[^[:alnum:]]/','', $this->get($key, $default, $deep)); } public function getDigits($key, $default ='', $deep = false) { return str_replace(array('-','+'),'', $this->filter($key, $default, $deep, FILTER_SANITIZE_NUMBER_INT)); } public function getInt($key, $default = 0, $deep = false) { return (int) $this->get($key, $default, $deep); } public function filter($key, $default = null, $deep = false, $filter=FILTER_DEFAULT, $options=array()) { $value = $this->get($key, $default, $deep); if (!is_array($options) && $options) { $options = array('flags'=> $options); } if (is_array($value) && !isset($options['flags'])) { $options['flags'] = FILTER_REQUIRE_ARRAY; } return filter_var($value, $filter, $options); } public function getIterator() { return new \ArrayIterator($this->parameters); } public function count() { return count($this->parameters); } } } namespace Symfony\Component\HttpFoundation { class Cookie { protected $name; protected $value; protected $domain; protected $expire; protected $path; protected $secure; protected $httpOnly; public function __construct($name, $value = null, $expire = 0, $path ='/', $domain = null, $secure = false, $httpOnly = true) { if (preg_match("/[=,; \t\r\n\013\014]/", $name)) { throw new \InvalidArgumentException(sprintf('The cookie name "%s" contains invalid characters.', $name)); } if (empty($name)) { throw new \InvalidArgumentException('The cookie name cannot be empty.'); } if ($expire instanceof \DateTime) { $expire = $expire->format('U'); } elseif (!is_numeric($expire)) { $expire = strtotime($expire); if (false === $expire || -1 === $expire) { throw new \InvalidArgumentException('The cookie expiration time is not valid.'); } } $this->name = $name; $this->value = $value; $this->domain = $domain; $this->expire = $expire; $this->path = empty($path) ?'/': $path; $this->secure = (Boolean) $secure; $this->httpOnly = (Boolean) $httpOnly; } public function __toString() { $str = urlencode($this->getName()).'='; if (''=== (string) $this->getValue()) { $str .='deleted; expires='.gmdate("D, d-M-Y H:i:s T", time() - 31536001); } else { $str .= urlencode($this->getValue()); if ($this->getExpiresTime() !== 0) { $str .='; expires='.gmdate("D, d-M-Y H:i:s T", $this->getExpiresTime()); } } if ('/'!== $this->path) { $str .='; path='.$this->path; } if (null !== $this->getDomain()) { $str .='; domain='.$this->getDomain(); } if (true === $this->isSecure()) { $str .='; secure'; } if (true === $this->isHttpOnly()) { $str .='; httponly'; } return $str; } public function getName() { return $this->name; } public function getValue() { return $this->value; } public function getDomain() { return $this->domain; } public function getExpiresTime() { return $this->expire; } public function getPath() { return $this->path; } public function isSecure() { return $this->secure; } public function isHttpOnly() { return $this->httpOnly; } public function isCleared() { return $this->expire < time(); } } } namespace Symfony\Component\HttpFoundation { use Symfony\Component\HttpFoundation\File\UploadedFile; class FileBag extends ParameterBag { private static $fileKeys = array('error','name','size','tmp_name','type'); public function __construct(array $parameters = array()) { $this->replace($parameters); } public function replace(array $files = array()) { $this->parameters = array(); $this->add($files); } public function set($key, $value) { if (!is_array($value) && !$value instanceof UploadedFile) { throw new \InvalidArgumentException('An uploaded file must be an array or an instance of UploadedFile.'); } parent::set($key, $this->convertFileInformation($value)); } public function add(array $files = array()) { foreach ($files as $key => $file) { $this->set($key, $file); } } protected function convertFileInformation($file) { if ($file instanceof UploadedFile) { return $file; } $file = $this->fixPhpFilesArray($file); if (is_array($file)) { $keys = array_keys($file); sort($keys); if ($keys == self::$fileKeys) { if (UPLOAD_ERR_NO_FILE == $file['error']) { $file = null; } else { $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['size'], $file['error']); } } else { $file = array_map(array($this,'convertFileInformation'), $file); } } return $file; } protected function fixPhpFilesArray($data) { if (!is_array($data)) { return $data; } $keys = array_keys($data); sort($keys); if (self::$fileKeys != $keys || !isset($data['name']) || !is_array($data['name'])) { return $data; } $files = $data; foreach (self::$fileKeys as $k) { unset($files[$k]); } foreach (array_keys($data['name']) as $key) { $files[$key] = $this->fixPhpFilesArray(array('error'=> $data['error'][$key],'name'=> $data['name'][$key],'type'=> $data['type'][$key],'tmp_name'=> $data['tmp_name'][$key],'size'=> $data['size'][$key] )); } return $files; } } } namespace Symfony\Component\HttpFoundation { class HeaderBag implements \IteratorAggregate, \Countable { protected $headers; protected $cacheControl; public function __construct(array $headers = array()) { $this->cacheControl = array(); $this->headers = array(); foreach ($headers as $key => $values) { $this->set($key, $values); } } public function __toString() { if (!$this->headers) { return''; } $max = max(array_map('strlen', array_keys($this->headers))) + 1; $content =''; ksort($this->headers); foreach ($this->headers as $name => $values) { $name = implode('-', array_map('ucfirst', explode('-', $name))); foreach ($values as $value) { $content .= sprintf("%-{$max}s %s\r\n", $name.':', $value); } } return $content; } public function all() { return $this->headers; } public function keys() { return array_keys($this->headers); } public function replace(array $headers = array()) { $this->headers = array(); $this->add($headers); } public function add(array $headers) { foreach ($headers as $key => $values) { $this->set($key, $values); } } public function get($key, $default = null, $first = true) { $key = strtr(strtolower($key),'_','-'); if (!array_key_exists($key, $this->headers)) { if (null === $default) { return $first ? null : array(); } return $first ? $default : array($default); } if ($first) { return count($this->headers[$key]) ? $this->headers[$key][0] : $default; } return $this->headers[$key]; } public function set($key, $values, $replace = true) { $key = strtr(strtolower($key),'_','-'); $values = array_values((array) $values); if (true === $replace || !isset($this->headers[$key])) { $this->headers[$key] = $values; } else { $this->headers[$key] = array_merge($this->headers[$key], $values); } if ('cache-control'=== $key) { $this->cacheControl = $this->parseCacheControl($values[0]); } } public function has($key) { return array_key_exists(strtr(strtolower($key),'_','-'), $this->headers); } public function contains($key, $value) { return in_array($value, $this->get($key, null, false)); } public function remove($key) { $key = strtr(strtolower($key),'_','-'); unset($this->headers[$key]); if ('cache-control'=== $key) { $this->cacheControl = array(); } } public function getDate($key, \DateTime $default = null) { if (null === $value = $this->get($key)) { return $default; } if (false === $date = \DateTime::createFromFormat(DATE_RFC2822, $value)) { throw new \RuntimeException(sprintf('The %s HTTP header is not parseable (%s).', $key, $value)); } return $date; } public function addCacheControlDirective($key, $value = true) { $this->cacheControl[$key] = $value; $this->set('Cache-Control', $this->getCacheControlHeader()); } public function hasCacheControlDirective($key) { return array_key_exists($key, $this->cacheControl); } public function getCacheControlDirective($key) { return array_key_exists($key, $this->cacheControl) ? $this->cacheControl[$key] : null; } public function removeCacheControlDirective($key) { unset($this->cacheControl[$key]); $this->set('Cache-Control', $this->getCacheControlHeader()); } public function getIterator() { return new \ArrayIterator($this->headers); } public function count() { return count($this->headers); } protected function getCacheControlHeader() { $parts = array(); ksort($this->cacheControl); foreach ($this->cacheControl as $key => $value) { if (true === $value) { $parts[] = $key; } else { if (preg_match('#[^a-zA-Z0-9._-]#', $value)) { $value ='"'.$value.'"'; } $parts[] = "$key=$value"; } } return implode(', ', $parts); } protected function parseCacheControl($header) { $cacheControl = array(); preg_match_all('#([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:"([^"]*)"|([^ \t",;]*)))?#', $header, $matches, PREG_SET_ORDER); foreach ($matches as $match) { $cacheControl[strtolower($match[1])] = isset($match[3]) ? $match[3] : (isset($match[2]) ? $match[2] : true); } return $cacheControl; } } } namespace Symfony\Component\HttpFoundation { class Response { public $headers; protected $content; protected $version; protected $statusCode; protected $statusText; protected $charset; public static $statusTexts = array( 100 =>'Continue', 101 =>'Switching Protocols', 102 =>'Processing', 200 =>'OK', 201 =>'Created', 202 =>'Accepted', 203 =>'Non-Authoritative Information', 204 =>'No Content', 205 =>'Reset Content', 206 =>'Partial Content', 207 =>'Multi-Status', 208 =>'Already Reported', 226 =>'IM Used', 300 =>'Multiple Choices', 301 =>'Moved Permanently', 302 =>'Found', 303 =>'See Other', 304 =>'Not Modified', 305 =>'Use Proxy', 306 =>'Reserved', 307 =>'Temporary Redirect', 308 =>'Permanent Redirect', 400 =>'Bad Request', 401 =>'Unauthorized', 402 =>'Payment Required', 403 =>'Forbidden', 404 =>'Not Found', 405 =>'Method Not Allowed', 406 =>'Not Acceptable', 407 =>'Proxy Authentication Required', 408 =>'Request Timeout', 409 =>'Conflict', 410 =>'Gone', 411 =>'Length Required', 412 =>'Precondition Failed', 413 =>'Request Entity Too Large', 414 =>'Request-URI Too Long', 415 =>'Unsupported Media Type', 416 =>'Requested Range Not Satisfiable', 417 =>'Expectation Failed', 418 =>'I\'m a teapot', 422 =>'Unprocessable Entity', 423 =>'Locked', 424 =>'Failed Dependency', 425 =>'Reserved for WebDAV advanced collections expired proposal', 426 =>'Upgrade Required', 428 =>'Precondition Required', 429 =>'Too Many Requests', 431 =>'Request Header Fields Too Large', 500 =>'Internal Server Error', 501 =>'Not Implemented', 502 =>'Bad Gateway', 503 =>'Service Unavailable', 504 =>'Gateway Timeout', 505 =>'HTTP Version Not Supported', 506 =>'Variant Also Negotiates (Experimental)', 507 =>'Insufficient Storage', 508 =>'Loop Detected', 510 =>'Not Extended', 511 =>'Network Authentication Required', ); public function __construct($content ='', $status = 200, $headers = array()) { $this->headers = new ResponseHeaderBag($headers); $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); if (!$this->headers->has('Date')) { $this->setDate(new \DateTime(null, new \DateTimeZone('UTC'))); } } public static function create($content ='', $status = 200, $headers = array()) { return new static($content, $status, $headers); } public function __toString() { return sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText)."\r\n". $this->headers."\r\n". $this->getContent(); } public function __clone() { $this->headers = clone $this->headers; } public function prepare(Request $request) { $headers = $this->headers; if ($this->isInformational() || in_array($this->statusCode, array(204, 304))) { $this->setContent(null); } if (!$headers->has('Content-Type')) { $format = $request->getRequestFormat(); if (null !== $format && $mimeType = $request->getMimeType($format)) { $headers->set('Content-Type', $mimeType); } } $charset = $this->charset ?:'UTF-8'; if (!$headers->has('Content-Type')) { $headers->set('Content-Type','text/html; charset='.$charset); } elseif (0 === strpos($headers->get('Content-Type'),'text/') && false === strpos($headers->get('Content-Type'),'charset')) { $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset); } if ($headers->has('Transfer-Encoding')) { $headers->remove('Content-Length'); } if ($request->isMethod('HEAD')) { $length = $headers->get('Content-Length'); $this->setContent(null); if ($length) { $headers->set('Content-Length', $length); } } if ('HTTP/1.0'!= $request->server->get('SERVER_PROTOCOL')) { $this->setProtocolVersion('1.1'); } if ('1.0'== $this->getProtocolVersion() &&'no-cache'== $this->headers->get('Cache-Control')) { $this->headers->set('pragma','no-cache'); $this->headers->set('expires', -1); } if (false !== stripos($this->headers->get('Content-Disposition'),'attachment') && preg_match('/MSIE (.*?);/i', $request->server->get('HTTP_USER_AGENT'), $match) == 1 && true === $request->isSecure()) { if(intval(preg_replace("/(MSIE )(.*?);/","$2", $match[0])) < 9) { $this->headers->remove('Cache-Control'); } } return $this; } public function sendHeaders() { if (headers_sent()) { return $this; } header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText)); foreach ($this->headers->allPreserveCase() as $name => $values) { foreach ($values as $value) { header($name.': '.$value, false); } } foreach ($this->headers->getCookies() as $cookie) { setcookie($cookie->getName(), $cookie->getValue(), $cookie->getExpiresTime(), $cookie->getPath(), $cookie->getDomain(), $cookie->isSecure(), $cookie->isHttpOnly()); } return $this; } public function sendContent() { echo $this->content; return $this; } public function send() { $this->sendHeaders(); $this->sendContent(); if (function_exists('fastcgi_finish_request')) { fastcgi_finish_request(); } elseif ('cli'!== PHP_SAPI) { $previous = null; $obStatus = ob_get_status(1); while (($level = ob_get_level()) > 0 && $level !== $previous) { $previous = $level; if ($obStatus[$level - 1] && isset($obStatus[$level - 1]['del']) && $obStatus[$level - 1]['del']) { ob_end_flush(); } } flush(); } return $this; } public function setContent($content) { if (null !== $content && !is_string($content) && !is_numeric($content) && !is_callable(array($content,'__toString'))) { throw new \UnexpectedValueException('The Response content must be a string or object implementing __toString(), "'.gettype($content).'" given.'); } $this->content = (string) $content; return $this; } public function getContent() { return $this->content; } public function setProtocolVersion($version) { $this->version = $version; return $this; } public function getProtocolVersion() { return $this->version; } public function setStatusCode($code, $text = null) { $this->statusCode = $code = (int) $code; if ($this->isInvalid()) { throw new \InvalidArgumentException(sprintf('The HTTP status code "%s" is not valid.', $code)); } if (null === $text) { $this->statusText = isset(self::$statusTexts[$code]) ? self::$statusTexts[$code] :''; return $this; } if (false === $text) { $this->statusText =''; return $this; } $this->statusText = $text; return $this; } public function getStatusCode() { return $this->statusCode; } public function setCharset($charset) { $this->charset = $charset; return $this; } public function getCharset() { return $this->charset; } public function isCacheable() { if (!in_array($this->statusCode, array(200, 203, 300, 301, 302, 404, 410))) { return false; } if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) { return false; } return $this->isValidateable() || $this->isFresh(); } public function isFresh() { return $this->getTtl() > 0; } public function isValidateable() { return $this->headers->has('Last-Modified') || $this->headers->has('ETag'); } public function setPrivate() { $this->headers->removeCacheControlDirective('public'); $this->headers->addCacheControlDirective('private'); return $this; } public function setPublic() { $this->headers->addCacheControlDirective('public'); $this->headers->removeCacheControlDirective('private'); return $this; } public function mustRevalidate() { return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->has('proxy-revalidate'); } public function getDate() { return $this->headers->getDate('Date', new \DateTime()); } public function setDate(\DateTime $date) { $date->setTimezone(new \DateTimeZone('UTC')); $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT'); return $this; } public function getAge() { if (null !== $age = $this->headers->get('Age')) { return (int) $age; } return max(time() - $this->getDate()->format('U'), 0); } public function expire() { if ($this->isFresh()) { $this->headers->set('Age', $this->getMaxAge()); } return $this; } public function getExpires() { try { return $this->headers->getDate('Expires'); } catch (\RuntimeException $e) { return \DateTime::createFromFormat(DATE_RFC2822,'Sat, 01 Jan 00 00:00:00 +0000'); } } public function setExpires(\DateTime $date = null) { if (null === $date) { $this->headers->remove('Expires'); } else { $date = clone $date; $date->setTimezone(new \DateTimeZone('UTC')); $this->headers->set('Expires', $date->format('D, d M Y H:i:s').' GMT'); } return $this; } public function getMaxAge() { if ($this->headers->hasCacheControlDirective('s-maxage')) { return (int) $this->headers->getCacheControlDirective('s-maxage'); } if ($this->headers->hasCacheControlDirective('max-age')) { return (int) $this->headers->getCacheControlDirective('max-age'); } if (null !== $this->getExpires()) { return $this->getExpires()->format('U') - $this->getDate()->format('U'); } return null; } public function setMaxAge($value) { $this->headers->addCacheControlDirective('max-age', $value); return $this; } public function setSharedMaxAge($value) { $this->setPublic(); $this->headers->addCacheControlDirective('s-maxage', $value); return $this; } public function getTtl() { if (null !== $maxAge = $this->getMaxAge()) { return $maxAge - $this->getAge(); } return null; } public function setTtl($seconds) { $this->setSharedMaxAge($this->getAge() + $seconds); return $this; } public function setClientTtl($seconds) { $this->setMaxAge($this->getAge() + $seconds); return $this; } public function getLastModified() { return $this->headers->getDate('Last-Modified'); } public function setLastModified(\DateTime $date = null) { if (null === $date) { $this->headers->remove('Last-Modified'); } else { $date = clone $date; $date->setTimezone(new \DateTimeZone('UTC')); $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s').' GMT'); } return $this; } public function getEtag() { return $this->headers->get('ETag'); } public function setEtag($etag = null, $weak = false) { if (null === $etag) { $this->headers->remove('Etag'); } else { if (0 !== strpos($etag,'"')) { $etag ='"'.$etag.'"'; } $this->headers->set('ETag', (true === $weak ?'W/':'').$etag); } return $this; } public function setCache(array $options) { if ($diff = array_diff(array_keys($options), array('etag','last_modified','max_age','s_maxage','private','public'))) { throw new \InvalidArgumentException(sprintf('Response does not support the following options: "%s".', implode('", "', array_values($diff)))); } if (isset($options['etag'])) { $this->setEtag($options['etag']); } if (isset($options['last_modified'])) { $this->setLastModified($options['last_modified']); } if (isset($options['max_age'])) { $this->setMaxAge($options['max_age']); } if (isset($options['s_maxage'])) { $this->setSharedMaxAge($options['s_maxage']); } if (isset($options['public'])) { if ($options['public']) { $this->setPublic(); } else { $this->setPrivate(); } } if (isset($options['private'])) { if ($options['private']) { $this->setPrivate(); } else { $this->setPublic(); } } return $this; } public function setNotModified() { $this->setStatusCode(304); $this->setContent(null); foreach (array('Allow','Content-Encoding','Content-Language','Content-Length','Content-MD5','Content-Type','Last-Modified') as $header) { $this->headers->remove($header); } return $this; } public function hasVary() { return null !== $this->headers->get('Vary'); } public function getVary() { if (!$vary = $this->headers->get('Vary')) { return array(); } return is_array($vary) ? $vary : preg_split('/[\s,]+/', $vary); } public function setVary($headers, $replace = true) { $this->headers->set('Vary', $headers, $replace); return $this; } public function isNotModified(Request $request) { if (!$request->isMethodSafe()) { return false; } $lastModified = $request->headers->get('If-Modified-Since'); $notModified = false; if ($etags = $request->getEtags()) { $notModified = (in_array($this->getEtag(), $etags) || in_array('*', $etags)) && (!$lastModified || $this->headers->get('Last-Modified') == $lastModified); } elseif ($lastModified) { $notModified = $lastModified == $this->headers->get('Last-Modified'); } if ($notModified) { $this->setNotModified(); } return $notModified; } public function isInvalid() { return $this->statusCode < 100 || $this->statusCode >= 600; } public function isInformational() { return $this->statusCode >= 100 && $this->statusCode < 200; } public function isSuccessful() { return $this->statusCode >= 200 && $this->statusCode < 300; } public function isRedirection() { return $this->statusCode >= 300 && $this->statusCode < 400; } public function isClientError() { return $this->statusCode >= 400 && $this->statusCode < 500; } public function isServerError() { return $this->statusCode >= 500 && $this->statusCode < 600; } public function isOk() { return 200 === $this->statusCode; } public function isForbidden() { return 403 === $this->statusCode; } public function isNotFound() { return 404 === $this->statusCode; } public function isRedirect($location = null) { return in_array($this->statusCode, array(201, 301, 302, 303, 307, 308)) && (null === $location ?: $location == $this->headers->get('Location')); } public function isEmpty() { return in_array($this->statusCode, array(201, 204, 304)); } } } namespace Symfony\Component\HttpFoundation { class RedirectResponse extends Response { protected $targetUrl; public function __construct($url, $status = 302, $headers = array()) { if (empty($url)) { throw new \InvalidArgumentException('Cannot redirect to an empty URL.'); } parent::__construct('', $status, $headers); $this->setTargetUrl($url); if (!$this->isRedirect()) { throw new \InvalidArgumentException(sprintf('The HTTP status code is not a redirect ("%s" given).', $status)); } } public static function create($url ='', $status = 302, $headers = array()) { return new static($url, $status, $headers); } public function getTargetUrl() { return $this->targetUrl; } public function setTargetUrl($url) { if (empty($url)) { throw new \InvalidArgumentException('Cannot redirect to an empty URL.'); } $this->targetUrl = $url; $this->setContent( sprintf('<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="refresh" content="1;url=%1$s" />

        <title>Redirecting to %1$s</title>
    </head>
    <body>
        Redirecting to <a href="%1$s">%1$s</a>.
    </body>
</html>', htmlspecialchars($url, ENT_QUOTES,'UTF-8'))); $this->headers->set('Location', $url); return $this; } } } namespace Symfony\Component\HttpFoundation { use Symfony\Component\HttpFoundation\Session\SessionInterface; class Request { const HEADER_CLIENT_IP ='client_ip'; const HEADER_CLIENT_HOST ='client_host'; const HEADER_CLIENT_PROTO ='client_proto'; const HEADER_CLIENT_PORT ='client_port'; protected static $trustProxy = false; protected static $trustedProxies = array(); protected static $trustedHeaders = array( self::HEADER_CLIENT_IP =>'X_FORWARDED_FOR', self::HEADER_CLIENT_HOST =>'X_FORWARDED_HOST', self::HEADER_CLIENT_PROTO =>'X_FORWARDED_PROTO', self::HEADER_CLIENT_PORT =>'X_FORWARDED_PORT', ); protected static $httpMethodParameterOverride = false; public $attributes; public $request; public $query; public $server; public $files; public $cookies; public $headers; protected $content; protected $languages; protected $charsets; protected $acceptableContentTypes; protected $pathInfo; protected $requestUri; protected $baseUrl; protected $basePath; protected $method; protected $format; protected $session; protected $locale; protected $defaultLocale ='en'; protected static $formats; public function __construct(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) { $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content); } public function initialize(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null) { $this->request = new ParameterBag($request); $this->query = new ParameterBag($query); $this->attributes = new ParameterBag($attributes); $this->cookies = new ParameterBag($cookies); $this->files = new FileBag($files); $this->server = new ServerBag($server); $this->headers = new HeaderBag($this->server->getHeaders()); $this->content = $content; $this->languages = null; $this->charsets = null; $this->acceptableContentTypes = null; $this->pathInfo = null; $this->requestUri = null; $this->baseUrl = null; $this->basePath = null; $this->method = null; $this->format = null; } public static function createFromGlobals() { $request = new static($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER); if (0 === strpos($request->headers->get('CONTENT_TYPE'),'application/x-www-form-urlencoded') && in_array(strtoupper($request->server->get('REQUEST_METHOD','GET')), array('PUT','DELETE','PATCH')) ) { parse_str($request->getContent(), $data); $request->request = new ParameterBag($data); } return $request; } public static function create($uri, $method ='GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null) { $server = array_replace(array('SERVER_NAME'=>'localhost','SERVER_PORT'=> 80,'HTTP_HOST'=>'localhost','HTTP_USER_AGENT'=>'Symfony/2.X','HTTP_ACCEPT'=>'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8','HTTP_ACCEPT_LANGUAGE'=>'en-us,en;q=0.5','HTTP_ACCEPT_CHARSET'=>'ISO-8859-1,utf-8;q=0.7,*;q=0.7','REMOTE_ADDR'=>'127.0.0.1','SCRIPT_NAME'=>'','SCRIPT_FILENAME'=>'','SERVER_PROTOCOL'=>'HTTP/1.1','REQUEST_TIME'=> time(), ), $server); $server['PATH_INFO'] =''; $server['REQUEST_METHOD'] = strtoupper($method); $components = parse_url($uri); if (isset($components['host'])) { $server['SERVER_NAME'] = $components['host']; $server['HTTP_HOST'] = $components['host']; } if (isset($components['scheme'])) { if ('https'=== $components['scheme']) { $server['HTTPS'] ='on'; $server['SERVER_PORT'] = 443; } else { unset($server['HTTPS']); $server['SERVER_PORT'] = 80; } } if (isset($components['port'])) { $server['SERVER_PORT'] = $components['port']; $server['HTTP_HOST'] = $server['HTTP_HOST'].':'.$components['port']; } if (isset($components['user'])) { $server['PHP_AUTH_USER'] = $components['user']; } if (isset($components['pass'])) { $server['PHP_AUTH_PW'] = $components['pass']; } if (!isset($components['path'])) { $components['path'] ='/'; } switch (strtoupper($method)) { case'POST': case'PUT': case'DELETE': if (!isset($server['CONTENT_TYPE'])) { $server['CONTENT_TYPE'] ='application/x-www-form-urlencoded'; } case'PATCH': $request = $parameters; $query = array(); break; default: $request = array(); $query = $parameters; break; } if (isset($components['query'])) { parse_str(html_entity_decode($components['query']), $qs); $query = array_replace($qs, $query); } $queryString = http_build_query($query,'','&'); $server['REQUEST_URI'] = $components['path'].(''!== $queryString ?'?'.$queryString :''); $server['QUERY_STRING'] = $queryString; return new static($query, $request, array(), $cookies, $files, $server, $content); } public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null) { $dup = clone $this; if ($query !== null) { $dup->query = new ParameterBag($query); } if ($request !== null) { $dup->request = new ParameterBag($request); } if ($attributes !== null) { $dup->attributes = new ParameterBag($attributes); } if ($cookies !== null) { $dup->cookies = new ParameterBag($cookies); } if ($files !== null) { $dup->files = new FileBag($files); } if ($server !== null) { $dup->server = new ServerBag($server); $dup->headers = new HeaderBag($dup->server->getHeaders()); } $dup->languages = null; $dup->charsets = null; $dup->acceptableContentTypes = null; $dup->pathInfo = null; $dup->requestUri = null; $dup->baseUrl = null; $dup->basePath = null; $dup->method = null; $dup->format = null; return $dup; } public function __clone() { $this->query = clone $this->query; $this->request = clone $this->request; $this->attributes = clone $this->attributes; $this->cookies = clone $this->cookies; $this->files = clone $this->files; $this->server = clone $this->server; $this->headers = clone $this->headers; } public function __toString() { return sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL'))."\r\n". $this->headers."\r\n". $this->getContent(); } public function overrideGlobals() { $_GET = $this->query->all(); $_POST = $this->request->all(); $_SERVER = $this->server->all(); $_COOKIE = $this->cookies->all(); foreach ($this->headers->all() as $key => $value) { $key = strtoupper(str_replace('-','_', $key)); if (in_array($key, array('CONTENT_TYPE','CONTENT_LENGTH'))) { $_SERVER[$key] = implode(', ', $value); } else { $_SERVER['HTTP_'.$key] = implode(', ', $value); } } $request = array('g'=> $_GET,'p'=> $_POST,'c'=> $_COOKIE); $requestOrder = ini_get('request_order') ?: ini_get('variable_order'); $requestOrder = preg_replace('#[^cgp]#','', strtolower($requestOrder)) ?:'gp'; $_REQUEST = array(); foreach (str_split($requestOrder) as $order) { $_REQUEST = array_merge($_REQUEST, $request[$order]); } } public static function trustProxyData() { trigger_error('trustProxyData() is deprecated since version 2.0 and will be removed in 2.3. Use setTrustedProxies() instead.', E_USER_DEPRECATED); self::$trustProxy = true; } public static function setTrustedProxies(array $proxies) { self::$trustedProxies = $proxies; self::$trustProxy = $proxies ? true : false; } public static function getTrustedProxies() { return self::$trustedProxies; } public static function setTrustedHeaderName($key, $value) { if (!array_key_exists($key, self::$trustedHeaders)) { throw new \InvalidArgumentException(sprintf('Unable to set the trusted header name for key "%s".', $key)); } self::$trustedHeaders[$key] = $value; } public static function isProxyTrusted() { return self::$trustProxy; } public static function normalizeQueryString($qs) { if (''== $qs) { return''; } $parts = array(); $order = array(); foreach (explode('&', $qs) as $param) { if (''=== $param ||'='=== $param[0]) { continue; } $keyValuePair = explode('=', $param, 2); $parts[] = isset($keyValuePair[1]) ? rawurlencode(urldecode($keyValuePair[0])).'='.rawurlencode(urldecode($keyValuePair[1])) : rawurlencode(urldecode($keyValuePair[0])); $order[] = urldecode($keyValuePair[0]); } array_multisort($order, SORT_ASC, $parts); return implode('&', $parts); } public static function enableHttpMethodParameterOverride() { self::$httpMethodParameterOverride = true; } public static function getHttpMethodParameterOverride() { return self::$httpMethodParameterOverride; } public function get($key, $default = null, $deep = false) { return $this->query->get($key, $this->attributes->get($key, $this->request->get($key, $default, $deep), $deep), $deep); } public function getSession() { return $this->session; } public function hasPreviousSession() { return $this->hasSession() && $this->cookies->has($this->session->getName()); } public function hasSession() { return null !== $this->session; } public function setSession(SessionInterface $session) { $this->session = $session; } public function getClientIp() { $ip = $this->server->get('REMOTE_ADDR'); if (!self::$trustProxy) { return $ip; } if (!self::$trustedHeaders[self::HEADER_CLIENT_IP] || !$this->headers->has(self::$trustedHeaders[self::HEADER_CLIENT_IP])) { return $ip; } $clientIps = array_map('trim', explode(',', $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_IP]))); $clientIps[] = $ip; $trustedProxies = self::$trustProxy && !self::$trustedProxies ? array($ip) : self::$trustedProxies; $clientIps = array_diff($clientIps, $trustedProxies); return array_pop($clientIps); } public function getScriptName() { return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME','')); } public function getPathInfo() { if (null === $this->pathInfo) { $this->pathInfo = $this->preparePathInfo(); } return $this->pathInfo; } public function getBasePath() { if (null === $this->basePath) { $this->basePath = $this->prepareBasePath(); } return $this->basePath; } public function getBaseUrl() { if (null === $this->baseUrl) { $this->baseUrl = $this->prepareBaseUrl(); } return $this->baseUrl; } public function getScheme() { return $this->isSecure() ?'https':'http'; } public function getPort() { if (self::$trustProxy && self::$trustedHeaders[self::HEADER_CLIENT_PORT] && $port = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PORT])) { return $port; } return $this->server->get('SERVER_PORT'); } public function getUser() { return $this->server->get('PHP_AUTH_USER'); } public function getPassword() { return $this->server->get('PHP_AUTH_PW'); } public function getUserInfo() { $userinfo = $this->getUser(); $pass = $this->getPassword(); if (''!= $pass) { $userinfo .= ":$pass"; } return $userinfo; } public function getHttpHost() { $scheme = $this->getScheme(); $port = $this->getPort(); if (('http'== $scheme && $port == 80) || ('https'== $scheme && $port == 443)) { return $this->getHost(); } return $this->getHost().':'.$port; } public function getRequestUri() { if (null === $this->requestUri) { $this->requestUri = $this->prepareRequestUri(); } return $this->requestUri; } public function getSchemeAndHttpHost() { return $this->getScheme().'://'.$this->getHttpHost(); } public function getUri() { if (null !== $qs = $this->getQueryString()) { $qs ='?'.$qs; } return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs; } public function getUriForPath($path) { return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path; } public function getQueryString() { $qs = static::normalizeQueryString($this->server->get('QUERY_STRING')); return''=== $qs ? null : $qs; } public function isSecure() { if (self::$trustProxy && self::$trustedHeaders[self::HEADER_CLIENT_PROTO] && $proto = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PROTO])) { return in_array(strtolower($proto), array('https','on','1')); } return'on'== strtolower($this->server->get('HTTPS')) || 1 == $this->server->get('HTTPS'); } public function getHost() { if (self::$trustProxy && self::$trustedHeaders[self::HEADER_CLIENT_HOST] && $host = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_HOST])) { $elements = explode(',', $host); $host = $elements[count($elements) - 1]; } elseif (!$host = $this->headers->get('HOST')) { if (!$host = $this->server->get('SERVER_NAME')) { $host = $this->server->get('SERVER_ADDR',''); } } $host = strtolower(preg_replace('/:\d+$/','', trim($host))); if ($host && !preg_match('/^\[?(?:[a-zA-Z0-9-:\]_]+\.?)+$/', $host)) { throw new \UnexpectedValueException('Invalid Host'); } return $host; } public function setMethod($method) { $this->method = null; $this->server->set('REQUEST_METHOD', $method); } public function getMethod() { if (null === $this->method) { $this->method = strtoupper($this->server->get('REQUEST_METHOD','GET')); if ('POST'=== $this->method) { if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) { $this->method = strtoupper($method); } elseif (self::$httpMethodParameterOverride) { $this->method = strtoupper($this->request->get('_method', $this->query->get('_method','POST'))); } } } return $this->method; } public function getRealMethod() { return strtoupper($this->server->get('REQUEST_METHOD','GET')); } public function getMimeType($format) { if (null === static::$formats) { static::initializeFormats(); } return isset(static::$formats[$format]) ? static::$formats[$format][0] : null; } public function getFormat($mimeType) { if (false !== $pos = strpos($mimeType,';')) { $mimeType = substr($mimeType, 0, $pos); } if (null === static::$formats) { static::initializeFormats(); } foreach (static::$formats as $format => $mimeTypes) { if (in_array($mimeType, (array) $mimeTypes)) { return $format; } } return null; } public function setFormat($format, $mimeTypes) { if (null === static::$formats) { static::initializeFormats(); } static::$formats[$format] = is_array($mimeTypes) ? $mimeTypes : array($mimeTypes); } public function getRequestFormat($default ='html') { if (null === $this->format) { $this->format = $this->get('_format', $default); } return $this->format; } public function setRequestFormat($format) { $this->format = $format; } public function getContentType() { return $this->getFormat($this->headers->get('CONTENT_TYPE')); } public function setDefaultLocale($locale) { $this->defaultLocale = $locale; if (null === $this->locale) { $this->setPhpDefaultLocale($locale); } } public function setLocale($locale) { $this->setPhpDefaultLocale($this->locale = $locale); } public function getLocale() { return null === $this->locale ? $this->defaultLocale : $this->locale; } public function isMethod($method) { return $this->getMethod() === strtoupper($method); } public function isMethodSafe() { return in_array($this->getMethod(), array('GET','HEAD')); } public function getContent($asResource = false) { if (false === $this->content || (true === $asResource && null !== $this->content)) { throw new \LogicException('getContent() can only be called once when using the resource return type.'); } if (true === $asResource) { $this->content = false; return fopen('php://input','rb'); } if (null === $this->content) { $this->content = file_get_contents('php://input'); } return $this->content; } public function getETags() { return preg_split('/\s*,\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY); } public function isNoCache() { return $this->headers->hasCacheControlDirective('no-cache') ||'no-cache'== $this->headers->get('Pragma'); } public function getPreferredLanguage(array $locales = null) { $preferredLanguages = $this->getLanguages(); if (empty($locales)) { return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null; } if (!$preferredLanguages) { return $locales[0]; } $preferredLanguages = array_values(array_intersect($preferredLanguages, $locales)); return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0]; } public function getLanguages() { if (null !== $this->languages) { return $this->languages; } $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all(); $this->languages = array(); foreach (array_keys($languages) as $lang) { if (strstr($lang,'-')) { $codes = explode('-', $lang); if ($codes[0] =='i') { if (count($codes) > 1) { $lang = $codes[1]; } } else { for ($i = 0, $max = count($codes); $i < $max; $i++) { if ($i == 0) { $lang = strtolower($codes[0]); } else { $lang .='_'.strtoupper($codes[$i]); } } } } $this->languages[] = $lang; } return $this->languages; } public function getCharsets() { if (null !== $this->charsets) { return $this->charsets; } return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all()); } public function getAcceptableContentTypes() { if (null !== $this->acceptableContentTypes) { return $this->acceptableContentTypes; } return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all()); } public function isXmlHttpRequest() { return'XMLHttpRequest'== $this->headers->get('X-Requested-With'); } public function splitHttpAcceptHeader($header) { trigger_error('splitHttpAcceptHeader() is deprecated since version 2.2 and will be removed in 2.3.', E_USER_DEPRECATED); $headers = array(); foreach (AcceptHeader::fromString($header)->all() as $item) { $key = $item->getValue(); foreach ($item->getAttributes() as $name => $value) { $key .= sprintf(';%s=%s', $name, $value); } $headers[$key] = $item->getQuality(); } return $headers; } protected function prepareRequestUri() { $requestUri =''; if ($this->headers->has('X_ORIGINAL_URL') && false !== stripos(PHP_OS,'WIN')) { $requestUri = $this->headers->get('X_ORIGINAL_URL'); $this->headers->remove('X_ORIGINAL_URL'); } elseif ($this->headers->has('X_REWRITE_URL') && false !== stripos(PHP_OS,'WIN')) { $requestUri = $this->headers->get('X_REWRITE_URL'); $this->headers->remove('X_REWRITE_URL'); } elseif ($this->server->get('IIS_WasUrlRewritten') =='1'&& $this->server->get('UNENCODED_URL') !='') { $requestUri = $this->server->get('UNENCODED_URL'); $this->server->remove('UNENCODED_URL'); $this->server->remove('IIS_WasUrlRewritten'); } elseif ($this->server->has('REQUEST_URI')) { $requestUri = $this->server->get('REQUEST_URI'); $schemeAndHttpHost = $this->getSchemeAndHttpHost(); if (strpos($requestUri, $schemeAndHttpHost) === 0) { $requestUri = substr($requestUri, strlen($schemeAndHttpHost)); } } elseif ($this->server->has('ORIG_PATH_INFO')) { $requestUri = $this->server->get('ORIG_PATH_INFO'); if (''!= $this->server->get('QUERY_STRING')) { $requestUri .='?'.$this->server->get('QUERY_STRING'); } $this->server->remove('ORIG_PATH_INFO'); } $this->server->set('REQUEST_URI', $requestUri); return $requestUri; } protected function prepareBaseUrl() { $filename = basename($this->server->get('SCRIPT_FILENAME')); if (basename($this->server->get('SCRIPT_NAME')) === $filename) { $baseUrl = $this->server->get('SCRIPT_NAME'); } elseif (basename($this->server->get('PHP_SELF')) === $filename) { $baseUrl = $this->server->get('PHP_SELF'); } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) { $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); } else { $path = $this->server->get('PHP_SELF',''); $file = $this->server->get('SCRIPT_FILENAME',''); $segs = explode('/', trim($file,'/')); $segs = array_reverse($segs); $index = 0; $last = count($segs); $baseUrl =''; do { $seg = $segs[$index]; $baseUrl ='/'.$seg.$baseUrl; ++$index; } while (($last > $index) && (false !== ($pos = strpos($path, $baseUrl))) && (0 != $pos)); } $requestUri = $this->getRequestUri(); if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) { return $prefix; } if ($baseUrl && false !== $prefix = $this->getUrlencodedPrefix($requestUri, dirname($baseUrl))) { return rtrim($prefix,'/'); } $truncatedRequestUri = $requestUri; if (($pos = strpos($requestUri,'?')) !== false) { $truncatedRequestUri = substr($requestUri, 0, $pos); } $basename = basename($baseUrl); if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) { return''; } if ((strlen($requestUri) >= strlen($baseUrl)) && ((false !== ($pos = strpos($requestUri, $baseUrl))) && ($pos !== 0))) { $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl)); } return rtrim($baseUrl,'/'); } protected function prepareBasePath() { $filename = basename($this->server->get('SCRIPT_FILENAME')); $baseUrl = $this->getBaseUrl(); if (empty($baseUrl)) { return''; } if (basename($baseUrl) === $filename) { $basePath = dirname($baseUrl); } else { $basePath = $baseUrl; } if ('\\'=== DIRECTORY_SEPARATOR) { $basePath = str_replace('\\','/', $basePath); } return rtrim($basePath,'/'); } protected function preparePathInfo() { $baseUrl = $this->getBaseUrl(); if (null === ($requestUri = $this->getRequestUri())) { return'/'; } $pathInfo ='/'; if ($pos = strpos($requestUri,'?')) { $requestUri = substr($requestUri, 0, $pos); } if ((null !== $baseUrl) && (false === ($pathInfo = substr($requestUri, strlen($baseUrl))))) { return'/'; } elseif (null === $baseUrl) { return $requestUri; } return (string) $pathInfo; } protected static function initializeFormats() { static::$formats = array('html'=> array('text/html','application/xhtml+xml'),'txt'=> array('text/plain'),'js'=> array('application/javascript','application/x-javascript','text/javascript'),'css'=> array('text/css'),'json'=> array('application/json','application/x-json'),'xml'=> array('text/xml','application/xml','application/x-xml'),'rdf'=> array('application/rdf+xml'),'atom'=> array('application/atom+xml'),'rss'=> array('application/rss+xml'), ); } private function setPhpDefaultLocale($locale) { try { if (class_exists('Locale', false)) { \Locale::setDefault($locale); } } catch (\Exception $e) { } } private function getUrlencodedPrefix($string, $prefix) { if (0 !== strpos(rawurldecode($string), $prefix)) { return false; } $len = strlen($prefix); if (preg_match("#^(%[[:xdigit:]]{2}|.){{$len}}#", $string, $match)) { return $match[0]; } return false; } } } namespace Symfony\Component\HttpFoundation { class ResponseHeaderBag extends HeaderBag { const COOKIES_FLAT ='flat'; const COOKIES_ARRAY ='array'; const DISPOSITION_ATTACHMENT ='attachment'; const DISPOSITION_INLINE ='inline'; protected $computedCacheControl = array(); protected $cookies = array(); protected $headerNames = array(); public function __construct(array $headers = array()) { parent::__construct($headers); if (!isset($this->headers['cache-control'])) { $this->set('Cache-Control',''); } } public function __toString() { $cookies =''; foreach ($this->getCookies() as $cookie) { $cookies .='Set-Cookie: '.$cookie."\r\n"; } ksort($this->headerNames); return parent::__toString().$cookies; } public function allPreserveCase() { return array_combine($this->headerNames, $this->headers); } public function replace(array $headers = array()) { $this->headerNames = array(); parent::replace($headers); if (!isset($this->headers['cache-control'])) { $this->set('Cache-Control',''); } } public function set($key, $values, $replace = true) { parent::set($key, $values, $replace); $uniqueKey = strtr(strtolower($key),'_','-'); $this->headerNames[$uniqueKey] = $key; if (in_array($uniqueKey, array('cache-control','etag','last-modified','expires'))) { $computed = $this->computeCacheControlValue(); $this->headers['cache-control'] = array($computed); $this->headerNames['cache-control'] ='Cache-Control'; $this->computedCacheControl = $this->parseCacheControl($computed); } } public function remove($key) { parent::remove($key); $uniqueKey = strtr(strtolower($key),'_','-'); unset($this->headerNames[$uniqueKey]); if ('cache-control'=== $uniqueKey) { $this->computedCacheControl = array(); } } public function hasCacheControlDirective($key) { return array_key_exists($key, $this->computedCacheControl); } public function getCacheControlDirective($key) { return array_key_exists($key, $this->computedCacheControl) ? $this->computedCacheControl[$key] : null; } public function setCookie(Cookie $cookie) { $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie; } public function removeCookie($name, $path ='/', $domain = null) { if (null === $path) { $path ='/'; } unset($this->cookies[$domain][$path][$name]); if (empty($this->cookies[$domain][$path])) { unset($this->cookies[$domain][$path]); if (empty($this->cookies[$domain])) { unset($this->cookies[$domain]); } } } public function getCookies($format = self::COOKIES_FLAT) { if (!in_array($format, array(self::COOKIES_FLAT, self::COOKIES_ARRAY))) { throw new \InvalidArgumentException(sprintf('Format "%s" invalid (%s).', $format, implode(', ', array(self::COOKIES_FLAT, self::COOKIES_ARRAY)))); } if (self::COOKIES_ARRAY === $format) { return $this->cookies; } $flattenedCookies = array(); foreach ($this->cookies as $path) { foreach ($path as $cookies) { foreach ($cookies as $cookie) { $flattenedCookies[] = $cookie; } } } return $flattenedCookies; } public function clearCookie($name, $path ='/', $domain = null) { $this->setCookie(new Cookie($name, null, 1, $path, $domain)); } public function makeDisposition($disposition, $filename, $filenameFallback ='') { if (!in_array($disposition, array(self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE))) { throw new \InvalidArgumentException(sprintf('The disposition must be either "%s" or "%s".', self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE)); } if (''== $filenameFallback) { $filenameFallback = $filename; } if (!preg_match('/^[\x20-\x7e]*$/', $filenameFallback)) { throw new \InvalidArgumentException('The filename fallback must only contain ASCII characters.'); } if (false !== strpos($filenameFallback,'%')) { throw new \InvalidArgumentException('The filename fallback cannot contain the "%" character.'); } if (false !== strpos($filename,'/') || false !== strpos($filename,'\\') || false !== strpos($filenameFallback,'/') || false !== strpos($filenameFallback,'\\')) { throw new \InvalidArgumentException('The filename and the fallback cannot contain the "/" and "\\" characters.'); } $output = sprintf('%s; filename="%s"', $disposition, str_replace('"','\\"', $filenameFallback)); if ($filename !== $filenameFallback) { $output .= sprintf("; filename*=utf-8''%s", rawurlencode($filename)); } return $output; } protected function computeCacheControlValue() { if (!$this->cacheControl && !$this->has('ETag') && !$this->has('Last-Modified') && !$this->has('Expires')) { return'no-cache'; } if (!$this->cacheControl) { return'private, must-revalidate'; } $header = $this->getCacheControlHeader(); if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) { return $header; } if (!isset($this->cacheControl['s-maxage'])) { return $header.', private'; } return $header; } } } namespace Symfony\Component\HttpFoundation { class ServerBag extends ParameterBag { public function getHeaders() { $headers = array(); foreach ($this->parameters as $key => $value) { if (0 === strpos($key,'HTTP_')) { $headers[substr($key, 5)] = $value; } elseif (in_array($key, array('CONTENT_LENGTH','CONTENT_MD5','CONTENT_TYPE'))) { $headers[$key] = $value; } } if (isset($this->parameters['PHP_AUTH_USER'])) { $headers['PHP_AUTH_USER'] = $this->parameters['PHP_AUTH_USER']; $headers['PHP_AUTH_PW'] = isset($this->parameters['PHP_AUTH_PW']) ? $this->parameters['PHP_AUTH_PW'] :''; } else { $authorizationHeader = null; if (isset($this->parameters['HTTP_AUTHORIZATION'])) { $authorizationHeader = $this->parameters['HTTP_AUTHORIZATION']; } elseif (isset($this->parameters['REDIRECT_HTTP_AUTHORIZATION'])) { $authorizationHeader = $this->parameters['REDIRECT_HTTP_AUTHORIZATION']; } if ((null !== $authorizationHeader) && (0 === stripos($authorizationHeader,'basic'))) { $exploded = explode(':', base64_decode(substr($authorizationHeader, 6))); if (count($exploded) == 2) { list($headers['PHP_AUTH_USER'], $headers['PHP_AUTH_PW']) = $exploded; } } } if (isset($headers['PHP_AUTH_USER'])) { $headers['AUTHORIZATION'] ='Basic '.base64_encode($headers['PHP_AUTH_USER'].':'.$headers['PHP_AUTH_PW']); } return $headers; } } } namespace Symfony\Component\HttpKernel\Controller { use Symfony\Component\HttpFoundation\Request; interface ControllerResolverInterface { public function getController(Request $request); public function getArguments(Request $request, $controller); } } namespace Symfony\Component\HttpKernel\Controller { use Psr\Log\LoggerInterface; use Symfony\Component\HttpFoundation\Request; class ControllerResolver implements ControllerResolverInterface { private $logger; public function __construct(LoggerInterface $logger = null) { $this->logger = $logger; } public function getController(Request $request) { if (!$controller = $request->attributes->get('_controller')) { if (null !== $this->logger) { $this->logger->warning('Unable to look for the controller as the "_controller" parameter is missing'); } return false; } if (is_array($controller) || (is_object($controller) && method_exists($controller,'__invoke'))) { return $controller; } if (false === strpos($controller,':')) { if (method_exists($controller,'__invoke')) { return new $controller; } elseif (function_exists($controller)) { return $controller; } } list($controller, $method) = $this->createController($controller); if (!method_exists($controller, $method)) { throw new \InvalidArgumentException(sprintf('Method "%s::%s" does not exist.', get_class($controller), $method)); } return array($controller, $method); } public function getArguments(Request $request, $controller) { if (is_array($controller)) { $r = new \ReflectionMethod($controller[0], $controller[1]); } elseif (is_object($controller) && !$controller instanceof \Closure) { $r = new \ReflectionObject($controller); $r = $r->getMethod('__invoke'); } else { $r = new \ReflectionFunction($controller); } return $this->doGetArguments($request, $controller, $r->getParameters()); } protected function doGetArguments(Request $request, $controller, array $parameters) { $attributes = $request->attributes->all(); $arguments = array(); foreach ($parameters as $param) { if (array_key_exists($param->name, $attributes)) { $arguments[] = $attributes[$param->name]; } elseif ($param->getClass() && $param->getClass()->isInstance($request)) { $arguments[] = $request; } elseif ($param->isDefaultValueAvailable()) { $arguments[] = $param->getDefaultValue(); } else { if (is_array($controller)) { $repr = sprintf('%s::%s()', get_class($controller[0]), $controller[1]); } elseif (is_object($controller)) { $repr = get_class($controller); } else { $repr = $controller; } throw new \RuntimeException(sprintf('Controller "%s" requires that you provide a value for the "$%s" argument (because there is no default value or because there is a non optional argument after this one).', $repr, $param->name)); } } return $arguments; } protected function createController($controller) { if (false === strpos($controller,'::')) { throw new \InvalidArgumentException(sprintf('Unable to find controller "%s".', $controller)); } list($class, $method) = explode('::', $controller, 2); if (!class_exists($class)) { throw new \InvalidArgumentException(sprintf('Class "%s" does not exist.', $class)); } return array(new $class(), $method); } } } namespace Symfony\Component\HttpKernel\Debug { use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpKernel\Exception\FlattenException; if (!defined('ENT_SUBSTITUTE')) { define('ENT_SUBSTITUTE', 8); } class ExceptionHandler { private $debug; private $charset; public function __construct($debug = true, $charset ='UTF-8') { $this->debug = $debug; $this->charset = $charset; } public static function register($debug = true) { $handler = new static($debug); set_exception_handler(array($handler,'handle')); return $handler; } public function handle(\Exception $exception) { $this->createResponse($exception)->send(); } public function createResponse($exception) { if (!$exception instanceof FlattenException) { $exception = FlattenException::create($exception); } return new Response($this->decorate($this->getContent($exception), $this->getStylesheet($exception)), $exception->getStatusCode(), $exception->getHeaders()); } public function getContent(FlattenException $exception) { switch ($exception->getStatusCode()) { case 404: $title ='Sorry, the page you are looking for could not be found.'; break; default: $title ='Whoops, looks like something went wrong.'; } $content =''; if ($this->debug) { try { $count = count($exception->getAllPrevious()); $total = $count + 1; foreach ($exception->toArray() as $position => $e) { $ind = $count - $position + 1; $class = $this->abbrClass($e['class']); $message = nl2br($e['message']); $content .= sprintf(<<<EOF
                        <div class="block_exception clear_fix">
                            <h2><span>%d/%d</span> %s: %s</h2>
                        </div>
                        <div class="block">
                            <ol class="traces list_exception">

EOF
, $ind, $total, $class, $message); foreach ($e['trace'] as $trace) { $content .='       <li>'; if ($trace['function']) { $content .= sprintf('at %s%s%s(%s)', $this->abbrClass($trace['class']), $trace['type'], $trace['function'], $this->formatArgs($trace['args'])); } if (isset($trace['file']) && isset($trace['line'])) { if ($linkFormat = ini_get('xdebug.file_link_format')) { $link = str_replace(array('%f','%l'), array($trace['file'], $trace['line']), $linkFormat); $content .= sprintf(' in <a href="%s" title="Go to source">%s line %s</a>', $link, $trace['file'], $trace['line']); } else { $content .= sprintf(' in %s line %s', $trace['file'], $trace['line']); } } $content .="</li>\n"; } $content .="    </ol>\n</div>\n"; } } catch (\Exception $e) { if ($this->debug) { $title = sprintf('Exception thrown when handling an exception (%s: %s)', get_class($exception), $exception->getMessage()); } else { $title ='Whoops, looks like something went wrong.'; } } } return<<<EOF
            <div id="sf-resetcontent" class="sf-reset">
                <h1>$title</h1>
                $content
            </div>
EOF
; } public function getStylesheet(FlattenException $exception) { return<<<EOF
            .sf-reset { font: 11px Verdana, Arial, sans-serif; color: #333 }
            .sf-reset .clear { clear:both; height:0; font-size:0; line-height:0; }
            .sf-reset .clear_fix:after { display:block; height:0; clear:both; visibility:hidden; }
            .sf-reset .clear_fix { display:inline-block; }
            .sf-reset * html .clear_fix { height:1%; }
            .sf-reset .clear_fix { display:block; }
            .sf-reset, .sf-reset .block { margin: auto }
            .sf-reset abbr { border-bottom: 1px dotted #000; cursor: help; }
            .sf-reset p { font-size:14px; line-height:20px; color:#868686; padding-bottom:20px }
            .sf-reset strong { font-weight:bold; }
            .sf-reset a { color:#6c6159; }
            .sf-reset a img { border:none; }
            .sf-reset a:hover { text-decoration:underline; }
            .sf-reset em { font-style:italic; }
            .sf-reset h1, .sf-reset h2 { font: 20px Georgia, "Times New Roman", Times, serif }
            .sf-reset h2 span { background-color: #fff; color: #333; padding: 6px; float: left; margin-right: 10px; }
            .sf-reset .traces li { font-size:12px; padding: 2px 4px; list-style-type:decimal; margin-left:20px; }
            .sf-reset .block { background-color:#FFFFFF; padding:10px 28px; margin-bottom:20px;
                -webkit-border-bottom-right-radius: 16px;
                -webkit-border-bottom-left-radius: 16px;
                -moz-border-radius-bottomright: 16px;
                -moz-border-radius-bottomleft: 16px;
                border-bottom-right-radius: 16px;
                border-bottom-left-radius: 16px;
                border-bottom:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
            }
            .sf-reset .block_exception { background-color:#ddd; color: #333; padding:20px;
                -webkit-border-top-left-radius: 16px;
                -webkit-border-top-right-radius: 16px;
                -moz-border-radius-topleft: 16px;
                -moz-border-radius-topright: 16px;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-top:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                overflow: hidden;
                word-wrap: break-word;
            }
            .sf-reset li a { background:none; color:#868686; text-decoration:none; }
            .sf-reset li a:hover { background:none; color:#313131; text-decoration:underline; }
            .sf-reset ol { padding: 10px 0; }
            .sf-reset h1 { background-color:#FFFFFF; padding: 15px 28px; margin-bottom: 20px;
                -webkit-border-radius: 10px;
                -moz-border-radius: 10px;
                border-radius: 10px;
                border: 1px solid #ccc;
            }
EOF
; } private function decorate($content, $css) { return<<<EOF
<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta name="robots" content="noindex,nofollow" />
        <style>
            /* Copyright (c) 2010, Yahoo! Inc. All rights reserved. Code licensed under the BSD License: http://developer.yahoo.com/yui/license.html */
            html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}

            html { background: #eee; padding: 10px }
            img { border: 0; }
            #sf-resetcontent { width:970px; margin:0 auto; }
            $css
        </style>
    </head>
    <body>
        $content
    </body>
</html>
EOF
; } private function abbrClass($class) { $parts = explode('\\', $class); return sprintf("<abbr title=\"%s\">%s</abbr>", $class, array_pop($parts)); } private function formatArgs(array $args) { $result = array(); foreach ($args as $key => $item) { if ('object'=== $item[0]) { $formattedValue = sprintf("<em>object</em>(%s)", $this->abbrClass($item[1])); } elseif ('array'=== $item[0]) { $formattedValue = sprintf("<em>array</em>(%s)", is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]); } elseif ('string'=== $item[0]) { $formattedValue = sprintf("'%s'", htmlspecialchars($item[1], ENT_QUOTES | ENT_SUBSTITUTE, $this->charset)); } elseif ('null'=== $item[0]) { $formattedValue ='<em>null</em>'; } elseif ('boolean'=== $item[0]) { $formattedValue ='<em>'.strtolower(var_export($item[1], true)).'</em>'; } elseif ('resource'=== $item[0]) { $formattedValue ='<em>resource</em>'; } else { $formattedValue = str_replace("\n",'', var_export(htmlspecialchars((string) $item[1], ENT_QUOTES | ENT_SUBSTITUTE, $this->charset), true)); } $result[] = is_int($key) ? $formattedValue : sprintf("'%s' => %s", $key, $formattedValue); } return implode(', ', $result); } } } namespace Symfony\Component\EventDispatcher { interface EventSubscriberInterface { public static function getSubscribedEvents(); } } namespace Symfony\Component\HttpKernel\EventListener { use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\Routing\RequestContextAwareInterface; use Symfony\Component\EventDispatcher\EventSubscriberInterface; class LocaleListener implements EventSubscriberInterface { private $router; private $defaultLocale; private $locales = array(); public function __construct($defaultLocale ='en', RequestContextAwareInterface $router = null) { $this->defaultLocale = $defaultLocale; $this->router = $router; } public function onKernelResponse(FilterResponseEvent $event) { array_shift($this->locales); $locale = isset($this->locales[0]) ? $this->locales[0] : $this->defaultLocale; $request = $event->getRequest(); $this->setLocale($request, $locale); } public function onKernelRequest(GetResponseEvent $event) { $request = $event->getRequest(); $request->setDefaultLocale($this->defaultLocale); $this->setLocale($request, $request->attributes->get('_locale', $this->defaultLocale)); array_unshift($this->locales, $request->getLocale()); } public static function getSubscribedEvents() { return array( KernelEvents::REQUEST => array(array('onKernelRequest', 16)), KernelEvents::RESPONSE =>'onKernelResponse', ); } private function setLocale(Request $request, $locale) { $request->setLocale($locale); if (null !== $this->router) { $this->router->getContext()->setParameter('_locale', $request->getLocale()); } } } } namespace Symfony\Component\HttpKernel\EventListener { use Psr\Log\LoggerInterface; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; use Symfony\Component\Routing\Exception\MethodNotAllowedException; use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\Matcher\UrlMatcherInterface; use Symfony\Component\Routing\Matcher\RequestMatcherInterface; use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\RequestContextAwareInterface; use Symfony\Component\EventDispatcher\EventSubscriberInterface; class RouterListener implements EventSubscriberInterface { private $matcher; private $context; private $logger; public function __construct($matcher, RequestContext $context = null, LoggerInterface $logger = null) { if (!$matcher instanceof UrlMatcherInterface && !$matcher instanceof RequestMatcherInterface) { throw new \InvalidArgumentException('Matcher must either implement UrlMatcherInterface or RequestMatcherInterface.'); } if (null === $context && !$matcher instanceof RequestContextAwareInterface) { throw new \InvalidArgumentException('You must either pass a RequestContext or the matcher must implement RequestContextAwareInterface.'); } $this->matcher = $matcher; $this->context = $context ?: $matcher->getContext(); $this->logger = $logger; } public function onKernelRequest(GetResponseEvent $event) { $request = $event->getRequest(); $this->context->fromRequest($request); if ($request->attributes->has('_controller')) { return; } try { if ($this->matcher instanceof RequestMatcherInterface) { $parameters = $this->matcher->matchRequest($request); } else { $parameters = $this->matcher->match($request->getPathInfo()); } if (null !== $this->logger) { $this->logger->info(sprintf('Matched route "%s" (parameters: %s)', $parameters['_route'], $this->parametersToString($parameters))); } $request->attributes->add($parameters); unset($parameters['_route']); unset($parameters['_controller']); $request->attributes->set('_route_params', $parameters); } catch (ResourceNotFoundException $e) { $message = sprintf('No route found for "%s %s"', $request->getMethod(), $request->getPathInfo()); throw new NotFoundHttpException($message, $e); } catch (MethodNotAllowedException $e) { $message = sprintf('No route found for "%s %s": Method Not Allowed (Allow: %s)', $request->getMethod(), $request->getPathInfo(), strtoupper(implode(', ', $e->getAllowedMethods()))); throw new MethodNotAllowedHttpException($e->getAllowedMethods(), $message, $e); } } private function parametersToString(array $parameters) { $pieces = array(); foreach ($parameters as $key => $val) { $pieces[] = sprintf('"%s": "%s"', $key, (is_string($val) ? $val : json_encode($val))); } return implode(', ', $pieces); } public static function getSubscribedEvents() { return array( KernelEvents::REQUEST => array(array('onKernelRequest', 32)), ); } } } namespace Symfony\Component\HttpKernel\EventListener { use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\EventDispatcher\EventSubscriberInterface; class ResponseListener implements EventSubscriberInterface { private $charset; public function __construct($charset) { $this->charset = $charset; } public function onKernelResponse(FilterResponseEvent $event) { if (HttpKernelInterface::MASTER_REQUEST !== $event->getRequestType()) { return; } $response = $event->getResponse(); if (null === $response->getCharset()) { $response->setCharset($this->charset); } $response->prepare($event->getRequest()); } public static function getSubscribedEvents() { return array( KernelEvents::RESPONSE =>'onKernelResponse', ); } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\EventDispatcher\Event; class KernelEvent extends Event { private $kernel; private $request; private $requestType; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType) { $this->kernel = $kernel; $this->request = $request; $this->requestType = $requestType; } public function getKernel() { return $this->kernel; } public function getRequest() { return $this->request; } public function getRequestType() { return $this->requestType; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; class FilterControllerEvent extends KernelEvent { private $controller; public function __construct(HttpKernelInterface $kernel, $controller, Request $request, $requestType) { parent::__construct($kernel, $request, $requestType); $this->setController($controller); } public function getController() { return $this->controller; } public function setController($controller) { if (!is_callable($controller)) { throw new \LogicException(sprintf('The controller must be a callable (%s given).', $this->varToString($controller))); } $this->controller = $controller; } private function varToString($var) { if (is_object($var)) { return sprintf('Object(%s)', get_class($var)); } if (is_array($var)) { $a = array(); foreach ($var as $k => $v) { $a[] = sprintf('%s => %s', $k, $this->varToString($v)); } return sprintf("Array(%s)", implode(', ', $a)); } if (is_resource($var)) { return sprintf('Resource(%s)', get_resource_type($var)); } if (null === $var) { return'null'; } if (false === $var) { return'false'; } if (true === $var) { return'true'; } return (string) $var; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; class FilterResponseEvent extends KernelEvent { private $response; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, Response $response) { parent::__construct($kernel, $request, $requestType); $this->setResponse($response); } public function getResponse() { return $this->response; } public function setResponse(Response $response) { $this->response = $response; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpFoundation\Response; class GetResponseEvent extends KernelEvent { private $response; public function getResponse() { return $this->response; } public function setResponse(Response $response) { $this->response = $response; $this->stopPropagation(); } public function hasResponse() { return null !== $this->response; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; class GetResponseForControllerResultEvent extends GetResponseEvent { private $controllerResult; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, $controllerResult) { parent::__construct($kernel, $request, $requestType); $this->controllerResult = $controllerResult; } public function getControllerResult() { return $this->controllerResult; } public function setControllerResult($controllerResult) { $this->controllerResult = $controllerResult; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request; class GetResponseForExceptionEvent extends GetResponseEvent { private $exception; public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, \Exception $e) { parent::__construct($kernel, $request, $requestType); $this->setException($e); } public function getException() { return $this->exception; } public function setException(\Exception $exception) { $this->exception = $exception; } } } namespace Symfony\Component\HttpKernel\Event { use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\EventDispatcher\Event; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; class PostResponseEvent extends Event { private $kernel; private $request; private $response; public function __construct(HttpKernelInterface $kernel, Request $request, Response $response) { $this->kernel = $kernel; $this->request = $request; $this->response = $response; } public function getKernel() { return $this->kernel; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } } } namespace Symfony\Component\HttpKernel\Exception { interface HttpExceptionInterface { public function getStatusCode(); public function getHeaders(); } } namespace Symfony\Component\HttpKernel\Exception { class HttpException extends \RuntimeException implements HttpExceptionInterface { private $statusCode; private $headers; public function __construct($statusCode, $message = null, \Exception $previous = null, array $headers = array(), $code = 0) { $this->statusCode = $statusCode; $this->headers = $headers; parent::__construct($message, $code, $previous); } public function getStatusCode() { return $this->statusCode; } public function getHeaders() { return $this->headers; } } } namespace Symfony\Component\HttpKernel\Exception { class AccessDeniedHttpException extends HttpException { public function __construct($message = null, \Exception $previous = null, $code = 0) { parent::__construct(403, $message, $previous, array(), $code); } } } namespace Symfony\Component\HttpKernel\Exception { class MethodNotAllowedHttpException extends HttpException { public function __construct(array $allow, $message = null, \Exception $previous = null, $code = 0) { $headers = array('Allow'=> strtoupper(implode(', ', $allow))); parent::__construct(405, $message, $previous, $headers, $code); } } } namespace Symfony\Component\HttpKernel\Exception { class NotFoundHttpException extends HttpException { public function __construct($message = null, \Exception $previous = null, $code = 0) { parent::__construct(404, $message, $previous, array(), $code); } } } namespace Symfony\Component\HttpKernel\Exception { class FlattenException { private $message; private $code; private $previous; private $trace; private $class; private $statusCode; private $headers; private $file; private $line; public static function create(\Exception $exception, $statusCode = null, array $headers = array()) { $e = new static(); $e->setMessage($exception->getMessage()); $e->setCode($exception->getCode()); if ($exception instanceof HttpExceptionInterface) { $statusCode = $exception->getStatusCode(); $headers = array_merge($headers, $exception->getHeaders()); } if (null === $statusCode) { $statusCode = 500; } $e->setStatusCode($statusCode); $e->setHeaders($headers); $e->setTraceFromException($exception); $e->setClass(get_class($exception)); $e->setFile($exception->getFile()); $e->setLine($exception->getLine()); if ($exception->getPrevious()) { $e->setPrevious(static::create($exception->getPrevious())); } return $e; } public function toArray() { $exceptions = array(); foreach (array_merge(array($this), $this->getAllPrevious()) as $exception) { $exceptions[] = array('message'=> $exception->getMessage(),'class'=> $exception->getClass(),'trace'=> $exception->getTrace(), ); } return $exceptions; } public function getStatusCode() { return $this->statusCode; } public function setStatusCode($code) { $this->statusCode = $code; } public function getHeaders() { return $this->headers; } public function setHeaders(array $headers) { $this->headers = $headers; } public function getClass() { return $this->class; } public function setClass($class) { $this->class = $class; } public function getFile() { return $this->file; } public function setFile($file) { $this->file = $file; } public function getLine() { return $this->line; } public function setLine($line) { $this->line = $line; } public function getMessage() { return $this->message; } public function setMessage($message) { $this->message = $message; } public function getCode() { return $this->code; } public function setCode($code) { $this->code = $code; } public function getPrevious() { return $this->previous; } public function setPrevious(FlattenException $previous) { $this->previous = $previous; } public function getAllPrevious() { $exceptions = array(); $e = $this; while ($e = $e->getPrevious()) { $exceptions[] = $e; } return $exceptions; } public function getTrace() { return $this->trace; } public function setTraceFromException(\Exception $exception) { $trace = $exception->getTrace(); if ($exception instanceof FatalErrorException) { if (function_exists('xdebug_get_function_stack')) { $trace = array_slice(array_reverse(xdebug_get_function_stack()), 4); foreach ($trace as $i => $frame) { if (!isset($frame['type'])) { $trace[$i]['type'] ='??'; } if ('dynamic'=== $trace[$i]['type']) { $trace[$i]['type'] ='->'; } elseif ('static'=== $trace[$i]['type']) { $trace[$i]['type'] ='::'; } if (isset($frame['params']) && !isset($frame['args'])) { $trace[$i]['args'] = $frame['params']; unset($trace[$i]['params']); } } } else { $trace = array_slice(array_reverse($trace), 1); } } $this->setTrace($trace, $exception->getFile(), $exception->getLine()); } public function setTrace($trace, $file, $line) { $this->trace = array(); $this->trace[] = array('namespace'=>'','short_class'=>'','class'=>'','type'=>'','function'=>'','file'=> $file,'line'=> $line,'args'=> array(), ); foreach ($trace as $entry) { $class =''; $namespace =''; if (isset($entry['class'])) { $parts = explode('\\', $entry['class']); $class = array_pop($parts); $namespace = implode('\\', $parts); } $this->trace[] = array('namespace'=> $namespace,'short_class'=> $class,'class'=> isset($entry['class']) ? $entry['class'] :'','type'=> isset($entry['type']) ? $entry['type'] :'','function'=> isset($entry['function']) ? $entry['function'] : null,'file'=> isset($entry['file']) ? $entry['file'] : null,'line'=> isset($entry['line']) ? $entry['line'] : null,'args'=> isset($entry['args']) ? $this->flattenArgs($entry['args']) : array(), ); } } private function flattenArgs($args, $level = 0) { $result = array(); foreach ($args as $key => $value) { if (is_object($value)) { $result[$key] = array('object', get_class($value)); } elseif (is_array($value)) { if ($level > 10) { $result[$key] = array('array','*DEEP NESTED ARRAY*'); } else { $result[$key] = array('array', $this->flattenArgs($value, ++$level)); } } elseif (null === $value) { $result[$key] = array('null', null); } elseif (is_bool($value)) { $result[$key] = array('boolean', $value); } elseif (is_resource($value)) { $result[$key] = array('resource', get_resource_type($value)); } elseif ($value instanceof \__PHP_Incomplete_Class) { $result[$key] = array('incomplete-object', $this->getClassNameFromIncomplete($value)); } else { $result[$key] = array('string', (string) $value); } } return $result; } private function getClassNameFromIncomplete(\__PHP_Incomplete_Class $value) { $array = new \ArrayObject($value); return $array['__PHP_Incomplete_Class_Name']; } } } namespace Symfony\Component\HttpKernel { use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; interface HttpKernelInterface { const MASTER_REQUEST = 1; const SUB_REQUEST = 2; public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true); } } namespace Symfony\Component\HttpKernel { use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; interface TerminableInterface { public function terminate(Request $request, Response $response); } } namespace Symfony\Component\HttpKernel { use Symfony\Component\HttpKernel\Controller\ControllerResolverInterface; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface; use Symfony\Component\HttpKernel\Event\FilterControllerEvent; use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent; use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent; use Symfony\Component\HttpKernel\Event\PostResponseEvent; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\EventDispatcher\EventDispatcherInterface; class HttpKernel implements HttpKernelInterface, TerminableInterface { protected $dispatcher; protected $resolver; public function __construct(EventDispatcherInterface $dispatcher, ControllerResolverInterface $resolver) { $this->dispatcher = $dispatcher; $this->resolver = $resolver; } public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true) { try { return $this->handleRaw($request, $type); } catch (\Exception $e) { if (false === $catch) { throw $e; } return $this->handleException($e, $request, $type); } } public function terminate(Request $request, Response $response) { $this->dispatcher->dispatch(KernelEvents::TERMINATE, new PostResponseEvent($this, $request, $response)); } private function handleRaw(Request $request, $type = self::MASTER_REQUEST) { $event = new GetResponseEvent($this, $request, $type); $this->dispatcher->dispatch(KernelEvents::REQUEST, $event); if ($event->hasResponse()) { return $this->filterResponse($event->getResponse(), $request, $type); } if (false === $controller = $this->resolver->getController($request)) { throw new NotFoundHttpException(sprintf('Unable to find the controller for path "%s". Maybe you forgot to add the matching route in your routing configuration?', $request->getPathInfo())); } $event = new FilterControllerEvent($this, $controller, $request, $type); $this->dispatcher->dispatch(KernelEvents::CONTROLLER, $event); $controller = $event->getController(); $arguments = $this->resolver->getArguments($request, $controller); $response = call_user_func_array($controller, $arguments); if (!$response instanceof Response) { $event = new GetResponseForControllerResultEvent($this, $request, $type, $response); $this->dispatcher->dispatch(KernelEvents::VIEW, $event); if ($event->hasResponse()) { $response = $event->getResponse(); } if (!$response instanceof Response) { $msg = sprintf('The controller must return a response (%s given).', $this->varToString($response)); if (null === $response) { $msg .=' Did you forget to add a return statement somewhere in your controller?'; } throw new \LogicException($msg); } } return $this->filterResponse($response, $request, $type); } private function filterResponse(Response $response, Request $request, $type) { $event = new FilterResponseEvent($this, $request, $type, $response); $this->dispatcher->dispatch(KernelEvents::RESPONSE, $event); return $event->getResponse(); } private function handleException(\Exception $e, $request, $type) { $event = new GetResponseForExceptionEvent($this, $request, $type, $e); $this->dispatcher->dispatch(KernelEvents::EXCEPTION, $event); $e = $event->getException(); if (!$event->hasResponse()) { throw $e; } $response = $event->getResponse(); if ($response->headers->has('X-Status-Code')) { $response->setStatusCode($response->headers->get('X-Status-Code')); $response->headers->remove('X-Status-Code'); } elseif (!$response->isClientError() && !$response->isServerError() && !$response->isRedirect()) { if ($e instanceof HttpExceptionInterface) { $response->setStatusCode($e->getStatusCode()); $response->headers->add($e->getHeaders()); } else { $response->setStatusCode(500); } } try { return $this->filterResponse($response, $request, $type); } catch (\Exception $e) { return $response; } } private function varToString($var) { if (is_object($var)) { return sprintf('Object(%s)', get_class($var)); } if (is_array($var)) { $a = array(); foreach ($var as $k => $v) { $a[] = sprintf('%s => %s', $k, $this->varToString($v)); } return sprintf("Array(%s)", implode(', ', $a)); } if (is_resource($var)) { return sprintf('Resource(%s)', get_resource_type($var)); } if (null === $var) { return'null'; } if (false === $var) { return'false'; } if (true === $var) { return'true'; } return (string) $var; } } } namespace Symfony\Component\HttpKernel { final class KernelEvents { const REQUEST ='kernel.request'; const EXCEPTION ='kernel.exception'; const VIEW ='kernel.view'; const CONTROLLER ='kernel.controller'; const RESPONSE ='kernel.response'; const TERMINATE ='kernel.terminate'; } } namespace Symfony\Component\Process { use Symfony\Component\Process\Exception\InvalidArgumentException; use Symfony\Component\Process\Exception\LogicException; class ProcessBuilder { private $arguments; private $cwd; private $env; private $stdin; private $timeout; private $options; private $inheritEnv; public function __construct(array $arguments = array()) { $this->arguments = $arguments; $this->timeout = 60; $this->options = array(); $this->env = array(); $this->inheritEnv = true; } public static function create(array $arguments = array()) { return new static($arguments); } public function add($argument) { $this->arguments[] = $argument; return $this; } public function setArguments(array $arguments) { $this->arguments = $arguments; return $this; } public function setWorkingDirectory($cwd) { $this->cwd = $cwd; return $this; } public function inheritEnvironmentVariables($inheritEnv = true) { $this->inheritEnv = $inheritEnv; return $this; } public function setEnv($name, $value) { $this->env[$name] = $value; return $this; } public function setInput($stdin) { $this->stdin = $stdin; return $this; } public function setTimeout($timeout) { if (null === $timeout) { $this->timeout = null; return $this; } $timeout = (integer) $timeout; if ($timeout < 0) { throw new InvalidArgumentException('The timeout value must be a valid positive integer.'); } $this->timeout = $timeout; return $this; } public function setOption($name, $value) { $this->options[$name] = $value; return $this; } public function getProcess() { if (!count($this->arguments)) { throw new LogicException('You must add() command arguments before calling getProcess().'); } $options = $this->options; $script = implode(' ', array_map('escapeshellarg', $this->arguments)); if ($this->inheritEnv) { $env = $this->env ? $this->env + $_ENV : null; } else { $env = $this->env; } return new Process($script, $this->cwd, $env, $this->stdin, $this->timeout, $options); } } } namespace Symfony\Component\Process { use Symfony\Component\Process\Exception\InvalidArgumentException; use Symfony\Component\Process\Exception\RuntimeException; class Process { const ERR ='err'; const OUT ='out'; const STATUS_READY ='ready'; const STATUS_STARTED ='started'; const STATUS_TERMINATED ='terminated'; const STDIN = 0; const STDOUT = 1; const STDERR = 2; private $commandline; private $cwd; private $env; private $stdin; private $timeout; private $options; private $exitcode; private $fallbackExitcode; private $processInformation; private $stdout; private $stderr; private $enhanceWindowsCompatibility; private $enhanceSigchildCompatibility; private $pipes; private $process; private $status = self::STATUS_READY; private $incrementalOutputOffset; private $incrementalErrorOutputOffset; private $fileHandles; private $readBytes; private static $sigchild; public static $exitCodes = array( 0 =>'OK', 1 =>'General error', 2 =>'Misuse of shell builtins', 126 =>'Invoked command cannot execute', 127 =>'Command not found', 128 =>'Invalid exit argument', 129 =>'Hangup', 130 =>'Interrupt', 131 =>'Quit and dump core', 132 =>'Illegal instruction', 133 =>'Trace/breakpoint trap', 134 =>'Process aborted', 135 =>'Bus error: "access to undefined portion of memory object"', 136 =>'Floating point exception: "erroneous arithmetic operation"', 137 =>'Kill (terminate immediately)', 138 =>'User-defined 1', 139 =>'Segmentation violation', 140 =>'User-defined 2', 141 =>'Write to pipe with no one reading', 142 =>'Signal raised by alarm', 143 =>'Termination (request to terminate)', 145 =>'Child process terminated, stopped (or continued*)', 146 =>'Continue if stopped', 147 =>'Stop executing temporarily', 148 =>'Terminal stop signal', 149 =>'Background process attempting to read from tty ("in")', 150 =>'Background process attempting to write to tty ("out")', 151 =>'Urgent data available on socket', 152 =>'CPU time limit exceeded', 153 =>'File size limit exceeded', 154 =>'Signal raised by timer counting virtual time: "virtual timer expired"', 155 =>'Profiling timer expired', 157 =>'Pollable event', 159 =>'Bad syscall', ); public function __construct($commandline, $cwd = null, array $env = null, $stdin = null, $timeout = 60, array $options = array()) { if (!function_exists('proc_open')) { throw new RuntimeException('The Process class relies on proc_open, which is not available on your PHP installation.'); } $this->commandline = $commandline; $this->cwd = $cwd; if (null === $this->cwd && defined('PHP_WINDOWS_VERSION_BUILD')) { $this->cwd = getcwd(); } if (null !== $env) { $this->env = array(); foreach ($env as $key => $value) { $this->env[(binary) $key] = (binary) $value; } } else { $this->env = null; } $this->stdin = $stdin; $this->setTimeout($timeout); $this->enhanceWindowsCompatibility = true; $this->enhanceSigchildCompatibility = !defined('PHP_WINDOWS_VERSION_BUILD') && $this->isSigchildEnabled(); $this->options = array_replace(array('suppress_errors'=> true,'binary_pipes'=> true), $options); } public function __destruct() { $this->stop(); } public function __clone() { $this->exitcode = null; $this->fallbackExitcode = null; $this->processInformation = null; $this->stdout = null; $this->stderr = null; $this->pipes = null; $this->process = null; $this->status = self::STATUS_READY; $this->fileHandles = null; $this->readBytes = null; } public function run($callback = null) { $this->start($callback); return $this->wait($callback); } public function start($callback = null) { if ($this->isRunning()) { throw new RuntimeException('Process is already running'); } $this->stdout =''; $this->stderr =''; $this->incrementalOutputOffset = 0; $this->incrementalErrorOutputOffset = 0; $callback = $this->buildCallback($callback); if (defined('PHP_WINDOWS_VERSION_BUILD')) { $this->fileHandles = array( self::STDOUT => tmpfile(), ); if (false === $this->fileHandles[self::STDOUT]) { throw new RuntimeException('A temporary file could not be opened to write the process output to, verify that your TEMP environment variable is writable'); } $this->readBytes = array( self::STDOUT => 0, ); $descriptors = array(array('pipe','r'), $this->fileHandles[self::STDOUT], array('pipe','w')); } else { $descriptors = array( array('pipe','r'), array('pipe','w'), array('pipe','w'), ); if ($this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) { $descriptors = array_merge($descriptors, array(array('pipe','w'))); $this->commandline ='('.$this->commandline.') 3>/dev/null; code=$?; echo $code >&3; exit $code'; } } $commandline = $this->commandline; if (defined('PHP_WINDOWS_VERSION_BUILD') && $this->enhanceWindowsCompatibility) { $commandline ='cmd /V:ON /E:ON /C "'.$commandline.'"'; if (!isset($this->options['bypass_shell'])) { $this->options['bypass_shell'] = true; } } $this->process = proc_open($commandline, $descriptors, $this->pipes, $this->cwd, $this->env, $this->options); if (!is_resource($this->process)) { throw new RuntimeException('Unable to launch a new process.'); } $this->status = self::STATUS_STARTED; foreach ($this->pipes as $pipe) { stream_set_blocking($pipe, false); } if (null === $this->stdin) { fclose($this->pipes[0]); unset($this->pipes[0]); return; } $writePipes = array($this->pipes[0]); unset($this->pipes[0]); $stdinLen = strlen($this->stdin); $stdinOffset = 0; while ($writePipes) { if (defined('PHP_WINDOWS_VERSION_BUILD')) { $this->processFileHandles($callback); } $r = $this->pipes; $w = $writePipes; $e = null; $n = @stream_select($r, $w, $e, $this->timeout); if (false === $n) { break; } if ($n === 0) { proc_terminate($this->process); throw new RuntimeException('The process timed out.'); } if ($w) { $written = fwrite($writePipes[0], (binary) substr($this->stdin, $stdinOffset), 8192); if (false !== $written) { $stdinOffset += $written; } if ($stdinOffset >= $stdinLen) { fclose($writePipes[0]); $writePipes = null; } } foreach ($r as $pipe) { $type = array_search($pipe, $this->pipes); $data = fread($pipe, 8192); if (strlen($data) > 0) { call_user_func($callback, $type == 1 ? self::OUT : self::ERR, $data); } if (false === $data || feof($pipe)) { fclose($pipe); unset($this->pipes[$type]); } } } $this->updateStatus(); } public function restart($callback = null) { if ($this->isRunning()) { throw new \RuntimeException('Process is already running'); } $process = clone $this; $process->start($callback); return $process; } public function wait($callback = null) { $this->updateStatus(); $callback = $this->buildCallback($callback); while ($this->pipes || (defined('PHP_WINDOWS_VERSION_BUILD') && $this->fileHandles)) { if (defined('PHP_WINDOWS_VERSION_BUILD') && $this->fileHandles) { $this->processFileHandles($callback, !$this->pipes); } if ($this->pipes) { $r = $this->pipes; $w = null; $e = null; if (false === $n = @stream_select($r, $w, $e, $this->timeout)) { $lastError = error_get_last(); if (isset($lastError['message']) && false === stripos($lastError['message'],'interrupted system call')) { $this->pipes = array(); } continue; } if (0 === $n) { proc_terminate($this->process); throw new RuntimeException('The process timed out.'); } foreach ($r as $pipe) { $type = array_search($pipe, $this->pipes); $data = fread($pipe, 8192); if (strlen($data) > 0) { if (3 == $type) { $this->fallbackExitcode = (int) $data; } else { call_user_func($callback, $type == 1 ? self::OUT : self::ERR, $data); } } if (false === $data || feof($pipe)) { fclose($pipe); unset($this->pipes[$type]); } } } } $this->updateStatus(); if ($this->processInformation['signaled']) { throw new RuntimeException(sprintf('The process stopped because of a "%s" signal.', $this->processInformation['stopsig'])); } $time = 0; while ($this->isRunning() && $time < 1000000) { $time += 1000; usleep(1000); } $exitcode = proc_close($this->process); if ($this->processInformation['signaled']) { throw new RuntimeException(sprintf('The process stopped because of a "%s" signal.', $this->processInformation['stopsig'])); } $this->exitcode = $this->processInformation['running'] ? $exitcode : $this->processInformation['exitcode']; if (-1 == $this->exitcode && null !== $this->fallbackExitcode) { $this->exitcode = $this->fallbackExitcode; } return $this->exitcode; } public function getOutput() { $this->updateOutput(); return $this->stdout; } public function getIncrementalOutput() { $data = $this->getOutput(); $latest = substr($data, $this->incrementalOutputOffset); $this->incrementalOutputOffset = strlen($data); return $latest; } public function getErrorOutput() { $this->updateErrorOutput(); return $this->stderr; } public function getIncrementalErrorOutput() { $data = $this->getErrorOutput(); $latest = substr($data, $this->incrementalErrorOutputOffset); $this->incrementalErrorOutputOffset = strlen($data); return $latest; } public function getExitCode() { if ($this->isSigchildEnabled() && !$this->enhanceSigchildCompatibility) { throw new RuntimeException('This PHP has been compiled with --enable-sigchild. You must use setEnhanceSigchildCompatibility() to use this method'); } $this->updateStatus(); return $this->exitcode; } public function getExitCodeText() { $exitcode = $this->getExitCode(); return isset(self::$exitCodes[$exitcode]) ? self::$exitCodes[$exitcode] :'Unknown error'; } public function isSuccessful() { return 0 == $this->getExitCode(); } public function hasBeenSignaled() { if ($this->isSigchildEnabled()) { throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved'); } $this->updateStatus(); return $this->processInformation['signaled']; } public function getTermSignal() { if ($this->isSigchildEnabled()) { throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved'); } $this->updateStatus(); return $this->processInformation['termsig']; } public function hasBeenStopped() { $this->updateStatus(); return $this->processInformation['stopped']; } public function getStopSignal() { $this->updateStatus(); return $this->processInformation['stopsig']; } public function isRunning() { if (self::STATUS_STARTED !== $this->status) { return false; } $this->updateStatus(); return $this->processInformation['running']; } public function isStarted() { return $this->status != self::STATUS_READY; } public function isTerminated() { $this->updateStatus(); return $this->status == self::STATUS_TERMINATED; } public function getStatus() { $this->updateStatus(); return $this->status; } public function stop($timeout = 10) { $timeoutMicro = (int) $timeout*10E6; if ($this->isRunning()) { proc_terminate($this->process); $time = 0; while (1 == $this->isRunning() && $time < $timeoutMicro) { $time += 1000; usleep(1000); } foreach ($this->pipes as $pipe) { fclose($pipe); } $this->pipes = array(); $exitcode = proc_close($this->process); $this->exitcode = -1 === $this->processInformation['exitcode'] ? $exitcode : $this->processInformation['exitcode']; if (defined('PHP_WINDOWS_VERSION_BUILD')) { foreach ($this->fileHandles as $fileHandle) { fclose($fileHandle); } $this->fileHandles = array(); } } $this->status = self::STATUS_TERMINATED; return $this->exitcode; } public function addOutput($line) { $this->stdout .= $line; } public function addErrorOutput($line) { $this->stderr .= $line; } public function getCommandLine() { return $this->commandline; } public function setCommandLine($commandline) { $this->commandline = $commandline; return $this; } public function getTimeout() { return $this->timeout; } public function setTimeout($timeout) { if (null === $timeout) { $this->timeout = null; return $this; } $timeout = (integer) $timeout; if ($timeout < 0) { throw new InvalidArgumentException('The timeout value must be a valid positive integer.'); } $this->timeout = $timeout; return $this; } public function getWorkingDirectory() { if (null === $this->cwd) { return getcwd() ?: null; } return $this->cwd; } public function setWorkingDirectory($cwd) { $this->cwd = $cwd; return $this; } public function getEnv() { return $this->env; } public function setEnv(array $env) { $this->env = $env; return $this; } public function getStdin() { return $this->stdin; } public function setStdin($stdin) { $this->stdin = $stdin; return $this; } public function getOptions() { return $this->options; } public function setOptions(array $options) { $this->options = $options; return $this; } public function getEnhanceWindowsCompatibility() { return $this->enhanceWindowsCompatibility; } public function setEnhanceWindowsCompatibility($enhance) { $this->enhanceWindowsCompatibility = (Boolean) $enhance; return $this; } public function getEnhanceSigchildCompatibility() { return $this->enhanceSigchildCompatibility; } public function setEnhanceSigchildCompatibility($enhance) { $this->enhanceSigchildCompatibility = (Boolean) $enhance; return $this; } protected function buildCallback($callback) { $that = $this; $out = self::OUT; $err = self::ERR; $callback = function ($type, $data) use ($that, $callback, $out, $err) { if ($out == $type) { $that->addOutput($data); } else { $that->addErrorOutput($data); } if (null !== $callback) { call_user_func($callback, $type, $data); } }; return $callback; } protected function updateStatus() { if (self::STATUS_STARTED !== $this->status) { return; } $this->processInformation = proc_get_status($this->process); if (!$this->processInformation['running']) { $this->status = self::STATUS_TERMINATED; if (-1 !== $this->processInformation['exitcode']) { $this->exitcode = $this->processInformation['exitcode']; } } } protected function updateErrorOutput() { if (isset($this->pipes[self::STDERR]) && is_resource($this->pipes[self::STDERR])) { $this->addErrorOutput(stream_get_contents($this->pipes[self::STDERR])); } } protected function updateOutput() { if (defined('PHP_WINDOWS_VERSION_BUILD') && isset($this->fileHandles[self::STDOUT]) && is_resource($this->fileHandles[self::STDOUT])) { fseek($this->fileHandles[self::STDOUT], $this->readBytes[self::STDOUT]); $this->addOutput(stream_get_contents($this->fileHandles[self::STDOUT])); } elseif (isset($this->pipes[self::STDOUT]) && is_resource($this->pipes[self::STDOUT])) { $this->addOutput(stream_get_contents($this->pipes[self::STDOUT])); } } protected function isSigchildEnabled() { if (null !== self::$sigchild) { return self::$sigchild; } ob_start(); phpinfo(INFO_GENERAL); return self::$sigchild = false !== strpos(ob_get_clean(),'--enable-sigchild'); } private function processFileHandles($callback, $closeEmptyHandles = false) { $fh = $this->fileHandles; foreach ($fh as $type => $fileHandle) { fseek($fileHandle, $this->readBytes[$type]); $data = fread($fileHandle, 8192); if (strlen($data) > 0) { $this->readBytes[$type] += strlen($data); call_user_func($callback, $type == 1 ? self::OUT : self::ERR, $data); } if (false === $data || ($closeEmptyHandles &&''=== $data && feof($fileHandle))) { fclose($fileHandle); unset($this->fileHandles[$type]); } } } } } namespace Symfony\Component\Routing\Exception { interface ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class InvalidParameterException extends \InvalidArgumentException implements ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class MethodNotAllowedException extends \RuntimeException implements ExceptionInterface { protected $allowedMethods = array(); public function __construct(array $allowedMethods, $message = null, $code = 0, \Exception $previous = null) { $this->allowedMethods = array_map('strtoupper', $allowedMethods); parent::__construct($message, $code, $previous); } public function getAllowedMethods() { return $this->allowedMethods; } } } namespace Symfony\Component\Routing\Exception { class MissingMandatoryParametersException extends \InvalidArgumentException implements ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class ResourceNotFoundException extends \RuntimeException implements ExceptionInterface { } } namespace Symfony\Component\Routing\Exception { class RouteNotFoundException extends \InvalidArgumentException implements ExceptionInterface { } } namespace Symfony\Component\Routing { interface RequestContextAwareInterface { public function setContext(RequestContext $context); public function getContext(); } } namespace Symfony\Component\Routing\Generator { use Symfony\Component\Routing\Exception\InvalidParameterException; use Symfony\Component\Routing\Exception\MissingMandatoryParametersException; use Symfony\Component\Routing\Exception\RouteNotFoundException; use Symfony\Component\Routing\RequestContextAwareInterface; interface UrlGeneratorInterface extends RequestContextAwareInterface { const ABSOLUTE_URL = true; const ABSOLUTE_PATH = false; const RELATIVE_PATH ='relative'; const NETWORK_PATH ='network'; public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH); } } namespace Symfony\Component\Routing\Generator { interface ConfigurableRequirementsInterface { public function setStrictRequirements($enabled); public function isStrictRequirements(); } } namespace Symfony\Component\Routing\Generator { use Symfony\Component\Routing\RouteCollection; use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\Exception\InvalidParameterException; use Symfony\Component\Routing\Exception\RouteNotFoundException; use Symfony\Component\Routing\Exception\MissingMandatoryParametersException; use Psr\Log\LoggerInterface; class UrlGenerator implements UrlGeneratorInterface, ConfigurableRequirementsInterface { protected $routes; protected $context; protected $strictRequirements = true; protected $logger; protected $decodedChars = array('%2F'=>'/','%40'=>'@','%3A'=>':','%3B'=>';','%2C'=>',','%3D'=>'=','%2B'=>'+','%21'=>'!','%2A'=>'*','%7C'=>'|', ); public function __construct(RouteCollection $routes, RequestContext $context, LoggerInterface $logger = null) { $this->routes = $routes; $this->context = $context; $this->logger = $logger; } public function setContext(RequestContext $context) { $this->context = $context; } public function getContext() { return $this->context; } public function setStrictRequirements($enabled) { $this->strictRequirements = null === $enabled ? null : (Boolean) $enabled; } public function isStrictRequirements() { return $this->strictRequirements; } public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH) { if (null === $route = $this->routes->get($name)) { throw new RouteNotFoundException(sprintf('Unable to generate a URL for the named route "%s" as such route does not exist.', $name)); } $compiledRoute = $route->compile(); return $this->doGenerate($compiledRoute->getVariables(), $route->getDefaults(), $route->getRequirements(), $compiledRoute->getTokens(), $parameters, $name, $referenceType, $compiledRoute->getHostTokens()); } protected function doGenerate($variables, $defaults, $requirements, $tokens, $parameters, $name, $referenceType, $hostTokens) { $variables = array_flip($variables); $mergedParams = array_replace($defaults, $this->context->getParameters(), $parameters); if ($diff = array_diff_key($variables, $mergedParams)) { throw new MissingMandatoryParametersException(sprintf('Some mandatory parameters are missing ("%s") to generate a URL for route "%s".', implode('", "', array_keys($diff)), $name)); } $url =''; $optional = true; foreach ($tokens as $token) { if ('variable'=== $token[0]) { if (!$optional || !array_key_exists($token[3], $defaults) || (string) $mergedParams[$token[3]] !== (string) $defaults[$token[3]]) { if (null !== $this->strictRequirements && !preg_match('#^'.$token[2].'$#', $mergedParams[$token[3]])) { $message = sprintf('Parameter "%s" for route "%s" must match "%s" ("%s" given) to generate a corresponding URL.', $token[3], $name, $token[2], $mergedParams[$token[3]]); if ($this->strictRequirements) { throw new InvalidParameterException($message); } if ($this->logger) { $this->logger->error($message); } return null; } $url = $token[1].$mergedParams[$token[3]].$url; $optional = false; } } else { $url = $token[1].$url; $optional = false; } } if (''=== $url) { $url ='/'; } $url = strtr(rawurlencode($url), $this->decodedChars); $url = strtr($url, array('/../'=>'/%2E%2E/','/./'=>'/%2E/')); if ('/..'=== substr($url, -3)) { $url = substr($url, 0, -2) .'%2E%2E'; } elseif ('/.'=== substr($url, -2)) { $url = substr($url, 0, -1) .'%2E'; } $schemeAuthority =''; if ($host = $this->context->getHost()) { $scheme = $this->context->getScheme(); if (isset($requirements['_scheme']) && ($req = strtolower($requirements['_scheme'])) && $scheme !== $req) { $referenceType = self::ABSOLUTE_URL; $scheme = $req; } if ($hostTokens) { $routeHost =''; foreach ($hostTokens as $token) { if ('variable'=== $token[0]) { if (null !== $this->strictRequirements && !preg_match('#^'.$token[2].'$#', $mergedParams[$token[3]])) { $message = sprintf('Parameter "%s" for route "%s" must match "%s" ("%s" given) to generate a corresponding URL.', $token[3], $name, $token[2], $mergedParams[$token[3]]); if ($this->strictRequirements) { throw new InvalidParameterException($message); } if ($this->logger) { $this->logger->error($message); } return null; } $routeHost = $token[1].$mergedParams[$token[3]].$routeHost; } else { $routeHost = $token[1].$routeHost; } } if ($routeHost !== $host) { $host = $routeHost; if (self::ABSOLUTE_URL !== $referenceType) { $referenceType = self::NETWORK_PATH; } } } if (self::ABSOLUTE_URL === $referenceType || self::NETWORK_PATH === $referenceType) { $port =''; if ('http'=== $scheme && 80 != $this->context->getHttpPort()) { $port =':'.$this->context->getHttpPort(); } elseif ('https'=== $scheme && 443 != $this->context->getHttpsPort()) { $port =':'.$this->context->getHttpsPort(); } $schemeAuthority = self::NETWORK_PATH === $referenceType ?'//': "$scheme://"; $schemeAuthority .= $host.$port; } } if (self::RELATIVE_PATH === $referenceType) { $url = self::getRelativePath($this->context->getPathInfo(), $url); } else { $url = $schemeAuthority.$this->context->getBaseUrl().$url; } $extra = array_diff_key($parameters, $variables); if ($extra && $query = http_build_query($extra,'','&')) { $url .='?'.$query; } return $url; } public static function getRelativePath($basePath, $targetPath) { if ($basePath === $targetPath) { return''; } $sourceDirs = explode('/', isset($basePath[0]) &&'/'=== $basePath[0] ? substr($basePath, 1) : $basePath); $targetDirs = explode('/', isset($targetPath[0]) &&'/'=== $targetPath[0] ? substr($targetPath, 1) : $targetPath); array_pop($sourceDirs); $targetFile = array_pop($targetDirs); foreach ($sourceDirs as $i => $dir) { if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) { unset($sourceDirs[$i], $targetDirs[$i]); } else { break; } } $targetDirs[] = $targetFile; $path = str_repeat('../', count($sourceDirs)) . implode('/', $targetDirs); return''=== $path ||'/'=== $path[0] || false !== ($colonPos = strpos($path,':')) && ($colonPos < ($slashPos = strpos($path,'/')) || false === $slashPos) ? "./$path" : $path; } } } namespace Symfony\Component\Routing\Matcher { use Symfony\Component\Routing\RequestContextAwareInterface; use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\Exception\MethodNotAllowedException; interface UrlMatcherInterface extends RequestContextAwareInterface { public function match($pathinfo); } } namespace Symfony\Component\Routing\Matcher { interface RedirectableUrlMatcherInterface { public function redirect($path, $route, $scheme = null); } } namespace Symfony\Component\Routing\Matcher { use Symfony\Component\Routing\Exception\MethodNotAllowedException; use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\RouteCollection; use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\Route; class UrlMatcher implements UrlMatcherInterface { const REQUIREMENT_MATCH = 0; const REQUIREMENT_MISMATCH = 1; const ROUTE_MATCH = 2; protected $context; protected $allow = array(); protected $routes; public function __construct(RouteCollection $routes, RequestContext $context) { $this->routes = $routes; $this->context = $context; } public function setContext(RequestContext $context) { $this->context = $context; } public function getContext() { return $this->context; } public function match($pathinfo) { $this->allow = array(); if ($ret = $this->matchCollection(rawurldecode($pathinfo), $this->routes)) { return $ret; } throw 0 < count($this->allow) ? new MethodNotAllowedException(array_unique(array_map('strtoupper', $this->allow))) : new ResourceNotFoundException(); } protected function matchCollection($pathinfo, RouteCollection $routes) { foreach ($routes as $name => $route) { $compiledRoute = $route->compile(); if (''!== $compiledRoute->getStaticPrefix() && 0 !== strpos($pathinfo, $compiledRoute->getStaticPrefix())) { continue; } if (!preg_match($compiledRoute->getRegex(), $pathinfo, $matches)) { continue; } $hostMatches = array(); if ($compiledRoute->getHostRegex() && !preg_match($compiledRoute->getHostRegex(), $this->context->getHost(), $hostMatches)) { continue; } if ($req = $route->getRequirement('_method')) { if ('HEAD'=== $method = $this->context->getMethod()) { $method ='GET'; } if (!in_array($method, $req = explode('|', strtoupper($req)))) { $this->allow = array_merge($this->allow, $req); continue; } } $status = $this->handleRouteRequirements($pathinfo, $name, $route); if (self::ROUTE_MATCH === $status[0]) { return $status[1]; } if (self::REQUIREMENT_MISMATCH === $status[0]) { continue; } return $this->getAttributes($route, $name, array_replace($matches, $hostMatches)); } } protected function getAttributes(Route $route, $name, array $attributes) { $attributes['_route'] = $name; return $this->mergeDefaults($attributes, $route->getDefaults()); } protected function handleRouteRequirements($pathinfo, $name, Route $route) { $scheme = $route->getRequirement('_scheme'); $status = $scheme && $scheme !== $this->context->getScheme() ? self::REQUIREMENT_MISMATCH : self::REQUIREMENT_MATCH; return array($status, null); } protected function mergeDefaults($params, $defaults) { foreach ($params as $key => $value) { if (!is_int($key)) { $defaults[$key] = $value; } } return $defaults; } } } namespace Symfony\Component\Routing\Matcher { use Symfony\Component\Routing\Exception\ResourceNotFoundException; use Symfony\Component\Routing\Route; abstract class RedirectableUrlMatcher extends UrlMatcher implements RedirectableUrlMatcherInterface { public function match($pathinfo) { try { $parameters = parent::match($pathinfo); } catch (ResourceNotFoundException $e) { if ('/'=== substr($pathinfo, -1) || !in_array($this->context->getMethod(), array('HEAD','GET'))) { throw $e; } try { parent::match($pathinfo.'/'); return $this->redirect($pathinfo.'/', null); } catch (ResourceNotFoundException $e2) { throw $e; } } return $parameters; } protected function handleRouteRequirements($pathinfo, $name, Route $route) { $scheme = $route->getRequirement('_scheme'); if ($scheme && $this->context->getScheme() !== $scheme) { return array(self::ROUTE_MATCH, $this->redirect($pathinfo, $name, $scheme)); } return array(self::REQUIREMENT_MATCH, null); } } } namespace Symfony\Component\Routing { use Symfony\Component\HttpFoundation\Request; class RequestContext { private $baseUrl; private $pathInfo; private $method; private $host; private $scheme; private $httpPort; private $httpsPort; private $parameters = array(); public function __construct($baseUrl ='', $method ='GET', $host ='localhost', $scheme ='http', $httpPort = 80, $httpsPort = 443, $path ='/') { $this->baseUrl = $baseUrl; $this->method = strtoupper($method); $this->host = $host; $this->scheme = strtolower($scheme); $this->httpPort = $httpPort; $this->httpsPort = $httpsPort; $this->pathInfo = $path; } public function fromRequest(Request $request) { $this->setBaseUrl($request->getBaseUrl()); $this->setPathInfo($request->getPathInfo()); $this->setMethod($request->getMethod()); $this->setHost($request->getHost()); $this->setScheme($request->getScheme()); $this->setHttpPort($request->isSecure() ? $this->httpPort : $request->getPort()); $this->setHttpsPort($request->isSecure() ? $request->getPort() : $this->httpsPort); } public function getBaseUrl() { return $this->baseUrl; } public function setBaseUrl($baseUrl) { $this->baseUrl = $baseUrl; } public function getPathInfo() { return $this->pathInfo; } public function setPathInfo($pathInfo) { $this->pathInfo = $pathInfo; } public function getMethod() { return $this->method; } public function setMethod($method) { $this->method = strtoupper($method); } public function getHost() { return $this->host; } public function setHost($host) { $this->host = $host; } public function getScheme() { return $this->scheme; } public function setScheme($scheme) { $this->scheme = strtolower($scheme); } public function getHttpPort() { return $this->httpPort; } public function setHttpPort($httpPort) { $this->httpPort = $httpPort; } public function getHttpsPort() { return $this->httpsPort; } public function setHttpsPort($httpsPort) { $this->httpsPort = $httpsPort; } public function getParameters() { return $this->parameters; } public function setParameters(array $parameters) { $this->parameters = $parameters; return $this; } public function getParameter($name) { return isset($this->parameters[$name]) ? $this->parameters[$name] : null; } public function hasParameter($name) { return array_key_exists($name, $this->parameters); } public function setParameter($name, $parameter) { $this->parameters[$name] = $parameter; } } } namespace Symfony\Component\Routing { class Route implements \Serializable { private $path ='/'; private $host =''; private $schemes = array(); private $methods = array(); private $defaults = array(); private $requirements = array(); private $options = array(); private $compiled; public function __construct($path, array $defaults = array(), array $requirements = array(), array $options = array(), $host ='', $schemes = array(), $methods = array()) { $this->setPath($path); $this->setDefaults($defaults); $this->setRequirements($requirements); $this->setOptions($options); $this->setHost($host); if ($schemes) { $this->setSchemes($schemes); } if ($methods) { $this->setMethods($methods); } } public function serialize() { return serialize(array('path'=> $this->path,'host'=> $this->host,'defaults'=> $this->defaults,'requirements'=> $this->requirements,'options'=> $this->options,'schemes'=> $this->schemes,'methods'=> $this->methods, )); } public function unserialize($data) { $data = unserialize($data); $this->path = $data['path']; $this->host = $data['host']; $this->defaults = $data['defaults']; $this->requirements = $data['requirements']; $this->options = $data['options']; $this->schemes = $data['schemes']; $this->methods = $data['methods']; } public function getPattern() { return $this->path; } public function setPattern($pattern) { return $this->setPath($pattern); } public function getPath() { return $this->path; } public function setPath($pattern) { $this->path ='/'. ltrim(trim($pattern),'/'); $this->compiled = null; return $this; } public function getHost() { return $this->host; } public function setHost($pattern) { $this->host = (string) $pattern; $this->compiled = null; return $this; } public function getSchemes() { return $this->schemes; } public function setSchemes($schemes) { $this->schemes = array_map('strtolower', (array) $schemes); if ($this->schemes) { $this->requirements['_scheme'] = implode('|', $this->schemes); } else { unset($this->requirements['_scheme']); } $this->compiled = null; return $this; } public function getMethods() { return $this->methods; } public function setMethods($methods) { $this->methods = array_map('strtoupper', (array) $methods); if ($this->methods) { $this->requirements['_method'] = implode('|', $this->methods); } else { unset($this->requirements['_method']); } $this->compiled = null; return $this; } public function getOptions() { return $this->options; } public function setOptions(array $options) { $this->options = array('compiler_class'=>'Symfony\\Component\\Routing\\RouteCompiler', ); return $this->addOptions($options); } public function addOptions(array $options) { foreach ($options as $name => $option) { $this->options[$name] = $option; } $this->compiled = null; return $this; } public function setOption($name, $value) { $this->options[$name] = $value; $this->compiled = null; return $this; } public function getOption($name) { return isset($this->options[$name]) ? $this->options[$name] : null; } public function hasOption($name) { return array_key_exists($name, $this->options); } public function getDefaults() { return $this->defaults; } public function setDefaults(array $defaults) { $this->defaults = array(); return $this->addDefaults($defaults); } public function addDefaults(array $defaults) { foreach ($defaults as $name => $default) { $this->defaults[$name] = $default; } $this->compiled = null; return $this; } public function getDefault($name) { return isset($this->defaults[$name]) ? $this->defaults[$name] : null; } public function hasDefault($name) { return array_key_exists($name, $this->defaults); } public function setDefault($name, $default) { $this->defaults[$name] = $default; $this->compiled = null; return $this; } public function getRequirements() { return $this->requirements; } public function setRequirements(array $requirements) { $this->requirements = array(); return $this->addRequirements($requirements); } public function addRequirements(array $requirements) { foreach ($requirements as $key => $regex) { $this->requirements[$key] = $this->sanitizeRequirement($key, $regex); } $this->compiled = null; return $this; } public function getRequirement($key) { return isset($this->requirements[$key]) ? $this->requirements[$key] : null; } public function hasRequirement($key) { return array_key_exists($key, $this->requirements); } public function setRequirement($key, $regex) { $this->requirements[$key] = $this->sanitizeRequirement($key, $regex); $this->compiled = null; return $this; } public function compile() { if (null !== $this->compiled) { return $this->compiled; } $class = $this->getOption('compiler_class'); return $this->compiled = $class::compile($this); } private function sanitizeRequirement($key, $regex) { if (!is_string($regex)) { throw new \InvalidArgumentException(sprintf('Routing requirement for "%s" must be a string.', $key)); } if (''!== $regex &&'^'=== $regex[0]) { $regex = (string) substr($regex, 1); } if ('$'=== substr($regex, -1)) { $regex = substr($regex, 0, -1); } if (''=== $regex) { throw new \InvalidArgumentException(sprintf('Routing requirement for "%s" cannot be empty.', $key)); } if ('_scheme'=== $key) { $this->setSchemes(explode('|', $regex)); } elseif ('_method'=== $key) { $this->setMethods(explode('|', $regex)); } return $regex; } } } namespace Symfony\Component\Routing { class CompiledRoute { private $variables; private $tokens; private $staticPrefix; private $regex; private $pathVariables; private $hostVariables; private $hostRegex; private $hostTokens; public function __construct($staticPrefix, $regex, array $tokens, array $pathVariables, $hostRegex = null, array $hostTokens = array(), array $hostVariables = array(), array $variables = array()) { $this->staticPrefix = (string) $staticPrefix; $this->regex = $regex; $this->tokens = $tokens; $this->pathVariables = $pathVariables; $this->hostRegex = $hostRegex; $this->hostTokens = $hostTokens; $this->hostVariables = $hostVariables; $this->variables = $variables; } public function getStaticPrefix() { return $this->staticPrefix; } public function getRegex() { return $this->regex; } public function getHostRegex() { return $this->hostRegex; } public function getTokens() { return $this->tokens; } public function getHostTokens() { return $this->hostTokens; } public function getVariables() { return $this->variables; } public function getPathVariables() { return $this->pathVariables; } public function getHostVariables() { return $this->hostVariables; } } } namespace Symfony\Component\Routing { use Symfony\Component\Config\Resource\ResourceInterface; class RouteCollection implements \IteratorAggregate, \Countable { private $routes = array(); private $resources = array(); private $prefix =''; private $parent; public function __clone() { foreach ($this->routes as $name => $route) { $this->routes[$name] = clone $route; } } public function getParent() { return $this->parent; } public function getRoot() { $parent = $this; while ($parent->getParent()) { $parent = $parent->getParent(); } return $parent; } public function getIterator() { return new \ArrayIterator($this->routes); } public function count() { return count($this->routes); } public function add($name, Route $route) { unset($this->routes[$name]); $this->routes[$name] = $route; } public function all() { return $this->routes; } public function get($name) { return isset($this->routes[$name]) ? $this->routes[$name] : null; } public function remove($name) { $root = $this->getRoot(); foreach ((array) $name as $n) { unset($root->routes[$n]); unset($this->routes[$n]); } } public function addCollection(RouteCollection $collection) { $collection->parent = $this; $numargs = func_num_args(); if ($numargs > 1) { $collection->addPrefix($this->prefix . func_get_arg(1)); if ($numargs > 2) { $collection->addDefaults(func_get_arg(2)); if ($numargs > 3) { $collection->addRequirements(func_get_arg(3)); if ($numargs > 4) { $collection->addOptions(func_get_arg(4)); } } } } else { $collection->addPrefix($this->prefix); } foreach ($collection->all() as $name => $route) { unset($this->routes[$name]); $this->routes[$name] = $route; } $this->resources = array_merge($this->resources, $collection->getResources()); } public function addPrefix($prefix, array $defaults = array(), array $requirements = array()) { $prefix = trim(trim($prefix),'/'); if (''=== $prefix) { return; } $this->prefix ='/'. $prefix . $this->prefix; $options = func_num_args() > 3 ? func_get_arg(3) : array(); foreach ($this->routes as $route) { $route->setPath('/'. $prefix . $route->getPath()); $route->addDefaults($defaults); $route->addRequirements($requirements); $route->addOptions($options); } } public function getPrefix() { return $this->prefix; } public function setHost($pattern, array $defaults = array(), array $requirements = array()) { foreach ($this->routes as $route) { $route->setHost($pattern); $route->addDefaults($defaults); $route->addRequirements($requirements); } } public function addDefaults(array $defaults) { if ($defaults) { foreach ($this->routes as $route) { $route->addDefaults($defaults); } } } public function addRequirements(array $requirements) { if ($requirements) { foreach ($this->routes as $route) { $route->addRequirements($requirements); } } } public function addOptions(array $options) { if ($options) { foreach ($this->routes as $route) { $route->addOptions($options); } } } public function setSchemes($schemes) { foreach ($this->routes as $route) { $route->setSchemes($schemes); } } public function setMethods($methods) { foreach ($this->routes as $route) { $route->setMethods($methods); } } public function getResources() { return array_unique($this->resources); } public function addResource(ResourceInterface $resource) { $this->resources[] = $resource; } } } namespace Symfony\Component\Routing { interface RouteCompilerInterface { public static function compile(Route $route); } } namespace Symfony\Component\Routing { class RouteCompiler implements RouteCompilerInterface { const REGEX_DELIMITER ='#'; const SEPARATORS ='/,;.:-_~+*=@|'; public static function compile(Route $route) { $staticPrefix = null; $hostVariables = array(); $pathVariables = array(); $variables = array(); $tokens = array(); $regex = null; $hostRegex = null; $hostTokens = array(); if (''!== $host = $route->getHost()) { $result = self::compilePattern($route, $host, true); $hostVariables = $result['variables']; $variables = array_merge($variables, $hostVariables); $hostTokens = $result['tokens']; $hostRegex = $result['regex']; } $path = $route->getPath(); $result = self::compilePattern($route, $path, false); $staticPrefix = $result['staticPrefix']; $pathVariables = $result['variables']; $variables = array_merge($variables, $pathVariables); $tokens = $result['tokens']; $regex = $result['regex']; return new CompiledRoute( $staticPrefix, $regex, $tokens, $pathVariables, $hostRegex, $hostTokens, $hostVariables, array_unique($variables) ); } private static function compilePattern(Route $route, $pattern, $isHost) { $tokens = array(); $variables = array(); $matches = array(); $pos = 0; $defaultSeparator = $isHost ?'.':'/'; preg_match_all('#\{\w+\}#', $pattern, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER); foreach ($matches as $match) { $varName = substr($match[0][0], 1, -1); $precedingText = substr($pattern, $pos, $match[0][1] - $pos); $pos = $match[0][1] + strlen($match[0][0]); $precedingChar = strlen($precedingText) > 0 ? substr($precedingText, -1) :''; $isSeparator =''!== $precedingChar && false !== strpos(static::SEPARATORS, $precedingChar); if (is_numeric($varName)) { throw new \DomainException(sprintf('Variable name "%s" cannot be numeric in route pattern "%s". Please use a different name.', $varName, $pattern)); } if (in_array($varName, $variables)) { throw new \LogicException(sprintf('Route pattern "%s" cannot reference variable name "%s" more than once.', $pattern, $varName)); } if ($isSeparator && strlen($precedingText) > 1) { $tokens[] = array('text', substr($precedingText, 0, -1)); } elseif (!$isSeparator && strlen($precedingText) > 0) { $tokens[] = array('text', $precedingText); } $regexp = $route->getRequirement($varName); if (null === $regexp) { $followingPattern = (string) substr($pattern, $pos); $nextSeparator = self::findNextSeparator($followingPattern); $regexp = sprintf('[^%s%s]+', preg_quote($defaultSeparator, self::REGEX_DELIMITER), $defaultSeparator !== $nextSeparator &&''!== $nextSeparator ? preg_quote($nextSeparator, self::REGEX_DELIMITER) :''); if ((''!== $nextSeparator && !preg_match('#^\{\w+\}#', $followingPattern)) ||''=== $followingPattern) { $regexp .='+'; } } $tokens[] = array('variable', $isSeparator ? $precedingChar :'', $regexp, $varName); $variables[] = $varName; } if ($pos < strlen($pattern)) { $tokens[] = array('text', substr($pattern, $pos)); } $firstOptional = INF; if (!$isHost) { for ($i = count($tokens) - 1; $i >= 0; $i--) { $token = $tokens[$i]; if ('variable'=== $token[0] && $route->hasDefault($token[3])) { $firstOptional = $i; } else { break; } } } $regexp =''; for ($i = 0, $nbToken = count($tokens); $i < $nbToken; $i++) { $regexp .= self::computeRegexp($tokens, $i, $firstOptional); } return array('staticPrefix'=>'text'=== $tokens[0][0] ? $tokens[0][1] :'','regex'=> self::REGEX_DELIMITER.'^'.$regexp.'$'.self::REGEX_DELIMITER.'s','tokens'=> array_reverse($tokens),'variables'=> $variables, ); } private static function findNextSeparator($pattern) { if (''== $pattern) { return''; } $pattern = preg_replace('#\{\w+\}#','', $pattern); return isset($pattern[0]) && false !== strpos(static::SEPARATORS, $pattern[0]) ? $pattern[0] :''; } private static function computeRegexp(array $tokens, $index, $firstOptional) { $token = $tokens[$index]; if ('text'=== $token[0]) { return preg_quote($token[1], self::REGEX_DELIMITER); } else { if (0 === $index && 0 === $firstOptional) { return sprintf('%s(?P<%s>%s)?', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]); } else { $regexp = sprintf('%s(?P<%s>%s)', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]); if ($index >= $firstOptional) { $regexp = "(?:$regexp"; $nbTokens = count($tokens); if ($nbTokens - 1 == $index) { $regexp .= str_repeat(")?", $nbTokens - $firstOptional - (0 === $firstOptional ? 1 : 0)); } } return $regexp; } } } } } namespace Symfony\Bridge\Twig\Extension { use Symfony\Component\Routing\Generator\UrlGeneratorInterface; class RoutingExtension extends \Twig_Extension { private $generator; public function __construct(UrlGeneratorInterface $generator) { $this->generator = $generator; } public function getFunctions() { return array('url'=> new \Twig_Function_Method($this,'getUrl'),'path'=> new \Twig_Function_Method($this,'getPath'), ); } public function getPath($name, $parameters = array(), $relative = false) { return $this->generator->generate($name, $parameters, $relative ? UrlGeneratorInterface::RELATIVE_PATH : UrlGeneratorInterface::ABSOLUTE_PATH); } public function getUrl($name, $parameters = array(), $schemeRelative = false) { return $this->generator->generate($name, $parameters, $schemeRelative ? UrlGeneratorInterface::NETWORK_PATH : UrlGeneratorInterface::ABSOLUTE_URL); } public function getName() { return'routing'; } } } namespace { class Pimple implements ArrayAccess { protected $values = array(); public function __construct (array $values = array()) { $this->values = $values; } public function offsetSet($id, $value) { $this->values[$id] = $value; } public function offsetGet($id) { if (!array_key_exists($id, $this->values)) { throw new InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id)); } $isFactory = is_object($this->values[$id]) && method_exists($this->values[$id],'__invoke'); return $isFactory ? $this->values[$id]($this) : $this->values[$id]; } public function offsetExists($id) { return array_key_exists($id, $this->values); } public function offsetUnset($id) { unset($this->values[$id]); } public static function share(Closure $callable) { return function ($c) use ($callable) { static $object; if (null === $object) { $object = $callable($c); } return $object; }; } public static function protect(Closure $callable) { return function ($c) use ($callable) { return $callable; }; } public function raw($id) { if (!array_key_exists($id, $this->values)) { throw new InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id)); } return $this->values[$id]; } public function extend($id, Closure $callable) { if (!array_key_exists($id, $this->values)) { throw new InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id)); } $factory = $this->values[$id]; if (!($factory instanceof Closure)) { throw new InvalidArgumentException(sprintf('Identifier "%s" does not contain an object definition.', $id)); } return $this->values[$id] = function ($c) use ($callable, $factory) { return $callable($factory($c), $c); }; } public function keys() { return array_keys($this->values); } } } namespace Silex { use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpKernel\HttpKernel; use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpKernel\TerminableInterface; use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\Event\PostResponseEvent; use Symfony\Component\HttpKernel\EventListener\ResponseListener; use Symfony\Component\HttpKernel\EventListener\RouterListener; use Symfony\Component\HttpKernel\Exception\HttpException; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\RedirectResponse; use Symfony\Component\HttpFoundation\StreamedResponse; use Symfony\Component\HttpFoundation\JsonResponse; use Symfony\Component\Routing\RouteCollection; use Symfony\Component\Routing\RequestContext; use Silex\RedirectableUrlMatcher; use Silex\ControllerResolver; use Silex\EventListener\LocaleListener; use Silex\EventListener\MiddlewareListener; use Silex\EventListener\ConverterListener; use Silex\EventListener\StringToResponseListener; class Application extends \Pimple implements HttpKernelInterface, TerminableInterface { const VERSION ='1.0-DEV'; const EARLY_EVENT = 512; const LATE_EVENT = -512; private $providers = array(); private $booted = false; public function __construct(array $values = array()) { parent::__construct(); $app = $this; $this['logger'] = null; $this['routes'] = $this->share(function () { return new RouteCollection(); }); $this['controllers'] = $this->share(function () use ($app) { return $app['controllers_factory']; }); $this['controllers_factory'] = function () use ($app) { return new ControllerCollection($app['route_factory']); }; $this['route_class'] ='Silex\\Route'; $this['route_factory'] = function () use ($app) { return new $app['route_class'](); }; $this['exception_handler'] = $this->share(function () use ($app) { return new ExceptionHandler($app['debug']); }); $this['dispatcher_class'] ='Symfony\\Component\\EventDispatcher\\EventDispatcher'; $this['dispatcher'] = $this->share(function () use ($app) { $dispatcher = new $app['dispatcher_class'](); $urlMatcher = new LazyUrlMatcher(function () use ($app) { return $app['url_matcher']; }); $dispatcher->addSubscriber(new RouterListener($urlMatcher, $app['request_context'], $app['logger'])); $dispatcher->addSubscriber(new LocaleListener($app, $urlMatcher)); if (isset($app['exception_handler'])) { $dispatcher->addSubscriber($app['exception_handler']); } $dispatcher->addSubscriber(new ResponseListener($app['charset'])); $dispatcher->addSubscriber(new MiddlewareListener($app)); $dispatcher->addSubscriber(new ConverterListener($app['routes'])); $dispatcher->addSubscriber(new StringToResponseListener()); return $dispatcher; }); $this['resolver'] = $this->share(function () use ($app) { return new ControllerResolver($app, $app['logger']); }); $this['kernel'] = $this->share(function () use ($app) { return new HttpKernel($app['dispatcher'], $app['resolver']); }); $this['request_context'] = $this->share(function () use ($app) { $context = new RequestContext(); $context->setHttpPort($app['request.http_port']); $context->setHttpsPort($app['request.https_port']); return $context; }); $this['url_matcher'] = $this->share(function () use ($app) { return new RedirectableUrlMatcher($app['routes'], $app['request_context']); }); $this['request_error'] = $this->protect(function () { throw new \RuntimeException('Accessed request service outside of request scope. Try moving that call to a before handler or controller.'); }); $this['request'] = $this['request_error']; $this['request.http_port'] = 80; $this['request.https_port'] = 443; $this['debug'] = false; $this['charset'] ='UTF-8'; $this['locale'] ='en'; foreach ($values as $key => $value) { $this[$key] = $value; } } public function register(ServiceProviderInterface $provider, array $values = array()) { $this->providers[] = $provider; $provider->register($this); foreach ($values as $key => $value) { $this[$key] = $value; } return $this; } public function boot() { if (!$this->booted) { foreach ($this->providers as $provider) { $provider->boot($this); } $this->booted = true; } } public function match($pattern, $to) { return $this['controllers']->match($pattern, $to); } public function get($pattern, $to) { return $this['controllers']->get($pattern, $to); } public function post($pattern, $to) { return $this['controllers']->post($pattern, $to); } public function put($pattern, $to) { return $this['controllers']->put($pattern, $to); } public function delete($pattern, $to) { return $this['controllers']->delete($pattern, $to); } public function on($eventName, $callback, $priority = 0) { $this['dispatcher']->addListener($eventName, $callback, $priority); } public function before($callback, $priority = 0) { $this['dispatcher']->addListener(KernelEvents::REQUEST, function (GetResponseEvent $event) use ($callback) { if (HttpKernelInterface::MASTER_REQUEST !== $event->getRequestType()) { return; } $ret = call_user_func($callback, $event->getRequest()); if ($ret instanceof Response) { $event->setResponse($ret); } }, $priority); } public function after($callback, $priority = 0) { $this['dispatcher']->addListener(KernelEvents::RESPONSE, function (FilterResponseEvent $event) use ($callback) { if (HttpKernelInterface::MASTER_REQUEST !== $event->getRequestType()) { return; } call_user_func($callback, $event->getRequest(), $event->getResponse()); }, $priority); } public function finish($callback, $priority = 0) { $this['dispatcher']->addListener(KernelEvents::TERMINATE, function (PostResponseEvent $event) use ($callback) { call_user_func($callback, $event->getRequest(), $event->getResponse()); }, $priority); } public function abort($statusCode, $message ='', array $headers = array()) { throw new HttpException($statusCode, $message, null, $headers); } public function error($callback, $priority = -8) { $this['dispatcher']->addListener(KernelEvents::EXCEPTION, new ExceptionListenerWrapper($this, $callback), $priority); } public function flush($prefix ='') { $this['routes']->addCollection($this['controllers']->flush($prefix)); } public function redirect($url, $status = 302) { return new RedirectResponse($url, $status); } public function stream($callback = null, $status = 200, $headers = array()) { return new StreamedResponse($callback, $status, $headers); } public function escape($text, $flags = ENT_COMPAT, $charset = null, $doubleEncode = true) { return htmlspecialchars($text, $flags, $charset ?: $this['charset'], $doubleEncode); } public function json($data = array(), $status = 200, $headers = array()) { return new JsonResponse($data, $status, $headers); } public function sendFile($file, $status = 200, $headers = array(), $contentDisposition = null) { if (!class_exists('Symfony\Component\HttpFoundation\BinaryFileResponse')) { throw new \RuntimeException('The "sendFile" method is only supported as of Http Foundation 2.2.'); } return new BinaryFileResponse($file, $status, $headers, true, $contentDisposition); } public function mount($prefix, $controllers) { if ($controllers instanceof ControllerProviderInterface) { $controllers = $controllers->connect($this); } if (!$controllers instanceof ControllerCollection) { throw new \LogicException('The "mount" method takes either a ControllerCollection or a ControllerProviderInterface instance.'); } $this['routes']->addCollection($controllers->flush($prefix)); return $this; } public function run(Request $request = null) { if (null === $request) { $request = Request::createFromGlobals(); } $response = $this->handle($request); $response->send(); $this->terminate($request, $response); } public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true) { if (!$this->booted) { $this->boot(); } $current = HttpKernelInterface::SUB_REQUEST === $type ? $this['request'] : $this['request_error']; $this['request'] = $request; $this->flush(); $response = $this['kernel']->handle($request, $type, $catch); $this['request'] = $current; return $response; } public function terminate(Request $request, Response $response) { $this['kernel']->terminate($request, $response); } } } namespace Silex { use Silex\Exception\ControllerFrozenException; class Controller { private $route; private $routeName; private $isFrozen = false; public function __construct(Route $route) { $this->route = $route; } public function getRoute() { return $this->route; } public function getRouteName() { return $this->routeName; } public function bind($routeName) { if ($this->isFrozen) { throw new ControllerFrozenException(sprintf('Calling %s on frozen %s instance.', __METHOD__, __CLASS__)); } $this->routeName = $routeName; return $this; } public function __call($method, $arguments) { if (!method_exists($this->route, $method)) { throw new \BadMethodCallException(sprintf('Method "%s::%s" does not exist.', get_class($this->route), $method)); } call_user_func_array(array($this->route, $method), $arguments); return $this; } public function freeze() { $this->isFrozen = true; } public function generateRouteName($prefix) { $requirements = $this->route->getRequirements(); $method = isset($requirements['_method']) ? $requirements['_method'] :''; $routeName = $prefix.$method.$this->route->getPattern(); $routeName = str_replace(array('/',':','|','-'),'_', $routeName); $routeName = preg_replace('/[^a-z0-9A-Z_.]+/','', $routeName); return $routeName; } } } namespace Silex { use Symfony\Component\Routing\RouteCollection; use Silex\Controller; class ControllerCollection { protected $controllers = array(); protected $defaultRoute; public function __construct(Route $defaultRoute) { $this->defaultRoute = $defaultRoute; } public function match($pattern, $to) { $route = clone $this->defaultRoute; $route->setPattern($pattern); $route->setDefault('_controller', $to); $this->controllers[] = $controller = new Controller($route); return $controller; } public function get($pattern, $to) { return $this->match($pattern, $to)->method('GET'); } public function post($pattern, $to) { return $this->match($pattern, $to)->method('POST'); } public function put($pattern, $to) { return $this->match($pattern, $to)->method('PUT'); } public function delete($pattern, $to) { return $this->match($pattern, $to)->method('DELETE'); } public function __call($method, $arguments) { if (!method_exists($this->defaultRoute, $method)) { throw new \BadMethodCallException(sprintf('Method "%s::%s" does not exist.', get_class($this->defaultRoute), $method)); } call_user_func_array(array($this->defaultRoute, $method), $arguments); foreach ($this->controllers as $controller) { call_user_func_array(array($controller, $method), $arguments); } return $this; } public function flush($prefix ='') { $routes = new RouteCollection(); foreach ($this->controllers as $controller) { if (!$name = $controller->getRouteName()) { $name = $controller->generateRouteName($prefix); while ($routes->get($name)) { $name .='_'; } $controller->bind($name); } $routes->add($name, $controller->getRoute()); $controller->freeze(); } $routes->addPrefix($prefix); $this->controllers = array(); return $routes; } } } namespace Silex { use Symfony\Component\HttpKernel\Controller\ControllerResolver as BaseControllerResolver; use Symfony\Component\HttpKernel\Log\LoggerInterface; use Symfony\Component\HttpFoundation\Request; class ControllerResolver extends BaseControllerResolver { protected $app; public function __construct(Application $app, LoggerInterface $logger = null) { $this->app = $app; parent::__construct($logger); } protected function doGetArguments(Request $request, $controller, array $parameters) { foreach ($parameters as $param) { if ($param->getClass() && $param->getClass()->isInstance($this->app)) { $request->attributes->set($param->getName(), $this->app); break; } } return parent::doGetArguments($request, $controller, $parameters); } } } namespace Silex\EventListener { use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpKernel\Event\FilterControllerEvent; use Symfony\Component\EventDispatcher\EventSubscriberInterface; use Symfony\Component\Routing\RouteCollection; class ConverterListener implements EventSubscriberInterface { protected $routes; public function __construct(RouteCollection $routes) { $this->routes = $routes; } public function onKernelController(FilterControllerEvent $event) { $request = $event->getRequest(); $route = $this->routes->get($request->attributes->get('_route')); if ($route && $converters = $route->getOption('_converters')) { foreach ($converters as $name => $callback) { $request->attributes->set($name, call_user_func($callback, $request->attributes->get($name), $request)); } } } public static function getSubscribedEvents() { return array( KernelEvents::CONTROLLER =>'onKernelController', ); } } } namespace Silex\EventListener { use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\EventListener\LocaleListener as BaseLocaleListener; use Symfony\Component\Routing\RequestContextAwareInterface; use Silex\Application; class LocaleListener extends BaseLocaleListener { protected $app; public function __construct(Application $app, RequestContextAwareInterface $router = null) { parent::__construct($app['locale'], $router); $this->app = $app; } public function onKernelRequest(GetResponseEvent $event) { parent::onKernelRequest($event); $this->app['locale'] = $event->getRequest()->getLocale(); } } } namespace Silex\EventListener { use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\EventDispatcher\EventSubscriberInterface; use Silex\Application; class MiddlewareListener implements EventSubscriberInterface { protected $app; public function __construct(Application $app) { $this->app = $app; } public function onKernelRequest(GetResponseEvent $event) { $request = $event->getRequest(); $routeName = $request->attributes->get('_route'); if (!$route = $this->app['routes']->get($routeName)) { return; } foreach ((array) $route->getOption('_before_middlewares') as $callback) { $ret = call_user_func($callback, $request, $this->app); if ($ret instanceof Response) { $event->setResponse($ret); return; } elseif (null !== $ret) { throw new \RuntimeException(sprintf('A before middleware for route "%s" returned an invalid response value. Must return null or an instance of Response.', $routeName)); } } } public function onKernelResponse(FilterResponseEvent $event) { $request = $event->getRequest(); $routeName = $request->attributes->get('_route'); if (!$route = $this->app['routes']->get($routeName)) { return; } foreach ((array) $route->getOption('_after_middlewares') as $callback) { $response = call_user_func($callback, $request, $event->getResponse(), $this->app); if ($response instanceof Response) { $event->setResponse($response); } elseif (null !== $response) { throw new \RuntimeException(sprintf('An after middleware for route "%s" returned an invalid response value. Must return null or an instance of Response.', $routeName)); } } } public static function getSubscribedEvents() { return array( KernelEvents::REQUEST => array('onKernelRequest', -1024), KernelEvents::RESPONSE => array('onKernelResponse', 128), ); } } } namespace Silex\EventListener { use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent; use Symfony\Component\EventDispatcher\EventSubscriberInterface; use Symfony\Component\HttpFoundation\Response; class StringToResponseListener implements EventSubscriberInterface { public function onKernelView(GetResponseForControllerResultEvent $event) { $response = $event->getControllerResult(); if (!( null === $response || is_array($response) || $response instanceof Response || (is_object($response) && !method_exists($response,'__toString')) )) { $event->setResponse(new Response((string) $response)); } } public static function getSubscribedEvents() { return array( KernelEvents::VIEW => array('onKernelView', -10), ); } } } namespace Silex { use Symfony\Component\HttpKernel\Debug\ExceptionHandler as DebugExceptionHandler; use Symfony\Component\EventDispatcher\EventSubscriberInterface; use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent; use Symfony\Component\HttpKernel\KernelEvents; class ExceptionHandler implements EventSubscriberInterface { protected $debug; protected $enabled; public function __construct($debug) { $this->debug = $debug; $this->enabled = true; } public function disable() { $this->enabled = false; } public function onSilexError(GetResponseForExceptionEvent $event) { if (!$this->enabled) { return; } $handler = new DebugExceptionHandler($this->debug); $event->setResponse($handler->createResponse($event->getException())); } public static function getSubscribedEvents() { return array(KernelEvents::EXCEPTION => array('onSilexError', -255)); } } } namespace Silex { use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent; use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent; use Silex\Application; class ExceptionListenerWrapper { protected $app; protected $callback; public function __construct(Application $app, $callback) { $this->app = $app; $this->callback = $callback; } public function __invoke(GetResponseForExceptionEvent $event) { $exception = $event->getException(); if (!$this->shouldRun($exception)) { return; } $code = $exception instanceof HttpExceptionInterface ? $exception->getStatusCode() : 500; $response = call_user_func($this->callback, $exception, $code); $this->ensureResponse($response, $event); } protected function shouldRun(\Exception $exception) { if (is_array($this->callback)) { $callbackReflection = new \ReflectionMethod($this->callback[0], $this->callback[1]); } elseif (is_object($this->callback) && !$this->callback instanceof \Closure) { $callbackReflection = new \ReflectionObject($this->callback); $callbackReflection = $callbackReflection->getMethod('__invoke'); } else { $callbackReflection = new \ReflectionFunction($this->callback); } if ($callbackReflection->getNumberOfParameters() > 0) { $parameters = $callbackReflection->getParameters(); $expectedException = $parameters[0]; if ($expectedException->getClass() && !$expectedException->getClass()->isInstance($exception)) { return false; } } return true; } protected function ensureResponse($response, GetResponseForExceptionEvent $event) { if ($response instanceof Response) { $event->setResponse($response); } else { $viewEvent = new GetResponseForControllerResultEvent($this->app['kernel'], $event->getRequest(), $event->getRequestType(), $response); $this->app['dispatcher']->dispatch(KernelEvents::VIEW, $viewEvent); if ($viewEvent->hasResponse()) { $event->setResponse($viewEvent->getResponse()); } } } } } namespace Silex\Exception { class ControllerFrozenException extends \RuntimeException { } } namespace Silex { use Symfony\Component\Routing\RequestContext; use Symfony\Component\Routing\Matcher\UrlMatcherInterface; class LazyUrlMatcher implements UrlMatcherInterface { private $factory; public function __construct(\Closure $factory) { $this->factory = $factory; } public function getUrlMatcher() { $urlMatcher = call_user_func($this->factory); if (!$urlMatcher instanceof UrlMatcherInterface) { throw new \LogicException("Factory supplied to LazyUrlMatcher must return implementation of UrlMatcherInterface."); } return $urlMatcher; } public function match($pathinfo) { return $this->getUrlMatcher()->match($pathinfo); } public function setContext(RequestContext $context) { $this->getUrlMatcher()->setContext($context); } public function getContext() { return $this->getUrlMatcher()->getContext(); } } } namespace Silex\Provider { use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpKernel\HttpKernelInterface; class TwigCoreExtension extends \Twig_Extension { public function getFunctions() { return array('render'=> new \Twig_Function_Method($this,'render', array('needs_environment'=> true,'is_safe'=> array('html'))), ); } public function render(\Twig_Environment $twig, $uri) { $globals = $twig->getGlobals(); $request = $globals['app']['request']; $subRequest = Request::create($uri,'get', array(), $request->cookies->all(), array(), $request->server->all()); if ($request->getSession()) { $subRequest->setSession($request->getSession()); } $response = $globals['app']->handle($subRequest, HttpKernelInterface::SUB_REQUEST, false); if (!$response->isSuccessful()) { throw new \RuntimeException(sprintf('Error when rendering "%s" (Status code is %s).', $request->getUri(), $response->getStatusCode())); } return $response->getContent(); } public function getName() { return'silex'; } } } namespace Silex { interface ServiceProviderInterface { public function register(Application $app); public function boot(Application $app); } } namespace Silex\Provider { use Silex\Application; use Silex\ServiceProviderInterface; use Symfony\Bridge\Twig\Extension\RoutingExtension; use Symfony\Bridge\Twig\Extension\TranslationExtension; use Symfony\Bridge\Twig\Extension\FormExtension; use Symfony\Bridge\Twig\Extension\SecurityExtension; use Symfony\Bridge\Twig\Form\TwigRendererEngine; use Symfony\Bridge\Twig\Form\TwigRenderer; class TwigServiceProvider implements ServiceProviderInterface { public function register(Application $app) { $app['twig.options'] = array(); $app['twig.form.templates'] = array('form_div_layout.html.twig'); $app['twig.path'] = array(); $app['twig.templates'] = array(); $app['twig'] = $app->share(function ($app) { $app['twig.options'] = array_replace( array('charset'=> $app['charset'],'debug'=> $app['debug'],'strict_variables'=> $app['debug'], ), $app['twig.options'] ); $twig = new \Twig_Environment($app['twig.loader'], $app['twig.options']); $twig->addGlobal('app', $app); $twig->addExtension(new TwigCoreExtension()); if ($app['debug']) { $twig->addExtension(new \Twig_Extension_Debug()); } if (class_exists('Symfony\Bridge\Twig\Extension\RoutingExtension')) { if (isset($app['url_generator'])) { $twig->addExtension(new RoutingExtension($app['url_generator'])); } if (isset($app['translator'])) { $twig->addExtension(new TranslationExtension($app['translator'])); } if (isset($app['security'])) { $twig->addExtension(new SecurityExtension($app['security'])); } if (isset($app['form.factory'])) { $app['twig.form.engine'] = $app->share(function ($app) { return new TwigRendererEngine($app['twig.form.templates']); }); $app['twig.form.renderer'] = $app->share(function ($app) { return new TwigRenderer($app['twig.form.engine'], $app['form.csrf_provider']); }); $twig->addExtension(new FormExtension($app['twig.form.renderer'])); $reflected = new \ReflectionClass('Symfony\Bridge\Twig\Extension\FormExtension'); $path = dirname($reflected->getFileName()).'/../Resources/views/Form'; $app['twig.loader']->addLoader(new \Twig_Loader_Filesystem($path)); } } return $twig; }); $app['twig.loader.filesystem'] = $app->share(function ($app) { return new \Twig_Loader_Filesystem($app['twig.path']); }); $app['twig.loader.array'] = $app->share(function ($app) { return new \Twig_Loader_Array($app['twig.templates']); }); $app['twig.loader'] = $app->share(function ($app) { return new \Twig_Loader_Chain(array( $app['twig.loader.array'], $app['twig.loader.filesystem'], )); }); } public function boot(Application $app) { } } } namespace Silex\Provider { use Silex\Application; use Silex\ServiceProviderInterface; use Symfony\Component\Routing\Generator\UrlGenerator; class UrlGeneratorServiceProvider implements ServiceProviderInterface { public function register(Application $app) { $app['url_generator'] = $app->share(function ($app) { $app->flush(); return new UrlGenerator($app['routes'], $app['request_context']); }); } public function boot(Application $app) { } } } namespace Silex { use Symfony\Component\HttpFoundation\RedirectResponse; use Symfony\Component\Routing\Matcher\RedirectableUrlMatcher as BaseRedirectableUrlMatcher; use Symfony\Component\Routing\Matcher\RedirectableUrlMatcherInterface; class RedirectableUrlMatcher extends BaseRedirectableUrlMatcher { public function redirect($path, $route, $scheme = null) { $url = $this->context->getBaseUrl().$path; if ($this->context->getHost()) { if ($scheme) { $port =''; if ('http'=== $scheme && 80 != $this->context->getHttpPort()) { $port =':'.$this->context->getHttpPort(); } elseif ('https'=== $scheme && 443 != $this->context->getHttpsPort()) { $port =':'.$this->context->getHttpsPort(); } $url = $scheme.'://'.$this->context->getHost().$port.$url; } } return array('_controller'=> function ($url) { return new RedirectResponse($url, 301); },'url'=> $url, ); } } } namespace Silex { use Symfony\Component\Routing\Route as BaseRoute; class Route extends BaseRoute { public function __construct($pattern ='', array $defaults = array(), array $requirements = array(), array $options = array()) { parent::__construct($pattern, $defaults, $requirements, $options); } public function assert($variable, $regexp) { $this->setRequirement($variable, $regexp); return $this; } public function value($variable, $default) { $this->setDefault($variable, $default); return $this; } public function convert($variable, $callback) { $converters = $this->getOption('_converters'); $converters[$variable] = $callback; $this->setOption('_converters', $converters); return $this; } public function method($method) { $this->setRequirement('_method', $method); return $this; } public function requireHttp() { $this->setRequirement('_scheme','http'); return $this; } public function requireHttps() { $this->setRequirement('_scheme','https'); return $this; } public function before($callback) { $callbacks = $this->getOption('_before_middlewares'); $callbacks[] = $callback; $this->setOption('_before_middlewares', $callbacks); return $this; } public function after($callback) { $callbacks = $this->getOption('_after_middlewares'); $callbacks[] = $callback; $this->setOption('_after_middlewares', $callbacks); return $this; } } } namespace Sismo { use Symfony\Component\Process\Process; class Builder { private $project; private $baseBuildDir; private $buildDir; private $callback; private $gitPath; private $gitCmds; public function __construct($buildDir, $gitPath, array $gitCmds) { $this->baseBuildDir = $buildDir; $this->gitPath = $gitPath; $this->gitCmds = array_replace(array('clone'=>'clone --progress --recursive %repo% %dir% --branch %localbranch%','fetch'=>'fetch origin','prepare'=>'submodule update --init --recursive','checkout'=>'checkout -q -f %branch%','reset'=>'reset --hard %revision%','show'=>'show -s --pretty=format:%format% %revision%', ), $gitCmds); } public function init(Project $project, $callback = null) { $this->project = $project; $this->callback = $callback; $this->buildDir = $this->baseBuildDir.'/'.$this->getBuildDir($project); } public function build() { file_put_contents($this->buildDir.'/sismo-run-tests.sh', str_replace(array("\r\n","\r"),"\n", $this->project->getCommand())); $process = new Process('sh sismo-run-tests.sh', $this->buildDir); $process->setTimeout(3600); $process->run($this->callback); return $process; } public function getBuildDir(Project $project) { return substr(md5($project->getRepository().$project->getBranch()), 0, 6); } public function prepare($revision, $sync) { if (!file_exists($this->buildDir)) { mkdir($this->buildDir, 0777, true); } if (!file_exists($this->buildDir.'/.git')) { $this->execute($this->getGitCommand('clone'), sprintf('Unable to clone repository for project "%s".', $this->project)); } if ($sync) { $this->execute($this->gitPath.' '.$this->gitCmds['fetch'], sprintf('Unable to fetch repository for project "%s".', $this->project)); } $this->execute($this->getGitCommand('checkout'), sprintf('Unable to checkout branch "%s" for project "%s".', $this->project->getBranch(), $this->project)); if ($sync) { $this->execute($this->gitPath.' '.$this->gitCmds['prepare'], sprintf('Unable to update submodules for project "%s".', $this->project)); } if (null === $revision ||'HEAD'=== $revision) { $revision = null; if (file_exists($file = $this->buildDir.'/.git/HEAD')) { $revision = trim(file_get_contents($file)); if (0 === strpos($revision,'ref: ')) { if (file_exists($file = $this->buildDir.'/.git/'.substr($revision, 5))) { $revision = trim(file_get_contents($file)); } else { $revision = null; } } } if (null === $revision) { throw new BuildException(sprintf('Unable to get HEAD for branch "%s" for project "%s".', $this->project->getBranch(), $this->project)); } } $this->execute($this->getGitCommand('reset', array('%revision%'=> escapeshellarg($revision))), sprintf('Revision "%s" for project "%s" does not exist.', $revision, $this->project)); $process = $this->execute($this->getGitCommand('show', array('%revision%'=> escapeshellarg($revision))), sprintf('Unable to get logs for project "%s".', $this->project)); return explode("\n", trim($process->getOutput()), 4); } protected function getGitCommand($command, array $replace = array()) { $replace = array_merge(array('%repo%'=> escapeshellarg($this->project->getRepository()),'%dir%'=> escapeshellarg($this->buildDir),'%branch%'=> escapeshellarg('origin/'.$this->project->getBranch()),'%localbranch%'=> escapeshellarg($this->project->getBranch()),'%format%'=>'"%H%n%an%n%ci%n%s%n"', ), $replace); return strtr($this->gitPath.' '.$this->gitCmds[$command], $replace); } private function execute($command, $message) { if (null !== $this->callback) { call_user_func($this->callback,'out', sprintf("Running \"%s\"\n", $command)); } $process = new Process($command, $this->buildDir); $process->setTimeout(3600); $process->run($this->callback); if (!$process->isSuccessful()) { throw new BuildException($message); } return $process; } } } namespace Sismo { class BuildException extends \Exception { } } namespace Sismo { class Commit { private $project; private $sha; private $message; private $author; private $date; private $build; private $output; private $buildDate; private $status ='building'; private $statuses = array('building'=>'building','success'=>'succeeded','failed'=>'failed'); public function __construct(Project $project, $sha) { $this->project = $project; $this->sha = $sha; } public function __toString() { return sprintf('%s@%s', $this->project, $this->getShortSha()); } public function isBuilding() { return'building'=== $this->status; } public function isBuilt() { return in_array($this->status, array('success','failed')); } public function isSuccessful() { return'success'=== $this->status; } public function setStatusCode($status) { if (!in_array($status, array('building','success','failed'))) { throw new \InvalidArgumentException(sprintf('Invalid status code "%s".', $status)); } $this->status = $status; } public function getStatusCode() { return $this->status; } public function getStatus() { return $this->statuses[$this->status]; } public function setOutput($output) { $this->output = $output; } public function getOutput() { return $this->output; } public function getMessage() { return $this->message; } public function setMessage($message) { $this->message = $message; } public function getSha() { return $this->sha; } public function getShortSha() { return substr($this->sha, 0, 6); } public function getProject() { return $this->project; } public function getAuthor() { return $this->author; } public function setAuthor($author) { $this->author = $author; } public function getDate() { return $this->date; } public function setDate(\DateTime $date) { $this->date = $date; } public function getBuildDate() { return $this->buildDate; } public function setBuildDate(\DateTime $date) { $this->buildDate = $date; } } } namespace Sismo\Notifier { use Sismo\Commit; abstract class Notifier { abstract public function notify(Commit $commit); protected function format($format, Commit $commit) { return strtr($format, $this->getPlaceholders($commit)); } protected function getPlaceholders(Commit $commit) { $project = $commit->getProject(); return array('%slug%'=> $project->getSlug(),'%name%'=> $project->getName(),'%status%'=> $commit->getStatus(),'%status_code%'=> $commit->getStatusCode(),'%STATUS%'=> strtoupper($commit->getStatus()),'%sha%'=> $commit->getSha(),'%short_sha%'=> $commit->getShortSha(),'%author%'=> $commit->getAuthor(),'%message%'=> $commit->getMessage(),'%output%'=> $commit->getOutput(), ); } } } namespace Sismo\Contrib { use Sismo\Notifier\Notifier; use Sismo\Commit; class XmppNotifier extends Notifier { private $format; private $host; private $port; private $username; private $password; private $server; private $recipient; public function __construct($host, $port, $server, $username, $password, $recipient, $format ='[%STATUS%] %name% %short_sha% -- %message% by %author%') { $this->host = $host; $this->port = $port; $this->server = $server; $this->username = $username; $this->password = $password; $this->recipient = $recipient; $this->format = $format; } public function notify(Commit $commit) { $old = error_reporting(0); $conn = new \XMPPHP_XMPP($this->host, $this->port, $this->username, $this->password,'sismo', $this->server); $conn->connect(); $conn->processUntil('session_start'); $conn->presence(); foreach (explode(',', $this->recipient) as $user) { $conn->message($user, $this->format($this->format, $commit)); } $conn->disconnect(); error_reporting($old); } } } namespace Sismo\Contrib { use Sismo\Commit; use Sismo\Notifier\Notifier; class CrossFingerNotifier extends Notifier { protected $notifiers; public function __construct($notifiers = array()) { if (!is_array($notifiers)) { $notifiers = array($notifiers); } foreach ($notifiers as $notifier) { if(!$notifier instanceof Notifier) { throw new \InvalidArgumentException("Only Sismo\Notifier instance supported"); } $this->notifiers[] = $notifier; } } public function notify(Commit $commit) { if ($this->commitNeedNotification($commit)) { foreach ($this->notifiers as $notifier) { $notifier->notify($commit); } return true; } return false; } protected function commitNeedNotification(Commit $commit) { if (!$commit->isSuccessful()) { return true; } $previousCommit = $commit->getProject()->getLatestCommit(); return !$previousCommit || $previousCommit->getStatusCode() != $commit->getStatusCode(); } } } namespace Sismo\Contrib { class GoogleTalkNotifier extends XmppNotifier { public function __construct($username, $password, $recipient, $format ='[%STATUS%] %name% %short_sha% -- %message% by %author%') { parent::__construct('talk.google.com', 5222,'gmail.com', $username, $password, $recipient, $format); } } } namespace Sismo\Notifier { use Symfony\Component\Process\Process; use Sismo\Commit; class DBusNotifier extends Notifier { public function __construct($format ="[%STATUS%]\n%message%\n%author%") { $this->format = $format; } public function notify(Commit $commit) { $process = new Process(sprintf('notify-send "%s" "%s"', $commit->getProject()->getName(), $this->format($this->format, $commit))); $process->setTimeout(2); $process->run(); if ($process->isSuccessful()) { return; } $process = new Process(sprintf('dbus-send --print-reply --dest=org.freedesktop.Notifications /org/freedesktop/Notifications org.freedesktop.Notifications.Notify string:"sismo" int32:0 string:"" string:"%s" string:"%s" array:string:"" dict:string:"" int32:-1', $commit->getProject()->getName(), $this->format($this->format, $commit))); $process->setTimeout(2); $process->run(); if ($process->isSuccessful()) { return; } } } } namespace Sismo\Notifier { use Sismo\Commit; class GrowlNotifier extends Notifier { private $application; private $address; private $notifications; private $password; private $port; private $registered; private $format; public function __construct($password, $application ='sismo', $address ='localhost', $format ="[%STATUS%]\n%message%\n%author%", $port = 9887) { $this->application = $application; $this->address = $address; $this->password = $password; $this->format = $format; $this->port = $port; $this->registered = false; $this->notifications = array( array('name'=>'Success','enabled'=> true), array('name'=>'Fail','enabled'=> true), ); } public function notify(Commit $commit) { $this->register(); return $this->doNotify($commit->isSuccessful() ?'Success':'Fail', $commit->getProject()->getName(), $this->format($this->format, $commit)); } private function register() { if (true === $this->registered) { return; } $this->registered = true; $data =''; $defaults =''; $nbDefaults = 0; foreach ($this->notifications as $i => $notification) { $data .= pack('n', strlen($notification['name'])).$notification['name']; if ($notification['enabled']) { $defaults .= pack('c', $i); ++$nbDefaults; } } $data = pack('c2nc2', 1, 0, strlen($this->application), count($this->notifications), $nbDefaults).$this->application.$data.$defaults; $this->send($data); } private function doNotify($name, $title, $message) { $data = pack('c2n5', 1, 1, 0, strlen($name), strlen($title), strlen($message), strlen($this->application)).$name.$title.$message.$this->application; $this->send($data); } private function send($data) { $data .= pack('H32', md5($data.$this->password)); $fp = fsockopen('udp://'.$this->address, $this->port); fwrite($fp, $data); fclose($fp); } } } namespace Sismo\Notifier { use Sismo\Commit; class MailNotifier extends Notifier { protected $recipients; protected $subjectFormat; protected $messageFormat; protected $headers; protected $params; public function __construct($recipients, $subjectFormat ='', $messageFormat ='', $headers ='', $params ='') { $this->recipients = $recipients; $this->subjectFormat = $subjectFormat; $this->messageFormat = $messageFormat; $this->headers = $headers; $this->params = $params; } public function notify(Commit $commit) { $subject = $this->format($this->subjectFormat, $commit); $message = $this->format($this->messageFormat, $commit); return $this->sendEmail($this->recipients, $subject, $message, $this->headers, $this->params); } protected function sendEmail($to, $subject, $message, $headers ='', $params ='') { if (is_array($to)) { $to = implode(',', $to); } return mail($to, $subject, $message, $headers, $params); } } } namespace Sismo { use Sismo\Notifier\Notifier; class Project { protected static $defaultCommand ='phpunit'; protected $name; protected $slug; protected $repository; protected $branch ='master'; protected $command; protected $urlPattern; protected $commits = array(); protected $building = false; protected $notifiers = array(); public function __construct($name, $repository = null, $notifiers = array(), $slug = null) { $this->name = $name; $this->slug = $slug ?: $this->slugify($name); $this->command = static::$defaultCommand; if (null !== $repository) { $this->setRepository($repository); } if (!is_array($notifiers)) { $notifiers = array($notifiers); } foreach ($notifiers as $notifier) { $this->addNotifier($notifier); } } public function __toString() { return $this->name; } public function setBuilding($bool) { $this->building = (Boolean) $bool; } public function isBuilding() { return $this->building; } public function addNotifier(Notifier $notifier) { $this->notifiers[] = $notifier; return $this; } public function getNotifiers() { return $this->notifiers; } public function setBranch($branch) { $this->branch = $branch; return $this; } public function getBranch() { return $this->branch; } public function setCommits(array $commits = array()) { $this->commits = $commits; } public function getCommits() { return $this->commits; } public function getLatestCommit() { return $this->commits ? $this->commits[0] : null; } public function getStatusCode() { return !$this->commits ?'no_build': $this->commits[0]->getStatusCode(); } public function getStatus() { return !$this->commits ?'not built yet': $this->commits[0]->getStatus(); } public function getCCStatus() { if (!$this->commits || !$this->commits[0]->isBuilt()) { return'Unknown'; } return $this->commits[0]->isSuccessful() ?'Success':'Failure'; } public function getCCActivity() { return $this->commits && $this->commits[0]->isBuilding() ?'Building':'Sleeping'; } public function getName() { return $this->name; } public function getShortName() { list($name, ) = explode('(', $this->name); return trim($name); } public function getSubName() { if (false !== $pos = strpos($this->name,'(')) { return trim(substr($this->name, $pos + 1, -1)); } return''; } public function getSlug() { return $this->slug; } public function setSlug($slug) { $this->slug = $slug; return $this; } public function getRepository() { return $this->repository; } public function setRepository($url) { if (false !== strpos($url,'@')) { list($url, $branch) = explode('@', $url); $this->branch = $branch; } $this->repository = $url; return $this; } public function getCommand() { return $this->command; } public function setCommand($command) { $this->command = $command; return $this; } public static function setDefaultCommand($command) { self::$defaultCommand = $command; } public function getUrlPattern() { return $this->urlPattern; } public function setUrlPattern($pattern) { $this->urlPattern = $pattern; return $this; } private function slugify($text) { $text = preg_replace('#[^\\pL\d]+#u','-', $text); $text = trim($text,'-'); if (function_exists('iconv')) { $text = iconv('utf-8','us-ascii//TRANSLIT', $text); } $text = strtolower($text); $text = preg_replace('#[^-\w]+#','', $text); if (empty($text)) { throw new \RuntimeException(sprintf('Unable to compute a slug for "%s". Define it explicitly.', $text)); } return $text; } } } namespace Sismo { use Symfony\Component\Process\Process; class GithubProject extends Project { public function setRepository($url) { parent::setRepository($url); if (file_exists($this->getRepository())) { $process = new Process('git remote -v', $this->getRepository()); $process->run(); foreach (explode("\n", $process->getOutput()) as $line) { $parts = explode("\t", $line); if ('origin'== $parts[0] && preg_match('#(?:\:|/|@)github.com(?:\:|/)(.*?)/(.*?)\.git#', $parts[1], $matches)) { $this->setUrlPattern(sprintf('https://github.com/%s/%s/commit/%%commit%%', $matches[1], $matches[2])); break; } } } elseif (preg_match('#^[a-z0-9_-]+/[a-z0-9_-]+$#i', $this->getRepository())) { $this->setUrlPattern(sprintf('https://github.com/%s/commit/%%commit%%', $this->getRepository())); parent::setRepository(sprintf('https://github.com/%s.git', $this->getRepository())); } else { throw new \InvalidArgumentException(sprintf('URL "%s" does not look like a Github repository.', $this->getRepository())); } } } } namespace Sismo { use Symfony\Component\Process\Process; class BitbucketProject extends Project { public function setRepository($url) { parent::setRepository($url); if (file_exists($this->getRepository())) { $process = new Process('git remote -v', $this->getRepository()); $process->run(); foreach (explode("\n", $process->getOutput()) as $line) { $parts = explode("\t", $line); if ('origin'== $parts[0] && preg_match('#(?:\:|/|@)bitbucket.org(?:\:|/)(.*?)/(.*?)\.git#', $parts[1], $matches)) { $this->setUrlPattern(sprintf('https://bitbucket.org/%s/%s/changeset/%%commit%%', $matches[1], $matches[2])); break; } } } elseif (preg_match('#^[a-z0-9_.-]+/[a-z0-9_.-]+$#i', $this->getRepository())) { $repo = preg_split('/\//', $this->getRepository()); $this->setUrlPattern(sprintf('https://bitbucket.org/%s/changeset/%%commit%%', $this->getRepository())); $this->setBitBucketRepository( sprintf('git@bitbucket.org:/%s.git', $this->getRepository()) ); } else { throw new \InvalidArgumentException(sprintf('URL "%s" does not look like a BitBucket repository.', $this->getRepository())); } } public function setBitBucketRepository($url) { $this->repository = $url; } } } namespace Sismo { class SSHProject extends Project { public function setRepository($url) { $this->repository = $url; } } } namespace Sismo { use Sismo\Storage\StorageInterface; class Sismo { const VERSION ='1.0.0'; const FORCE_BUILD = 1; const LOCAL_BUILD = 2; const SILENT_BUILD = 4; private $storage; private $builder; private $projects = array(); public function __construct(StorageInterface $storage, Builder $builder) { $this->storage = $storage; $this->builder = $builder; } public function build(Project $project, $revision = null, $flags = 0, $callback = null) { if ($project->isBuilding() && Sismo::FORCE_BUILD !== ($flags & Sismo::FORCE_BUILD)) { return; } $this->builder->init($project, $callback); list($sha, $author, $date, $message) = $this->builder->prepare($revision, Sismo::LOCAL_BUILD !== ($flags & Sismo::LOCAL_BUILD)); $commit = $this->storage->getCommit($project, $sha); if ($commit && $commit->isBuilt() && Sismo::FORCE_BUILD !== ($flags & Sismo::FORCE_BUILD)) { return; } $commit = $this->storage->initCommit($project, $sha, $author, \DateTime::createFromFormat('Y-m-d H:i:s O', $date), $message); $process = $this->builder->build(); if (!$process->isSuccessful()) { $commit->setStatusCode('failed'); $commit->setOutput(sprintf("\033[31mBuild failed\033[0m\n\n\033[33mOutput\033[0m\n%s\n\n\033[33m Error\033[0m%s", $process->getOutput(), $process->getErrorOutput())); } else { $commit->setStatusCode('success'); $commit->setOutput($process->getOutput()); } $this->storage->updateCommit($commit); if (Sismo::SILENT_BUILD !== ($flags & Sismo::SILENT_BUILD)) { foreach ($project->getNotifiers() as $notifier) { $notifier->notify($commit); } } } public function hasProject($slug) { return isset($this->projects[$slug]); } public function getProject($slug) { if (!isset($this->projects[$slug])) { throw new \InvalidArgumentException(sprintf('Project "%s" does not exist.', $slug)); } return $this->projects[$slug]; } public function addProject(Project $project) { $this->storage->updateProject($project); $this->projects[$project->getSlug()] = $project; } public function getProjects() { return $this->projects; } } } namespace Sismo\Storage { use Sismo\Project; use Sismo\Commit; interface StorageInterface { public function getCommit(Project $project, $sha); public function initCommit(Project $project, $sha, $author, \DateTime $date, $message); public function updateProject(Project $project); public function updateCommit(Commit $commit); public function close(); } } namespace Sismo\Storage { use Sismo\Project; use Sismo\Commit; class Storage implements StorageInterface { private $db; public function __construct(\SQLite3 $db) { $this->db = $db; } public function getCommit(Project $project, $sha) { $stmt = $this->db->prepare('SELECT slug, sha, author, date, build_date, message, status, output FROM `commit` WHERE slug = :slug AND sha = :sha'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':sha', $sha, SQLITE3_TEXT); if (false !== $result = $stmt->execute()) { if (false !== $result = $result->fetchArray(\SQLITE3_ASSOC)) { return $this->createCommit($project, $result); } } return false; } public function initCommit(Project $project, $sha, $author, \DateTime $date, $message) { $stmt = $this->db->prepare('INSERT OR REPLACE INTO `commit` (slug, sha, author, date, message, status, output, build_date) VALUES (:slug, :sha, :author, :date, :message, :status, :output, :build_date)'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':sha', $sha, SQLITE3_TEXT); $stmt->bindValue(':author', $author, SQLITE3_TEXT); $stmt->bindValue(':date', $date->format('Y-m-d H:i:s'), SQLITE3_TEXT); $stmt->bindValue(':message', $message, SQLITE3_TEXT); $stmt->bindValue(':status','building', SQLITE3_TEXT); $stmt->bindValue(':output','', SQLITE3_TEXT); $stmt->bindValue(':build_date','', SQLITE3_TEXT); if (false === $result = $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to save commit "%s" from project "%s".', $sha, $project->getName())); } $commit = new Commit($project, $sha); $commit->setAuthor($author); $commit->setMessage($message); $commit->setDate($date); return $commit; } public function updateProject(Project $project) { $stmt = $this->db->prepare('INSERT OR REPLACE INTO project (slug, name, repository, branch, command, url_pattern) VALUES (:slug, :name, :repository, :branch, :command, :url_pattern)'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':name', $project->getName(), SQLITE3_TEXT); $stmt->bindValue(':repository', $project->getRepository(), SQLITE3_TEXT); $stmt->bindValue(':branch', $project->getBranch(), SQLITE3_TEXT); $stmt->bindValue(':command', $project->getCommand(), SQLITE3_TEXT); $stmt->bindValue(':url_pattern', $project->getUrlPattern(), SQLITE3_TEXT); if (false === $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to save project "%s".', $project->getName())); } $stmt = $this->db->prepare('SELECT sha, author, date, build_date, message, status, output FROM `commit` WHERE slug = :slug ORDER BY build_date DESC LIMIT 100'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); if (false === $results = $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to get latest commit for project "%s".', $project->getName())); } $commits = array(); while ($result = $results->fetchArray(\SQLITE3_ASSOC)) { $commits[] = $this->createCommit($project, $result); } $project->setCommits($commits); $stmt = $this->db->prepare('SELECT COUNT(*) AS count FROM `commit` WHERE slug = :slug AND status = "building"'); $stmt->bindValue(':slug', $project->getSlug(), SQLITE3_TEXT); $building = false; if (false !== $result = $stmt->execute()) { if (false !== $result = $result->fetchArray(\SQLITE3_ASSOC)) { if ($result['count'] > 0) { $building = true; } } } $project->setBuilding($building); } public function updateCommit(Commit $commit) { $stmt = $this->db->prepare('UPDATE `commit` SET status = :status, output = :output, build_date = CURRENT_TIMESTAMP WHERE slug = :slug AND sha = :sha'); $stmt->bindValue(':slug', $commit->getProject()->getSlug(), SQLITE3_TEXT); $stmt->bindValue(':sha', $commit->getSha(), SQLITE3_TEXT); $stmt->bindValue(':status', $commit->getStatusCode(), SQLITE3_TEXT); $stmt->bindValue(':output', $commit->getOutput(), SQLITE3_TEXT); if (false === $stmt->execute()) { throw new \RuntimeException(sprintf('Unable to save build "%s@%s".', $commit->getProject()->getName(), $commit->getSha())); } } private function createCommit($project, $result) { $commit = new Commit($project, $result['sha']); $commit->setAuthor($result['author']); $commit->setMessage($result['message']); $commit->setDate(\DateTime::createFromFormat('Y-m-d H:i:s', $result['date'])); if ($result['build_date']) { $commit->setBuildDate(\DateTime::createFromFormat('Y-m-d H:i:s', $result['build_date'])); } $commit->setStatusCode($result['status']); $commit->setOutput($result['output']); return $commit; } public function close() { $this->db->close(); } public function __destruct() { $this->close(); } } } namespace SensioLabs\AnsiConverter { use SensioLabs\AnsiConverter\Theme\Theme; class AnsiToHtmlConverter { protected $theme; protected $charset; protected $inlineStyles; protected $inlineColors; protected $colorNames; public function __construct(Theme $theme = null, $inlineStyles = true, $charset ='UTF-8') { $this->theme = null === $theme ? new Theme() : $theme; $this->inlineStyles = $inlineStyles; $this->charset = $charset; $this->inlineColors = $this->theme->asArray(); $this->colorNames = array('black','red','green','yellow','blue','magenta','cyan','white','','','brblack','brred','brgreen','bryellow','brblue','brmagenta','brcyan','brwhite', ); } public function convert($text) { $text = preg_replace('#\e\[(K|s|u|2J|2K|\d+(A|B|C|D|E|F|G|J|K|S|T)|\d+;\d+(H|f))#','', $text); $text = htmlspecialchars($text, ENT_QUOTES, $this->charset); $tokens = $this->tokenize($text); foreach ($tokens as $i => $token) { if ('backspace'== $token[0]) { $j = $i; while (--$j >= 0) { if ('text'== $tokens[$j][0] && strlen($tokens[$j][1]) > 0) { $tokens[$j][1] = substr($tokens[$j][1], 0, -1); break; } } } } $html =''; foreach ($tokens as $token) { if ('text'== $token[0]) { $html .= $token[1]; } elseif ('color'== $token[0]) { $html .= $this->convertAnsiToColor($token[1]); } } if ($this->inlineStyles) { $html = sprintf('<span style="background-color: %s; color: %s">%s</span>', $this->inlineColors['black'], $this->inlineColors['white'], $html); } else { $html = sprintf('<span class="ansi_color_fg_black ansi_color_bg_white">%s</span>', $html); } $html = preg_replace('#<span[^>]*></span>#','', $html); return $html; } protected function convertAnsiToColor($ansi) { $bg = 0; $fg = 7; if ('0'!= $ansi) { $options = explode(';', $ansi); foreach ($options as $option) { if ($option >= 30 && $option < 38) { $fg = $option - 30; } elseif ($option >= 40 && $option < 48) { $bg = $option - 40; } elseif (39 == $option) { $fg = 7; } elseif (49 == $option) { $bg = 0; } } if (in_array(1, $options)) { $fg += 10; $bg += 10; } if (in_array(4, $options)) { $text = sprintf('<u>%s</u>', $text); } if (in_array(7, $options)) { $tmp = $fg; $fg = $bg; $bg = $tmp; } } if ($this->inlineStyles) { return sprintf('</span><span style="background-color: %s; color: %s">', $this->inlineColors[$this->colorNames[$bg]], $this->inlineColors[$this->colorNames[$fg]]); } else { return sprintf('</span><span class="ansi_color_bg_%s ansi_color_fg_%s">', $this->colorNames[$bg], $this->colorNames[$fg]); } } protected function tokenize($text) { $tokens = array(); preg_match_all("/(?:\e\[(.+?)m|(\x08))/", $text, $matches, PREG_OFFSET_CAPTURE); $offset = 0; foreach ($matches[0] as $i => $match) { if ($match[1] - $offset > 0) { $tokens[] = array('text', substr($text, $offset, $match[1] - $offset)); } $tokens[] = array("\x08"== $match[0] ?'backspace':'color', $matches[1][$i][0]); $offset = $match[1] + strlen($match[0]); } if ($offset < strlen($text)) { $tokens[] = array('text', substr($text, $offset)); } return $tokens; } } } namespace SensioLabs\AnsiConverter\Theme { class Theme { public function asCss($prefix ='ansi_color') { $css = array(); foreach ($this->asArray() as $name => $color) { $css[] = sprintf('.%s_fg_%s { color: %s }', $prefix, $name, $color); $css[] = sprintf('.%s_bg_%s { background-color: %s }', $prefix, $name, $color); } return implode("\n", $css); } public function asArray() { return array('black'=>'black','red'=>'darkred','green'=>'green','yellow'=>'yellow','blue'=>'blue','magenta'=>'darkmagenta','cyan'=>'cyan','white'=>'white','brblack'=>'black','brred'=>'red','brgreen'=>'lightgreen','bryellow'=>'lightyellow','brblue'=>'lightblue','brmagenta'=>'magenta','brcyan'=>'lightcyan','brwhite'=>'white', ); } } } namespace { use Silex\Application; use Silex\Provider\TwigServiceProvider; use Silex\Provider\UrlGeneratorServiceProvider; use Sismo\Sismo; use Sismo\Project; use Sismo\Storage\Storage; use Sismo\Builder; use Symfony\Component\Process\Process; use Symfony\Component\HttpFoundation\Response; use SensioLabs\AnsiConverter\AnsiToHtmlConverter; $app = new Application(); $app->register(new UrlGeneratorServiceProvider()); $app->register(new TwigServiceProvider(), array( 'twig.path' => __DIR__.'/templates', )); $app['twig'] = $app->share($app->extend('twig', function($twig, $app) { $twig->setCache($app['twig.cache.path']); $twig->addGlobal('ansi_to_html', new AnsiToHtmlConverter()); return $twig; })); $app['data.path'] = getenv('SISMO_DATA_PATH') ?: getenv('HOME').'/.sismo/data'; $app['config.file'] = getenv('SISMO_CONFIG_PATH') ?: getenv('HOME').'/.sismo/config.php'; $app['config.storage.file'] = getenv('SISMO_STORAGE_PATH') ?: getenv('HOME').'/.sismo/storage.php'; $app['build.path'] = $app->share(function ($app) { return $app['data.path'].'/build'; }); $app['db.path'] = $app->share(function ($app) { if (!is_dir($app['data.path'])) { mkdir($app['data.path'], 0777, true); } return $app['data.path'].'/sismo.db'; }); $app['twig.cache.path'] = $app->share(function ($app) { return $app['data.path'].'/cache'; }); $app['git.path'] = getenv('SISMO_GIT_PATH') ?: 'git'; $app['git.cmds'] = array(); $app['db.schema'] = <<<EOF
CREATE TABLE IF NOT EXISTS project (
    slug        TEXT,
    name        TEXT,
    repository  TEXT,
    branch      TEXT,
    command     BLOB,
    url_pattern TEXT,
    PRIMARY KEY (slug)
);

CREATE TABLE IF NOT EXISTS `commit` (
    slug          TEXT,
    sha           TEXT,
    date          TEXT,
    message       BLOB,
    author        TEXT,
    status        TEXT,
    output        BLOB,
    build_date    TEXT DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (slug, sha),
    CONSTRAINT slug FOREIGN KEY (slug) REFERENCES project(slug) ON DELETE CASCADE
);
EOF;
$app['db'] = $app->share(function () use ($app) { $db = new \SQLite3($app['db.path']); $db->busyTimeout(1000); $db->exec($app['db.schema']); return $db; }); $app['storage'] = $app->share(function () use ($app) { if (is_file($app['config.storage.file'])) { $storage = require $app['config.storage.file']; } else { $storage = new Storage($app['db']); } return $storage; }); $app['builder'] = $app->share(function () use ($app) { $process = new Process(sprintf('%s --version', $app['git.path'])); if ($process->run() > 0) { throw new \RuntimeException(sprintf('The git binary cannot be found (%s).', $app['git.path'])); } return new Builder($app['build.path'], $app['git.path'], $app['git.cmds']); }); $app['sismo'] = $app->share(function () use ($app) { $sismo = new Sismo($app['storage'], $app['builder']); if (!is_file($app['config.file'])) { throw new \RuntimeException(sprintf("Looks like you forgot to define your projects.\nSismo looked into \"%s\".", $app['config.file'])); } $projects = require $app['config.file']; if (null === $projects) { throw new \RuntimeException(sprintf('The "%s" configuration file must return an array of Projects (returns null).', $app['config.file'])); } if (!is_array($projects)) { throw new \RuntimeException(sprintf('The "%s" configuration file must return an array of Projects (returns a non-array).', $app['config.file'])); } foreach ($projects as $project) { if (!$project instanceof Project) { throw new \RuntimeException(sprintf('The "%s" configuration file must return an array of Project instances.', $app['config.file'])); } $sismo->addProject($project); } return $sismo; }); $app->error(function (\Exception $e, $code) use ($app) { if ($app['debug']) { return; } $error = 404 == $code ? $e->getMessage() : null; return new Response($app['twig']->render('error.twig', array('error' => $error)), $code); }); }namespace { class FakeTwigLoader implements Twig_LoaderInterface { public function getSource($name) {} public function getCacheKey($name) { static $templates = array( 'ccmonitor.twig.xml' => '/Users/fabien/Code/github/fabpot/Sismo/src/templates/ccmonitor.twig.xml', 'error.twig' => '/Users/fabien/Code/github/fabpot/Sismo/src/templates/error.twig', 'layout.twig' => '/Users/fabien/Code/github/fabpot/Sismo/src/templates/layout.twig', 'project.twig' => '/Users/fabien/Code/github/fabpot/Sismo/src/templates/project.twig', 'projects.twig' => '/Users/fabien/Code/github/fabpot/Sismo/src/templates/projects.twig', ); return $templates[$name]; } public function isFresh($name, $time) { return true; } } $app['twig.loader'] = $app->share(function () { return new FakeTwigLoader(); }); } namespace { class __TwigTemplate_a2f2b90df548de8a724196b71cb9be37 extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = false; $this->blocks = array( ); } protected function doDisplay(array $context, array $blocks = array()) { echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<Projects>
"; $context['_parent'] = (array) $context; $context['_seq'] = twig_ensure_traversable((isset($context["projects"]) ? $context["projects"] : null)); foreach ($context['_seq'] as $context["_key"] => $context["project"]) { $context["commit"] = $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "getLatestCommit"); echo "<Project
  name=\""; echo twig_escape_filter($this->env, (isset($context["project"]) ? $context["project"] : null), "html", null, true); echo "\"
  category=\"\"
  activity=\""; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "ccactivity"), "html", null, true); echo "\"
  lastBuildStatus=\""; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "ccstatus"), "html", null, true); echo "\"
  lastBuildLabel=\"build."; echo twig_escape_filter($this->env, ((((isset($context["commit"]) ? $context["commit"] : null) && $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "built"))) ? ($this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "sha")) : ("Unknown")), "html", null, true); echo "\"
  lastBuildTime=\""; echo twig_escape_filter($this->env, ((((isset($context["commit"]) ? $context["commit"] : null) && $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "built"))) ? ($this->getAttribute($this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "builddate"), "format", array(0 => twig_constant("DATE_ATOM")), "method")) : ("1970-01-01T00:00:00.000000-00:00")), "html", null, true); echo "\"
  webUrl=\""; echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getUrl("project", array("slug" => $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "slug"))), "html", null, true); echo "\"
/>
"; } $_parent = $context['_parent']; unset($context['_seq'], $context['_iterated'], $context['_key'], $context['project'], $context['_parent'], $context['loop']); $context = array_merge($_parent, array_intersect_key($context, $_parent)); echo "</Projects>
"; } public function getTemplateName() { return "ccmonitor.twig.xml"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 62 => 15, 53 => 12, 49 => 11, 45 => 10, 41 => 9, 37 => 8, 32 => 6, 29 => 5, 27 => 4, 23 => 3, 19 => 1,); } } class __TwigTemplate_98f949c841f226019fd77ce1428d26d5 extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = $this->env->loadTemplate("layout.twig"); $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doGetParent(array $context) { return "layout.twig"; } protected function doDisplay(array $context, array $blocks = array()) { $this->parent->display($context, array_merge($this->blocks, $blocks)); } public function block_title($context, array $blocks = array()) { echo "Error"; } public function block_content($context, array $blocks = array()) { echo "    <h1>Hmmm, looks like something went wrong</h1>

    <p id=\"error\">"; echo (((isset($context["error"]) ? $context["error"] : null)) ? (strtr((isset($context["error"]) ? $context["error"] : null), array("
" => "<br />"))) : ("An error occurred")); echo "</p>
"; } public function getTemplateName() { return "error.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 42 => 8, 38 => 6, 35 => 5, 62 => 15, 53 => 12, 49 => 11, 45 => 10, 41 => 9, 37 => 8, 32 => 6, 29 => 3, 27 => 4, 23 => 3, 19 => 1,); } } class __TwigTemplate_57cfa2e2d25dda7065f8132b6e217076 extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = false; $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doDisplay(array $context, array $blocks = array()) { echo "<!DOCTYPE html>
<html>
    <head>
        <meta charset=\"utf-8\" />
        <title>"; $this->displayBlock('title', $context, $blocks); echo " | Sismo</title>
        <link href=\""; echo twig_escape_filter($this->env, $this->getAttribute($this->getAttribute((isset($context["app"]) ? $context["app"] : null), "request"), "baseurl"), "html", null, true); echo "/css/sismo.css\" rel=\"stylesheet\" />
    </head>
    <body>
        <div id=\"content\">
            "; $this->displayBlock('content', $context, $blocks); echo "        </div>
        <footer>
            <span>Powered by <strong><a href=\"http://sismo.sensiolabs.org/\">Sismo</a></strong> "; echo twig_escape_filter($this->env, twig_constant("Sismo\\Sismo::VERSION"), "html", null, true); echo ", your Personal Continuous Testing Server</span>
            <a href=\"http://www.sensiolabs.com/\"><img class=\"png_fix\" src=\""; echo twig_escape_filter($this->env, $this->getAttribute($this->getAttribute((isset($context["app"]) ? $context["app"] : null), "request"), "baseurl"), "html", null, true); echo "/images/sensio-labs-product.png\" alt=\"a Sensio Labs product\" /></a>
        </footer>
    </body>
</html>
"; } public function block_title($context, array $blocks = array()) { echo ""; } public function block_content($context, array $blocks = array()) { echo ""; } public function getTemplateName() { return "layout.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 63 => 10, 57 => 5, 48 => 14, 44 => 13, 40 => 11, 31 => 6, 21 => 1, 42 => 8, 38 => 10, 35 => 5, 62 => 15, 53 => 12, 49 => 11, 45 => 10, 41 => 9, 37 => 8, 32 => 6, 29 => 3, 27 => 5, 23 => 3, 19 => 1,); } } class __TwigTemplate_f2c0e83937c8d83f720ac6c643720bec extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = $this->env->loadTemplate("layout.twig"); $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doGetParent(array $context) { return "layout.twig"; } protected function doDisplay(array $context, array $blocks = array()) { $context["__internal_bf39666edab4b4d72450a22c1791b1634b6bb49d"] = $this; $this->parent->display($context, array_merge($this->blocks, $blocks)); } public function block_title($context, array $blocks = array()) { echo twig_escape_filter($this->env, ("Project " . (isset($context["project"]) ? $context["project"] : null)), "html", null, true); } public function block_content($context, array $blocks = array()) { echo "    <div id=\"back\"><a href=\""; echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("projects"), "html", null, true); echo "\">&laquo; Projects</a></div>

    <h1>
        <a href=\""; echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("project", array("slug" => $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "slug"))), "html", null, true); echo "\">
            "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "shortname"), "html", null, true); echo "
            "; if ($this->getAttribute((isset($context["project"]) ? $context["project"] : null), "subname")) { echo "<small> &mdash; "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "subname"), "html", null, true); echo "</small>"; } echo "        </a>
    </h1>

    "; if ((!(isset($context["commit"]) ? $context["commit"] : null))) { echo "        <p id=\"error\">Never built yet.</p>
    "; } else { echo "        <div class=\"clearfix "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "statuscode"), "html", null, true); echo "\" id=\"build\">"; echo $context["__internal_bf39666edab4b4d72450a22c1791b1634b6bb49d"]->getcommit_block((isset($context["commit"]) ? $context["commit"] : null)); echo "</div>

        "; if ($this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "isbuilt")) { echo "            <div id=\"output\">
                <pre>"; echo (($this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "output")) ? ($this->getAttribute((isset($context["ansi_to_html"]) ? $context["ansi_to_html"] : null), "convert", array(0 => $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "output")), "method")) : ("No output")); echo "</pre>
            </div>
        "; } echo "
        "; if ((array_key_exists("commits", $context) && (isset($context["commits"]) ? $context["commits"] : null))) { echo "            <h1>Builds History</h1>
            <ul id=\"builds\">
                "; $context['_parent'] = (array) $context; $context['_seq'] = twig_ensure_traversable((isset($context["commits"]) ? $context["commits"] : null)); foreach ($context['_seq'] as $context["_key"] => $context["commit"]) { echo "                    <li class=\""; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "statuscode"), "html", null, true); echo "\">"; echo $context["__internal_bf39666edab4b4d72450a22c1791b1634b6bb49d"]->getcommit_block((isset($context["commit"]) ? $context["commit"] : null)); echo "</li>
                "; } $_parent = $context['_parent']; unset($context['_seq'], $context['_iterated'], $context['_key'], $context['commit'], $context['_parent'], $context['loop']); $context = array_merge($_parent, array_intersect_key($context, $_parent)); echo "            </ul>
        "; } echo "    "; } } public function getcommit_block($_commit = null) { $context = $this->env->mergeGlobals(array( "commit" => $_commit, )); $blocks = array(); ob_start(); try { echo "    <div class=\"commit\">"; echo $this->getAttribute($this, "commit_link", array(0 => (isset($context["commit"]) ? $context["commit"] : null)), "method"); echo "</div>
    <h2>
        "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "message"), "html", null, true); echo "
        <span class=\"permalink\"><a href=\""; echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("commit", array("slug" => $this->getAttribute($this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "project"), "slug"), "sha" => $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "sha"))), "html", null, true); echo "\">¶</a></span>
    </h2>
    <div class=\"meta\">
        by <em>"; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "author"), "html", null, true); echo "</em> on <em>"; echo twig_escape_filter($this->env, twig_date_format_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "date"), "j M Y H:i"), "html", null, true); echo "</em>
    </div>
"; } catch (Exception $e) { ob_end_clean(); throw $e; } return ('' === $tmp = ob_get_clean()) ? '' : new Twig_Markup($tmp, $this->env->getCharset()); } public function getcommit_link($_commit = null) { $context = $this->env->mergeGlobals(array( "commit" => $_commit, )); $blocks = array(); ob_start(); try { echo "    "; if ((!$this->getAttribute($this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "project"), "urlpattern"))) { echo "        #"; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "shortsha"), "html", null, true); echo " "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "status"), "html", null, true); echo "
    "; } else { echo "        #<a href=\""; echo twig_escape_filter($this->env, strtr($this->getAttribute($this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "project"), "urlpattern"), array("%commit%" => $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "sha"))), "html", null, true); echo "\">"; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "shortsha"), "html", null, true); echo "</a> "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["commit"]) ? $context["commit"] : null), "status"), "html", null, true); echo "
    "; } } catch (Exception $e) { ob_end_clean(); throw $e; } return ('' === $tmp = ob_get_clean()) ? '' : new Twig_Markup($tmp, $this->env->getCharset()); } public function getTemplateName() { return "project.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 189 => 54, 181 => 52, 178 => 51, 167 => 50, 151 => 46, 145 => 43, 141 => 42, 135 => 40, 124 => 39, 119 => 36, 115 => 34, 104 => 32, 100 => 31, 96 => 29, 94 => 28, 91 => 27, 85 => 24, 82 => 23, 80 => 22, 72 => 20, 68 => 18, 66 => 17, 61 => 14, 55 => 13, 51 => 12, 47 => 11, 26 => 3, 63 => 10, 57 => 5, 48 => 14, 44 => 13, 40 => 8, 31 => 5, 21 => 1, 42 => 8, 38 => 10, 35 => 5, 62 => 15, 53 => 12, 49 => 11, 45 => 10, 41 => 9, 37 => 7, 32 => 6, 29 => 3, 27 => 5, 23 => 3, 19 => 1,); } } class __TwigTemplate_84dbb6408c4f4d511a4fd6939c9349b1 extends Twig_Template { public function __construct(Twig_Environment $env) { parent::__construct($env); $this->parent = $this->env->loadTemplate("layout.twig"); $this->blocks = array( 'title' => array($this, 'block_title'), 'content' => array($this, 'block_content'), ); } protected function doGetParent(array $context) { return "layout.twig"; } protected function doDisplay(array $context, array $blocks = array()) { $this->parent->display($context, array_merge($this->blocks, $blocks)); } public function block_title($context, array $blocks = array()) { echo "Projects"; } public function block_content($context, array $blocks = array()) { echo "    "; if ((!(isset($context["projects"]) ? $context["projects"] : null))) { echo "        <p>No project yet.</p>
    "; } else { echo "        <ul id=\"projects\">
            "; $context['_parent'] = (array) $context; $context['_seq'] = twig_ensure_traversable((isset($context["projects"]) ? $context["projects"] : null)); foreach ($context['_seq'] as $context["i"] => $context["project"]) { echo "                <li class=\""; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "statuscode"), "html", null, true); echo "\">
                    <div class=\"status\">"; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "status"), "html", null, true); echo "</div>
                    <a href=\""; echo twig_escape_filter($this->env, $this->env->getExtension('routing')->getPath("project", array("slug" => $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "slug"))), "html", null, true); echo "\">
                        "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "shortname"), "html", null, true); echo "
                        "; if ($this->getAttribute((isset($context["project"]) ? $context["project"] : null), "subname")) { echo "<small> &mdash; "; echo twig_escape_filter($this->env, $this->getAttribute((isset($context["project"]) ? $context["project"] : null), "subname"), "html", null, true); echo "</small>"; } echo "                    </a>
               </li>
            "; } $_parent = $context['_parent']; unset($context['_seq'], $context['_iterated'], $context['i'], $context['project'], $context['_parent'], $context['loop']); $context = array_merge($_parent, array_intersect_key($context, $_parent)); echo "        </ul>
    "; } } public function getTemplateName() { return "projects.twig"; } public function isTraitable() { return false; } public function getDebugInfo() { return array ( 83 => 19, 75 => 16, 69 => 15, 65 => 14, 52 => 11, 189 => 54, 181 => 52, 178 => 51, 167 => 50, 151 => 46, 145 => 43, 141 => 42, 135 => 40, 124 => 39, 119 => 36, 115 => 34, 104 => 32, 100 => 31, 96 => 29, 94 => 28, 91 => 27, 85 => 24, 82 => 23, 80 => 22, 72 => 20, 68 => 18, 66 => 17, 61 => 13, 55 => 13, 51 => 12, 47 => 11, 26 => 3, 63 => 10, 57 => 12, 48 => 10, 44 => 13, 40 => 8, 31 => 5, 21 => 1, 42 => 8, 38 => 6, 35 => 5, 62 => 15, 53 => 12, 49 => 11, 45 => 9, 41 => 7, 37 => 7, 32 => 6, 29 => 3, 27 => 5, 23 => 3, 19 => 1,); } } } namespace { use Sismo\Sismo; use Sismo\BuildException; use Symfony\Component\Console\Application; use Symfony\Component\Console\Input\InputInterface; use Symfony\Component\Console\Input\InputArgument; use Symfony\Component\Console\Input\InputOption; use Symfony\Component\Console\Output\OutputInterface; use Symfony\Component\Process\ProcessBuilder; $console = new Application('Sismo', Sismo::VERSION); $console ->register('output') ->setDefinition(array( new InputArgument('slug', InputArgument::REQUIRED, 'Project slug'), )) ->setDescription('Displays the latest output for a project') ->setHelp(<<<EOF
The <info>%command.name%</info> command displays the latest output for a project:

    <info>php %command.full_name% twig</info>
EOF
) ->setCode(function (InputInterface $input, OutputInterface $output) use ($app) { $sismo = $app['sismo']; $slug = $input->getArgument('slug'); if (!$sismo->hasProject($slug)) { $output->writeln(sprintf('<error>Project "%s" does not exist.</error>', $slug)); return 1; } $project = $sismo->getProject($slug); if (!$project->getLatestCommit()) { $output->writeln(sprintf('<error>Project "%s" has never been built yet.</error>', $slug)); return 2; } $output->write($project->getLatestCommit()->getOutput()); $now = new \DateTime(); $diff = $now->diff($project->getLatestCommit()->getBuildDate()); if ($m = $diff->format('%i')) { $time = $m.' minutes'; } else { $time = $diff->format('%s').' seconds'; } $output->writeln(''); $output->writeln(sprintf('<info>This output was generated by Sismo %s ago</info>', $time)); }) ; $console ->register('projects') ->setDescription('List available projects') ->setHelp(<<<EOF
The <info>%command.name%</info> command displays the available projects Sismo can build.
EOF
) ->setCode(function (InputInterface $input, OutputInterface $output) use ($app) { $sismo = $app['sismo']; $projects = array(); $width = 0; foreach ($sismo->getProjects() as $slug => $project) { $projects[$slug] = $project->getName(); $width = strlen($project->getName()) > $width ? strlen($project->getName()) : $width; } $width += 2; $output->writeln(''); $output->writeln('<comment>Available projects:</comment>'); foreach ($projects as $slug => $project) { $output->writeln(sprintf("  <info>%-${width}s</info> %s", $slug, $project)); } $output->writeln(''); }) ; $console ->register('build') ->setDefinition(array( new InputArgument('slug', InputArgument::OPTIONAL, 'Project slug'), new InputArgument('sha', InputArgument::OPTIONAL, 'Commit sha'), new InputOption('force', '', InputOption::VALUE_NONE, 'Force the build'), new InputOption('local', '', InputOption::VALUE_NONE, 'Disable remote sync'), new InputOption('silent', '', InputOption::VALUE_NONE, 'Disable notifications'), new InputOption('timeout', '', InputOption::VALUE_REQUIRED, 'Time limit'), new InputOption('data-path', '', InputOption::VALUE_REQUIRED, 'The data path'), new InputOption('config-file', '', InputOption::VALUE_REQUIRED, 'The config file'), )) ->setDescription('Build projects') ->setHelp(<<<EOF
Without any arguments, the <info>%command.name%</info> command builds the latest commit
of all configured projects one after the other:

    <info>php %command.full_name%</info>

The command loads project configurations from
<comment>~/.sismo/config.php</comment>. Change it with the
<info>--config-file</info> option:

    <info>php %command.full_name% --config-file=/path/to/config.php</info>

Data (repository, DB, ...) are stored in <comment>~/.sismo/data/</comment>.
The <info>--data-path</info> option allows you to change the default:

    <info>php %command.full_name% --data-path=/path/to/data</info>

Pass the project slug to build a specific project:

    <info>php %command.full_name% twig</info>

Force a specific commit to be built by passing the SHA:

    <info>php %command.full_name% twig a1ef34</info>

Use <comment>--force</comment> to force the built even if it has already been
built previously:

    <info>php %command.full_name% twig a1ef34 --force</info>

Disable notifications with <comment>--silent</comment>:

    <info>php %command.full_name% twig a1ef34 --silent</info>

Disable repository synchonization with <comment>--local</comment>:

    <info>php %command.full_name% twig a1ef34 --local</info>

Limit the time (in seconds) spent by the command building projects by using
the <comment>--timeout</comment> option:

    <info>php %command.full_name% twig --timeout 3600</info>

When you use this command as a cron job, <comment>--timeout</comment> can avoid
the command to be run concurrently. Be warned that this is a rough estimate as
the time is only checked between two builds. When a build is started, it won't
be stopped if the time limit is over.

Use the <comment>--verbose</comment> option to debug builds in case of a
problem.
EOF
) ->setCode(function (InputInterface $input, OutputInterface $output) use ($app) { if ($input->getOption('data-path')) { $app['data.path'] = $input->getOption('data-path'); } if ($input->getOption('config-file')) { $app['config.file'] = $input->getOption('config-file'); } $sismo = $app['sismo']; if ($slug = $input->getArgument('slug')) { if (!$sismo->hasProject($slug)) { $output->writeln(sprintf('<error>Project "%s" does not exist.</error>', $slug)); return 1; } $projects = array($sismo->getProject($slug)); } else { $projects = $sismo->getProjects(); } $start = time(); $startedOut = false; $startedErr = false; $callback = null; if (OutputInterface::VERBOSITY_VERBOSE === $output->getVerbosity()) { $callback = function ($type, $buffer) use ($output, &$startedOut, &$startedErr) { if ('err' === $type) { if (!$startedErr) { $output->write("\n<bg=red;fg=white> ERR </> "); $startedErr = true; $startedOut = false; } $output->write(str_replace("\n", "\n<bg=red;fg=white> ERR </> ", $buffer)); } else { if (!$startedOut) { $output->write("\n<bg=green;fg=white> OUT </> "); $startedOut = true; $startedErr = false; } $output->write(str_replace("\n", "\n<bg=green;fg=white> OUT </> ", $buffer)); } }; } $flags = 0; if ($input->getOption('force')) { $flags = $flags | Sismo::FORCE_BUILD; } if ($input->getOption('local')) { $flags = $flags | Sismo::LOCAL_BUILD; } if ($input->getOption('silent')) { $flags = $flags | Sismo::SILENT_BUILD; } foreach ($projects as $project) { if ($input->getOption('timeout') && time() - $start > $input->getOption('timeout')) { break; } try { $output->writeln(sprintf('<info>Building Project "%s" (into "%s")</info>', $project, $app['builder']->getBuildDir($project))); $sismo->build($project, $input->getArgument('sha'), $flags, $callback); $output->writeln(''); } catch (BuildException $e) { $output->writeln("\n".sprintf('<error>%s</error>', $e->getMessage())); return 1; } } }) ; $console ->register('run') ->setDefinition(array( new InputArgument('address', InputArgument::OPTIONAL, 'Address:port', 'localhost:9000') )) ->setDescription('Runs Sismo with PHP built-in web server') ->setHelp(<<<EOF
The <info>%command.name%</info> command runs the embedded Sismo web server:

    <info>%command.full_name%</info>

You can also customize the default address and port the web server listens to:

    <info>%command.full_name% 127.0.0.1:8080</info>
EOF
) ->setCode(function (InputInterface $input, OutputInterface $output) use ($console) { if (version_compare(PHP_VERSION, '5.4.0') < 0) { throw new \Exception('This feature only runs with PHP 5.4.0 or higher.'); } $sismo = __DIR__ . '/sismo.php'; while (!file_exists($sismo)) { $dialog = $console->getHelperSet()->get('dialog'); $sismo = $dialog->ask($output, sprintf('<comment>I cannot find "%s". What\'s the absoulte path of "sismo.php"?</comment> ', $sismo), __DIR__ . '/sismo.php'); } $output->writeln(sprintf("Sismo running on <info>%s</info>\n", $input->getArgument('address'))); $builder = new ProcessBuilder(array(PHP_BINARY, '-S', $input->getArgument('address'), $sismo)); $builder->setWorkingDirectory(getcwd()); $builder->setTimeout(null); $builder->getProcess()->run(function ($type, $buffer) use ($output) { if (OutputInterface::VERBOSITY_VERBOSE === $output->getVerbosity()) { $output->write($buffer); } }); }) ; } namespace { use Symfony\Component\HttpFoundation\Response; $app->get('/css/sismo.css', function() { return new Response('/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var,optgroup{font-style:inherit;font-weight:inherit;}del,ins{text-decoration:none;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:\'\';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:baseline;}sub{vertical-align:baseline;}legend{color:#000;}input,button,textarea,select,optgroup,option{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;}input,button,textarea,select{*font-size:100%;}

/* Sismo CSS */
html {
    background-color: #182d33;
}

body {
    font-family: Georgia, serif;
    color: #fff;
    font-size: 16px;
}

em {
    font-style: italic;
}

strong {
    font-weight: bold;
}

h1 {
    font-size: 30px;
    margin-top: 30px;
    margin-bottom: 10px;
}

h1 a {
    color: #fff;
}

h2 {
    font-size: 26px;
}

#builds h2 {
    font-size: 21px;
}

#content, footer {
    width: 780px;
    margin: 0 auto;
    background: #274751;
    padding: 15px 24px;
}

#content {
    padding-top: 160px;
    background: #274751 url(../images/header.png) no-repeat right top;
}

a {
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

.success {
    background: url(../images/success.png) repeat-y !important;
}

.failed {
  background: url(../images/failed.png) repeat-y !important;
}

.success a, .failed a {
    color: #fff !important;
}

#projects {
    margin: 15px 0;
    margin-top: 30px;
}

#projects li {
    position: relative;
    padding: 12px;
    margin-bottom: 5px;
    font-size: 30px;
    vertical-align: bottom;
    border: 3px solid #ccc;
}

#projects li a {
    color: #555;
}

#build {
    padding: 10px 15px;
    margin-bottom: 15px;
    border: 3px solid #ccc;
    background: url(../images/nobuild.png) repeat-y;
}

#build a {
    color: #555;
}

#output {
    margin-bottom: 15px;
}

#output pre {
    background: #111;
    color: #fff;
    padding: 8px;
    overflow: auto;
    max-height: 300px;
    width: 764px;
    font-size: 14px;
}

.meta {
    font-size: 13px;
    font-family: Georgia, serif;
}

#builds li {
    padding: 8px 12px;
    margin-bottom: 5px;
    border: 3px solid #ccc;
    background: url(../images/nobuild.png) repeat-y;
}

#builds li a {
    color: #fff;
}

#builds .meta {
    font-size: 14px;
}

.commit {
    float: right;
    padding-left: 15px;
    padding-bottom: 15px;
    color: #333 !important;
}

.commit a {
    color: #333 !important;
}

.status {
    float: right;
    padding-left: 15px;
    padding-bottom: 15px;
    color: #333 !important;
    font-size: 15px;
}

footer {
    text-align: center;
    font-size: 12px;
    font-family: Arial;
    background: #274751 url(../images/hr.png) no-repeat;
    display: block;
}

footer span {
    margin-right: 40px;
}

footer img {
    margin: 0 4px;
    vertical-align: middle;
}

footer a {
    color: #fff;
}

.clearfix:after { content: "\0020"; display: block; height: 0; clear: both; visibility: hidden; overflow: hidden; }
.clearfix { display: inline-block; }
* html .clearfix { height: 1%; }
.clearfix { display: block; }

#project_command_test {
    width: 100%;
    height: 150px;
}

.permalink {
    font-size: 60%;
}

.permalink a {
    color: #eee !important;
}

#back {
    float: right;
}

#back a {
    color: #ddd;
}

#error {
    margin-top: 30px;
    margin-bottom: 30px;
    position: relative;
    padding: 12px;
    font-size: 22px;
    vertical-align: bottom;
    border: 3px solid #ccc;
}

.ansi_color_fg_black   { color: black; }
.ansi_color_fg_red     { color: red; }
.ansi_color_fg_green   { color: green; }
.ansi_color_fg_yellow  { color: yellow; }
.ansi_color_fg_blue    { color: blue; }
.ansi_color_fg_magenta {  color: magenta; }
.ansi_color_fg_cyan    { color: cyan; }
.ansi_color_fg_white   { color: white; }
.ansi_color_bg_black   { background-color: black; padding: 2px 0; }
.ansi_color_bg_red     { background-color: red; padding: 2px 0; }
.ansi_color_bg_green   { background-color: green; padding: 2px 0; }
.ansi_color_bg_yellow  { background-color: yellow; padding: 2px 0; }
.ansi_color_bg_blue    { background-color: blue; padding: 2px 0; }
.ansi_color_bg_magenta { background-color: magenta; padding: 2px 0; }
.ansi_color_bg_cyan    { background-color: cyan; padding: 2px 0; }
.ansi_color_bg_white   { background-color: white; padding: 2px 0; }
', 200, array('Content-Type' => 'text/css')); });$app->get('/images/failed.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAwYAAAABCAIAAADrSS6mAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgVJREFUeNp0VolxwzAMIzRPV+j+ncqsxBdUHOfOifURBEA6+Pv5FRUAur9EIFDV87U/du3xGjzzuSxm1TaL5OIztNZ69LG1WDn32HQ95sjZfrYAj+iSuJ9ZHzxb4L/l49rRD3LHtmNfSGxFppYrAvNI0H+cNOnsoAVOwBlahtnv9mg4bftBHhTF+DjIjgdhdoSgROIh6dQEUCvr3hewjKgacJZ8xCiVWGAriYdMNvmPQMRMgHZETamZIbGjssPI+gnwaafI/jD5KWNgShNeDlSO0hqFJFudckuwQTIVwwaBaYe2LEKuANLDBODE2hNMpmS4eYGN51m/SCzlxFwZLAexSPOtcFeovLBIykFeC6JNcSt4qeyrKV/O1HEucHVAegpVVjIY1mLyi76ax2Q4IiQY9tDZBJQ9mBqVUY2uqyIcZNOuJEzBuOqry5v6Wpo2DOxNpv0Z+nrC9chqc9ZpqtorqfOU3m1ZzG+/YaipKRXpO6tmAtDmmXFSVbJVwP1KR12QbdoqsfsSojNadwii8f3dQc2cEbJA1yFlg+pF1Z2+2fJSNkK8Ifl8yzAPXafdHokf6slxPrWaq+HP/hF1+upwDJayayXJWZ7JR62UbkUkbpmn3aszxH2ffeOqcbnclUBm+uw2UGNHVcd8g1dE6ffOZz2OV4wI3v4rUEWM8i9sWVz/AgwAVqr1ag5GyKIAAAAASUVORK5CYII='), 200, array('Content-Type' => 'image/png')); });$app->get('/images/header.png', function() { return new Response(base64_decode('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'), 200, array('Content-Type' => 'image/png')); });$app->get('/images/hr.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAzwAAAACCAIAAAASDE75AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAARNJREFUeNrsWFsSwiAMJB3v4lH89v536VrIg5e11LYfOlmmkIZNgNQxGW73xzOcAZomFbG8pV5m9vnJ9MKQismaICoyc5KBjEA2MlMkSlKa5SbUpZ+o5cQDshBnZYUoiDtWWhwsGo2+DpTutjo+lYTeZDN6TMY8j1s5HA6H488BoNfNGLTtXLCM2ErH9gIEa0hPnoEMrEx+eCeqEXJSmibmNTHX2UTTrnAb1EGzSbPNO2FC/QRYBZMlLW+KeKwE660OwCmf8Yq8TtrTgYrtq4UP2dN5Z2/3M1g/aSF4qGLjn7WVbv5P5XA4HA65X7D7CGyUHn1urukD6VauQ4IsXFusFDEIu4obavMuPqZ0+v3P+BJgAMcOofYE4u86AAAAAElFTkSuQmCC'), 200, array('Content-Type' => 'image/png')); });$app->get('/images/nobuild.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAwYAAAABCAIAAADrSS6mAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAchJREFUeNqUVFuSJCEIBO69fxN7bFl5iqI1sVUR1bZikqQp+OfnLyIBMAAyD5g/iDnuzwyuSzOYmXWLPHN8LOVfkiwweKBEow0kAH11DIVFeW2eJBffODiy7AoyNkk4kTkyFm76deZSa2RE2yr1SmljIFlSDQoQQ0QX5yiTGMYMFxCQVybJVUqGWb4sBkm8CVXLnAETmjRwQpv4cQSGMzJWgg126SOJ/EtSXUCryGDBevrKP4KHh0SwrBKadI5MM4WM52Cl0GJj4zog/YqkoR5YesPM2vfqirXYZTdwtY/v0jqAB9ukKZDy2gCLabVYcFgFQSO6BeOL0jIzaV1AoaFT5V3/tVSc4zOkTNRvVQSKq5TPwxvkIhjgvjdt/8EKC5bZCcJgAGURljE2MgiPm460+/m4Mttf3O5yHEXyx1rIkWhdIoRHp0Jd5+3Qq5h59kq6i1abSW0pBXwrv/oZrzZ4+KTMH331qz905KOyo1+1WzBSuw5yEMbmxmvwh2OzCfdy8o5c3dIkuljrSH14plO6Ev6Vf93V5epMrmyPjB835dh1LeHVfPrkta6XqteO0ZvS97m/YF/kX0f/v2brOn8gHPrMwT8BBgDMkjfuxvEtbAAAAABJRU5ErkJggg=='), 200, array('Content-Type' => 'image/png')); });$app->get('/images/success.png', function() { return new Response(base64_decode('iVBORw0KGgoAAAANSUhEUgAAAwYAAAABCAIAAADrSS6mAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAjdJREFUeNpkVQF2JSEIAy+4R+kpey2pCglhtu91/oyCQBLQf37/bQs3i7Dl/t49LJb5Pkvn42xZ/t+/Y5Nf5+cYvzdf5/0a3y1Pu2fh8MvFiPB0zxPP+/PysqmT7ZntE8sqQK4EnukIvwwRzPC43eRzcVdsh3XsyBrOiy8vpwimcMvPzxfsPuwt5OZ7XUyjkGBsq3PKIV6VN4qzdqDz3AqB81yLgL+s9n2cDBO9AFA3fy9kz+bGeeuSALiMcWs3XRPhjPISCGNdYAeVVIaJAxG+CtnhkEJBB95JVp5OQl2qzjQAaClnKTLEnpyKwJYD6/2quI6en5dN8GW7ZFBUFpksUEgA17noV3QlCUVjJXS5vgbCt5wNMV9KqKuztdA+4ADtEKJ8UhOdDGQgu4nOoiXbzVX9qChr7tAObXwTQA7KUQWNJqt0Mql0nNNiMZLoQwnsF9aFmZCauPR0/zRNLStjszwQuFelwcbRzdk7oLWroKhccs2TqcY7BruEkjJFq5r5jAsUJsh0rYV75nCjBWeg2KhiG9EgAoK0NiAEOfSMrkfJPZqLGml8OuqY1VFOMuLlv3wMPvaLDEbXwwsWV+VPd+sSVCp9oKmEwYjp1dBzo5tLND36WkYN25MHfkYo7yBq+9O2oopGyVS3nIffA1VCNsbCOOV/nYihzdpN5wEwnzcUrT76mTHnDOe1pdSMG9OGYhvSUX4QJWsDG3CJZihA1/vF6D97rCnWAa4Kt3Hl6fBP/z8BBgBV6/vMFgEx6QAAAABJRU5ErkJggg=='), 200, array('Content-Type' => 'image/png')); });$app->get('/images/sensio-labs-product.png', function() { return new Response(base64_decode('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'), 200, array('Content-Type' => 'image/png')); });} namespace { use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; $app->get('/', function() use ($app) { return $app['twig']->render('projects.twig', array('projects' => $app['sismo']->getProjects())); })->bind('projects'); $app->get('/{slug}', function($slug) use ($app) { if (!$app['sismo']->hasProject($slug)) { throw new NotFoundHttpException(sprintf('Project "%s" not found.', $slug)); } $project = $app['sismo']->getProject($slug); $commits = $project->getCommits(); $latest = array_shift($commits); return $app['twig']->render('project.twig', array( 'project' => $project, 'commit' => $latest, 'commits' => $commits, )); })->bind('project'); $app->get('/dashboard/cctray.xml', function() use ($app) { $content = $app['twig']->render('ccmonitor.twig.xml', array('projects' => $app['sismo']->getProjects())); return new Response($content, 200, array('content-type' => 'text/xml')); })->bind('ccmonitor'); $app->get('/{slug}/{sha}', function($slug, $sha) use ($app) { if (!$app['sismo']->hasProject($slug)) { throw new NotFoundHttpException(sprintf('Project "%s" not found.', $slug)); } $project = $app['sismo']->getProject($slug); if (!$commit = $app['storage']->getCommit($project, $sha)) { throw new NotFoundHttpException(sprintf('Commit "%s" for project "%s" not found.', $sha, $slug)); } return $app['twig']->render('project.twig', array( 'project' => $project, 'commit' => $commit, )); })->bind('commit'); $app->post('/{slug}/build/{token}', function($slug, $token) use ($app) { $app['sismo']; if (!$server_token = getenv('SISMO_BUILD_TOKEN')) { throw new NotFoundHttpException('Not found.'); } if ($token != $server_token) { throw new AccessDeniedHttpException; } if (!$app['sismo']->hasProject($slug)) { throw new NotFoundHttpException(sprintf('Project "%s" not found.', $slug)); } $project = $app['sismo']->getProject($slug); $app['sismo']->build($project); return sprintf('Triggered build for project "%s".', $slug); })->bind('build'); } namespace { if ('cli' === php_sapi_name()) { $console->run(); } else { $app->run(); } } 